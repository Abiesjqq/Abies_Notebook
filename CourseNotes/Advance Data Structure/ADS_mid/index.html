
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>ADS mid - Abies's Notebook</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20viewBox%3D%220%200%2024%2024%22%3E%3Cpath%20d%3D%22M22%2012a10%2010%200%200%201-10%2010A10%2010%200%200%201%202%2012%2010%2010%200%200%201%2012%202a10%2010%200%200%201%2010%2010M6%2013h8l-3.5%203.5%201.42%201.42L17.84%2012l-5.92-5.92L10.5%207.5%2014%2011H6z%22/%3E%3C/svg%3E');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
      <link rel="stylesheet" href="../../../stylesheets/extra2.css">
    
      <link rel="stylesheet" href="../../../stylesheets/cursor.css">
    
      <link rel="stylesheet" href="../../../stylesheets/info.css">
    
      <link rel="stylesheet" href="../../../stylesheets/create_and_update.css">
    
      <link rel="stylesheet" href="../../../stylesheets/customize.css">
    
      <link rel="stylesheet" href="../../../stylesheets/font.css">
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="teal">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#avl" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="Abies&#39;s Notebook" class="md-header__button md-logo" aria-label="Abies's Notebook" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.19 18H24l-3.86-6H22L15 2l-2.39 3.41L17.92 13h-1.95zM16 12 9 2 2 12h1.86L0 18h7v4h4v-4h7l-3.86-6zm-3.84-2H10.5l3.84 6H3.67l3.86-6H5.84L9 5.5zm.84 9v3h4v-3z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Abies's Notebook
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              ADS mid
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="teal"  aria-label="切换至夜间模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换至夜间模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="teal"  aria-label="切换至日间模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换至日间模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="分享" aria-label="分享" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/Abiesjqq/Abies_Notebook" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    Abies_Notebook
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../.." class="md-tabs__link">
          
  
  
    
  
  Home

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../%E8%87%AA%E5%AD%A6%E8%AE%B0%E5%BD%95/1_index/" class="md-tabs__link">
          
  
  
    
  
  碎碎念

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../note_index/" class="md-tabs__link">
          
  
  
    
  
  课程笔记

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../NoflowersNotes/Noflower_index/" class="md-tabs__link">
          
  
  
    
  
  Noflower的笔记

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../AbiesNotes/Abies_index/" class="md-tabs__link">
          
  
  
    
  
  Abies的笔记

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/4D%E7%94%9F%E6%88%90/L4GM/L4GM/" class="md-tabs__link">
          
  
  
    
  
  论文阅读

        </a>
      </li>
    
  

    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../snippet/links/" class="md-tabs__link">
          
  
  
    
  
  妙妙屋

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Abies&#39;s Notebook" class="md-nav__button md-logo" aria-label="Abies's Notebook" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.19 18H24l-3.86-6H22L15 2l-2.39 3.41L17.92 13h-1.95zM16 12 9 2 2 12h1.86L0 18h7v4h4v-4h7l-3.86-6zm-3.84-2H10.5l3.84 6H3.67l3.86-6H5.84L9 5.5zm.84 9v3h4v-3z"/></svg>

    </a>
    Abies's Notebook
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/Abiesjqq/Abies_Notebook" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    Abies_Notebook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../.." class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
    
    
    
      
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../../%E8%87%AA%E5%AD%A6%E8%AE%B0%E5%BD%95/1_index/" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    
  
    碎碎念
  

    
  </span>
  
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
      
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../note_index/" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    
  
    课程笔记
  

    
  </span>
  
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
      
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../../NoflowersNotes/Noflower_index/" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    
  
    Noflower的笔记
  

    
  </span>
  
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
    
    
    
      
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../../AbiesNotes/Abies_index/" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    
  
    Abies的笔记
  

    
  </span>
  
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
    
    
    
      
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    
  
  
  
    <a href="../../../%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/4D%E7%94%9F%E6%88%90/L4GM/L4GM/" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    
  
    论文阅读
  

    
  </span>
  
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
    
    
    
      
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../../snippet/links/" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    
  
    妙妙屋
  

    
  </span>
  
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#avl" class="md-nav__link">
    <span class="md-ellipsis">
      
        AVL 树
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#splay" class="md-nav__link">
    <span class="md-ellipsis">
      
        Splay 树
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        红黑树
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#b" class="md-nav__link">
    <span class="md-ellipsis">
      
        B+ 树
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      
        倒排索引
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      
        左偏堆
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      
        斜堆
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      
        二项队列
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      
        回溯法
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      
        八皇后问题
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      
        博弈树
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      
        收费公路问题
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      
        井字棋
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      
        分治法
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      
        主定理
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      
        最近点对问题
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      
        背包问题
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      
        矩阵乘法的顺序
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      
        最优二叉搜索树
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      
        全源最短路径
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      
        产品装配问题
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    <span class="md-ellipsis">
      
        动态规划
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    <span class="md-ellipsis">
      
        贪心算法
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    <span class="md-ellipsis">
      
        活动选择问题
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    <span class="md-ellipsis">
      
        哈夫曼编码
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  


  
  


  <h1>ADS mid</h1>

<div class="admonition info reading-info">
<p class="admonition-title">阅读信息</p>
<p><span class="twemoji"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2A10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10h-2a8 8 0 0 1-8 8 8 8 0 0 1-8-8 8 8 0 0 1 8-8V2m6.78 1a.69.69 0 0 0-.48.2l-1.22 1.21 2.5 2.5L20.8 5.7c.26-.26.26-.7 0-.95L19.25 3.2c-.13-.13-.3-.2-.47-.2m-2.41 2.12L9 12.5V15h2.5l7.37-7.38-2.5-2.5Z"></path></svg></span> 约 <strong>6706</strong> 个字&nbsp;&nbsp;<strong>31</strong> 分钟&nbsp;&nbsp;本页总访问量：<span id="busuanzi_value_page_pv">加载中...</span> 次</p>
</div>
<h2 id="avl">AVL 树</h2>
<p>AVL 树的要求：二叉搜索树 + 左右子树的高度差的绝对值小于等于 1。</p>
<p>操作：LL，RR，LR，RL</p>
<p><strong>树高怎么定义？</strong></p>
<p>这里的树高相当于叶节点深度的最大值。空树的树高定义为-1，只有根节点的树的树高定义为 0。</p>
<p><strong>平衡因子怎么定义？</strong></p>
<p>平衡因子 BF 等于左子树的高度减右子树的高度。</p>
<p><strong>AVL 树中节点数和树高的关系？</strong></p>
<p>设 AVL 树的节点数量为 n，则树高为 <span class="arithmatex">\(O(\log n)\)</span>。</p>
<p>为什么？给定树高，最大和最小节点数都为指数级。</p>
<p>最小节点数：各个节点的平衡因子尽量为 1 或 -1，<span class="arithmatex">\(N_h=N_{h-1}+N_{h-2}+1\)</span>。定义斐波那契数列 <span class="arithmatex">\(F_0=0, F_1=1\)</span>，则最小节点数 <span class="arithmatex">\(N_h=F_{h+2}-1\)</span>。
最大节点数：树尽可能饱满，各节点的平衡因子为 0，<span class="arithmatex">\(N(h)=2N(h-1)+1\)</span></p>
<p><strong>插入时可能多个节点的平衡条件被破坏？</strong></p>
<p>可能插入节点到根节点的路径上，平衡全部被破坏。</p>
<p><strong>此时仍可以通过一次旋转恢复平衡？</strong></p>
<p>只需要调整距离最近的一个节点。因为旋转后调整了失衡的局部特征，使失衡不会向上传递。</p>
<p><strong>AVL 树的删除？</strong></p>
<p>按普通 BST 删除 &rarr; 从下到上更新节点的高度 &rarr; 沿着路径向上检测失衡并旋转恢复。</p>
<p>如果出现多个节点失衡，为什么在插入时只要调整一次，但删除时需要调整多次？删除中不能通过旋转使局部恢复平衡。</p>
<p>一次删除中，旋转次数最多为 <span class="arithmatex">\(O(\log n)\)</span> 次（因为向上传递，树高为 <span class="arithmatex">\(O(\log n)\)</span>）。</p>
<p><strong>AVL 树相比于 Splay 树有什么缺点？</strong></p>
<ol>
<li>插入和删除至少 <span class="arithmatex">\(O(\log n)\)</span>，旋转需要额外时间，摊还时间不能保证；</li>
<li>多次访问同一个点没有优势。</li>
</ol>
<div class="admonition examples">
<p class="admonition-title">判断 平衡因子</p>
<p>In an AVL tree, it is impossible to have this situation that the balance factors of a node and both of its children are all <span class="arithmatex">\(-1\)</span>.（T/F）</p>
<hr />
<p>T。构造，可行。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">判断 AVL 树高度</p>
<p>The maximum/minimum height for an AVL tree of 30 nodes is <span class="arithmatex">\(6/4\)</span>. (The height of an empty tree is defined to be <span class="arithmatex">\(-1\)</span>)（T/F）</p>
<hr />
<p>F。分别计算高度为 h 时的最少节点和最多节点数。最大高度为 5 而非 6。</p>
<p>注意只有根节点时树高为 0。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">AVL 树和 Splay 树辨析</p>
<p>Among the following 3 statements about AVL trees and splay trees, how many of them are correct?</p>
<p>(1) In a splay tree, if we only have to find a node without any more operation, it is acceptable that we don't push it to root and hence reduce the operation cost. Otherwise, we must push this node to the root position.</p>
<p>(2) In a splay tree, for any non-root node <span class="arithmatex">\(X\)</span>, its parent <span class="arithmatex">\(P\)</span> and grandparent <span class="arithmatex">\(G\)</span> (guaranteed to exist), the correct operation to splay <span class="arithmatex">\(X\)</span> to <span class="arithmatex">\(G\)</span> is to rotate <span class="arithmatex">\(X\)</span> upward twice.</p>
<p>(3) Splaying roughly halves the depth of most nodes on the access path.</p>
<hr />
<p>（1）错，只是访问也需要伸展到根。</p>
<p>（2）错，第一次是 <span class="arithmatex">\(P\)</span> 转，第二次才是 <span class="arithmatex">\(X\)</span> 转。</p>
<p>（3）对。注意是路径上的节点，而不是所有节点。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">AVL 树删除再插入</p>
<p>Delete a node <span class="arithmatex">\(v\)</span> from an AVL tree <span class="arithmatex">\(T_1\)</span>, we can obtain another AVL tree <span class="arithmatex">\(T_2\)</span>. Then insert <span class="arithmatex">\(v\)</span> into <span class="arithmatex">\(T_2\)</span>, we can obtain another AVL tree <span class="arithmatex">\(T_3\)</span>. Which one(s) of the following statements about <span class="arithmatex">\(T_1\)</span> and <span class="arithmatex">\(T_3\)</span> is(are) true?</p>
<ul>
<li>Ⅰ、If <span class="arithmatex">\(v\)</span> is a leaf node in <span class="arithmatex">\(T_1\)</span>, then <span class="arithmatex">\(T_1\)</span> and <span class="arithmatex">\(T_3\)</span> might be different.</li>
<li>Ⅱ、If <span class="arithmatex">\(v\)</span> is not a leaf node in <span class="arithmatex">\(T_1\)</span>, then <span class="arithmatex">\(T_1\)</span> and <span class="arithmatex">\(T_3\)</span> must be different.</li>
<li>Ⅲ、If <span class="arithmatex">\(v\)</span> is not a leaf node in <span class="arithmatex">\(T_1\)</span>, then <span class="arithmatex">\(T_1\)</span> and <span class="arithmatex">\(T_3\)</span> must be the same.</li>
</ul>
<hr />
<p>I 正确。删除叶节点可能导致旋转，再插入节点时，如果插入路径可能与原路径不同，从而触发不同的旋转。</p>
<p>II、III 错误。must 都不能确定。</p>
</div>
<h2 id="splay">Splay 树</h2>
<p>Splay 树的要求：每次访问后将访问的节点 splay 到根上。</p>
<p>操作：zig，zig-zag，zig-zig</p>
<p><strong>什么时候进行 splay 操作？</strong></p>
<ol>
<li>插入：插入后将插入的节点 splay 到根。</li>
<li>查询：若成功查找到节点 x，则将 x 伸展到根；若查找失败，则将搜索路径的最后一个节点伸展到根。</li>
<li>删除：找到删除的节点 x，将 x 伸展到根 &rarr; 删除根节点后，得到两棵子树 L 和 R &rarr; 若 L 非空，查找 L 中最大节点（这一步将最大节点伸展到根，得到的结果没有右子树） &rarr; 将 R 作为右子树接上。</li>
</ol>
<p>Splay 树的删除中，将 x 伸展到根并删除根节点后，可选择 L 中最大的节点，也可选择 R 中最小的节点。</p>
<p><strong>zig，zig-zag，zig-zig 操作相比于普通旋转有什么区别？</strong></p>
<p>普通旋转指每次只调整访问的节点和其父亲节点。在顺序插入时，这种旋转后的树仍为链表。zig，zig-zag 操作和普通旋转相同，但 zig-zig 操作先转祖父节点、再转父节点。顺序插入再依次查找时，查找过程顺便将树高减半。</p>
<p><strong>摊还分析的三种方法？</strong></p>
<ol>
<li>聚合分析(aggregate analysis)：计算总成本除以操作次数。</li>
<li>核分析（accounting method）：给每个操作分配摊还费用，多余的费用作为 credit。每个操作对 credit 的影响等于摊还费用减实际成本。需要保证 credit 大于零。</li>
<li>势能分析（potential method）：对状态定义势能函数，总摊还成本等于实际成本加势能的变化量。</li>
</ol>
<p>esp. Multipop stack 的分析：</p>
<ol>
<li>聚合分析：分析得到总时间为 <span class="arithmatex">\(O(n)\)</span>。</li>
<li>核分析：定义 push 的费用为 2，pop 和 multipop 的费用为 0。</li>
<li>势能分析：定义势能函数为栈中元素个数。</li>
</ol>
<p><strong>Splay 树的势能分析？</strong></p>
<p>定义势能函数为 <span class="arithmatex">\(\Phi(T)=\sum_{i\in T}\log S(i)=\sum_{i\in T}Rank(i)\)</span>，其中 <span class="arithmatex">\(S(i)\)</span> 表示以 i 为根（包括 i）的子树中节点个数，<span class="arithmatex">\(Rank(i)=\log S(i)\)</span>。</p>
<p>结论：将节点 x 伸展到根的最大摊还代价是 <span class="arithmatex">\(3(Rank_2(x)-Rank_1(x))+1\)</span>。</p>
<p><strong>为什么不能用树高作为 Splay 树的势能函数？</strong></p>
<p>Splay 操作会导致树高剧烈变化，树高变化与单次操作的复杂度没有互补关系，每次操作的树高变化没有上界。</p>
<p>势能函数需要使实际成本最大的那一步，势能变化为负值且变化大，两者相加后将这一步的摊还成本控制在一定范围内。</p>
<div class="admonition examples">
<p class="admonition-title">势能函数的选择 1</p>
<p>A queue can be implemented by using two stacks SA and SB as follows:</p>
<ul>
<li>To enqueue x, we push a onto SA.</li>
<li>To dequeue from the queue, we pop and return the top item from SB. However, if SB is empty, we first fill it (and empty SA) by popping the top item from SA, pushing this item onto SB, and repeat until SA is empty.</li>
</ul>
<p>Assuming that push and pop operations take <span class="arithmatex">\(O(1)\)</span> worst-case time, please select a potential function <span class="arithmatex">\(\Phi\)</span> which can help us prove that enqueue and dequeue operations take <span class="arithmatex">\(O(1)\)</span> amortized time(when starting from an empty queue).</p>
<p>A. <span class="arithmatex">\(\Phi= 2|SA|\)</span>
B. <span class="arithmatex">\(\Phi= |SA|\)</span>
C. <span class="arithmatex">\(\Phi= 2|SB|\)</span>
D. <span class="arithmatex">\(\Phi= |SB|\)</span></p>
<hr />
<p>实际成本最大的步骤为 SB 为空时的 pop，此时实际成本为 <span class="arithmatex">\(2|SA|\)</span>，因此这一步的势能变化应为 <span class="arithmatex">\(-2|SA|+C\)</span>。选A。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">势能函数的选择 2</p>
<p>You are to maintain a collection of lists and to support the following operations.</p>
<ol>
<li>insert(item, list): insert item into list (cost = 1).</li>
<li>sum(list): sum the items in list, and replace the list with a list containing one item that is the sum (cost = length of list).</li>
</ol>
<p>We show that the amortized cost of an insert operation is <span class="arithmatex">\(O(1)\)</span> and the amortized cost of a sum operation is <span class="arithmatex">\(O(1)\)</span>. If we assume the potential function to be the number of elements in the list, which of the following is FALSE?</p>
<p>A. For insert, the actual cost is 1.
B. For insert, the change in potential is 1. The amortized cost is 2.
C. For sum, the actual cost is k.
D. For sum, the change cost is 2 − k. The amortized cost is 2.</p>
<hr />
<p>actual cost 表示实际成本，amortized cost 表示摊还成本。</p>
<p>AB：插入的实际成本为 1，势能变化为 1，摊还成本为 2。
CD：设 list 的长度为 k。sum 的实际成本为 k，势能变化为 -(k-1)，摊还成本为 1。</p>
<p>选 D。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">判断 Splay 树的高度</p>
<p>All of the Zig, Zig-zig, and Zig-zag rotations in a splay tree not only move the accessed node to the root, but also roughly half the depth of most nodes in the tree. （T/F）</p>
<hr />
<p>F。伸展操作只保证把被访问的节点移动到根，将根到访问节点的路径上的节点的 Rank 近似减少一半（也可说成路径上的深度大致减半），不保证所有其他节点的深度都减少一半</p>
</div>
<h2 id="_1">红黑树</h2>
<p>红黑树的要求：节点红或黑，根节点黑，NIL 黑，红色节点不相邻，每个节点到任意 NIL 的路径上黑色节点数相同。</p>
<p><strong>黑高怎么定义？</strong></p>
<p>对于任意节点 x，其黑高为 x 到任意 NIL 的路径上黑色节点的个数（不包括 x，但包括 NIL）。</p>
<p><strong>红色节点的子节点一定都是 NIL 或都不是 NIL？</strong></p>
<p>假设只有一个是 NIL，则根节点到这个 NIL 的距离和经过另一个黑色孩子到 NIL 的距离不相等，违反黑高特性。</p>
<p><strong>红黑树中节点数和树高的关系？</strong></p>
<p>设红黑树的节点数量为 n，则树高最大为 <span class="arithmatex">\(2\log_2 (n+1)\)</span>。</p>
<p>为什么？设 <span class="arithmatex">\(bh\)</span> 表示黑高，<span class="arithmatex">\(bh\le \frac{h}{2}\)</span>，根节点到所有 NIL 的长度至少为 <span class="arithmatex">\(bh\)</span>，故 <span class="arithmatex">\(N\ge 2^{bh}-1\)</span>，化简得到上式。</p>
<p>课件中的证明：归纳法。首先，只有 NIL 节点时 <span class="arithmatex">\(bh\)</span> 为零，总节点数为零。归纳对于任意高度为 <span class="arithmatex">\(k+1\)</span> 的节点 x，它孩子的黑高为 <span class="arithmatex">\(bh(x)\)</span> 或 <span class="arithmatex">\(bh(x)-1\)</span>，故子树节点数 <span class="arithmatex">\(size(child) \ge 2^{bh(child)}-1\ge 2^{bh(x)-1}-1\)</span>，以当前节点为根的子树总节点数 <span class="arithmatex">\(size(x)\ge 1+2size(child)=2^{bh(x)}-1\)</span>。</p>
<p>另外，从某节点到其后代叶节点的所有简单路径中，最长的一条路径的长度至少是最短一条的 2 倍。</p>
<p><strong>红黑树的插入？</strong></p>
<p>插入节点默认红色节点，按二叉搜索树特性找到插入位置。只可能违反红色节点不相邻的条件，即父亲为红色。</p>
<ol>
<li>叔叔也为红色：父亲、叔叔这一层变为黑色，爷爷变为红色，上移判断。</li>
<li>叔叔为黑色，且爷爷-父亲-插入节点为 LR 或 RL：一次旋转，转为第三种。</li>
<li>叔叔为黑色，且爷爷-父亲-插入节点为 LL 或 RR：上面的红色节点和爷爷颜色互换，再将父亲转到根。</li>
</ol>
<p><strong>红黑树中，从空树开始连续插入 n 个节点（n&gt;1），一定会出现红色节点吗？</strong></p>
<p>会。n=2 时有红色节点。再继续插入，插入为红色节点，调整过程中红色节点保留。</p>
<p><strong>红黑树的删除？</strong></p>
<p>只考虑删除节点有一个孩子的情况。此时问题为删除节点为黑色，且子节点为黑色或 NIL。</p>
<p>将删除后接替的节点定义为双黑节点。</p>
<ol>
<li>兄弟是红色：兄弟和父亲颜色互换，将兄弟转到父亲的位置，转为 234 中的一种。</li>
<li>兄弟是黑色，且兄弟的孩子都是黑色：双黑和兄弟这一层黑度减一（兄弟变红），双黑的一个黑度上移到父亲。</li>
<li>兄弟是黑色，兄弟有孩子是红色，且父亲-兄弟-红孩子为 LR 或 RL：红孩子和兄弟的颜色互换，红孩子向上转到兄弟的位置，转为情况 4。</li>
<li>兄弟是黑色，兄弟有孩子是红色，且父亲-兄弟-红孩子为 LL 或 RR：将兄弟和父亲颜色互换，兄弟转到根，红孩子染黑（补偿原来兄弟的黑色），双黑变单黑（路径上增加了原来兄弟的黑色）。</li>
</ol>
<p>情况 34 中 4 优先。</p>
<p>如果要删除节点为 x 且 x 的孩子均为黑，则双黑标记在 x 的位置。</p>
<p>红黑树删除的时间复杂度：最多 3 次旋转（1-&gt;3-&gt;4），情况 2 中向上推进的次数最多为树高 <span class="arithmatex">\(O(\log n)\)</span>，故删除的 TC 为 <span class="arithmatex">\(O(\log n)\)</span>。</p>
<p><strong>红黑树中旋转次数？</strong></p>
<p>插入最多 2 次，删除最多 3 次。</p>
<div class="admonition examples">
<p class="admonition-title">判断 红色节点数</p>
<p>In a red-black tree with 3 nodes, there must be a red node.（T/F）</p>
<hr />
<p>F。虽然空树插入三个节点为黑红红，但可能通过后续操作使其变成黑黑黑。如：插入一个数、再删除插入的数。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">红黑树判断</p>
<p>If we insert <span class="arithmatex">\(N\)</span> (<span class="arithmatex">\(N \geq 2\)</span>) nodes (with different integer elements) consecutively to build a red-black tree <span class="arithmatex">\(T\)</span> from an empty tree, which of the following situations is possible:</p>
<ul>
<li>A. All nodes in <span class="arithmatex">\(T\)</span> are black</li>
<li>B. The number of leaf nodes (NIL) in <span class="arithmatex">\(T\)</span> is <span class="arithmatex">\(2N - 1\)</span></li>
<li>C. <span class="arithmatex">\(2N\)</span> rotations occurred during the construction of <span class="arithmatex">\(T\)</span></li>
<li>D. The height of <span class="arithmatex">\(T\)</span> is <span class="arithmatex">\(\lceil 3\log_2(N + 1)\rceil\)</span> (assume the height of the empty tree is 0)</li>
</ul>
<hr />
<p>A 错。从空树连续插入，两个节点以上的红黑树中一定有红色节点。</p>
<p>B 对。NIL 数等于内部节点数加一，N=2 时满足。</p>
<p>C 错。红黑树中一次插入最多旋转 2 次，因为每组旋转后局部已满足性质，不会向上传播。</p>
<p>D 错。由于黑高的限制，红黑树高度最大为 <span class="arithmatex">\(2\log_2(N + 1)\)</span></p>
</div>
<div class="admonition examples">
<p class="admonition-title">红黑树的势能分析</p>
<p>There are four basic operations on red-black trees that perform structural modifications: node insertions, node deletions, rotations, and color changes. We shall prove that any sequence of <span class="arithmatex">\(m\)</span> RB-INSERT and RB-DELETE operations on an initially empty red-black tree causes <span class="arithmatex">\(O(m)\)</span> structural modifications in the worst case. We count the structural modifications in each step (e.g. Case 1 in RB-DELETION) as one unit operation (cost = 1).</p>
<p>We define the weight of each node based on its state, and the potential of the Red-Black Tree <span class="arithmatex">\(T\)</span> is represented by the following function:</p>
<p><span class="arithmatex">\(\Phi(T) = \sum_{x \in T} g(x)\)</span></p>
<p>where <span class="arithmatex">\(g(x)\)</span> is calculated for all nodes <span class="arithmatex">\(x \in T\)</span> of the Red-Black Tree.</p>
<p>We define the weight of a red node <span class="arithmatex">\(x\)</span> as <span class="arithmatex">\(g(x) = 0\)</span>.</p>
<p>For black nodes, which of the following definitions work?</p>
<p>A.</p>
<ul>
<li><span class="arithmatex">\(g(x) = 1\)</span>: If the black node has no red children.</li>
<li><span class="arithmatex">\(g(x) = 0\)</span>: If the black node has one red child.</li>
<li><span class="arithmatex">\(g(x) = 2\)</span>: If the black node has two red children.</li>
</ul>
<p>B.</p>
<ul>
<li><span class="arithmatex">\(g(x) = 1\)</span>: If the black node has no red children or one red child.</li>
<li><span class="arithmatex">\(g(x) = 2\)</span>: If the black node has two red children.</li>
</ul>
<p>C.</p>
<ul>
<li><span class="arithmatex">\(g(x) = 0\)</span>: If the black node has no red children.</li>
<li><span class="arithmatex">\(g(x) = 1\)</span>: If the black node has one red child.</li>
<li><span class="arithmatex">\(g(x) = 2\)</span>: If the black node has two red children.</li>
</ul>
<p>D.</p>
<ul>
<li><span class="arithmatex">\(g(x) = 1\)</span>: If the black node has no red children.</li>
<li><span class="arithmatex">\(g(x) = 2\)</span>: If the black node has one red child.</li>
<li><span class="arithmatex">\(g(x) = 0\)</span>: If the black node has two red children.</li>
</ul>
<hr />
<p>C。</p>
<p>摊还分析要求代价小的操作势能差大、代价大的操作势能差小。势能对于状态定义，需要反映状态“坏”的程度，当树被修复（旋转、变色）时势能下降。红黑树中的“坏结构”为黑色节点有红孩子，因为红黑树的修复机制都是围绕着“红色太多”展开的，红色节点后插入可能导致红色节点相邻，引发修复。删除黑节点会造成 double-black，但删除触发修复的关键在兄弟节点有没有红孩子、兄弟节点是否是红色、叔侄子是否红色等，仍由红色结构决定。因此，结构越“坏”， <span class="arithmatex">\(g(x)\)</span> 也要越大。</p>
</div>
<h2 id="b">B+ 树</h2>
<p>B+ 树的要求：对 M 阶 B+ 树，根节点有 2~M 个孩子，非叶节点有 <span class="arithmatex">\(\lceil\frac{M}{2} \rceil\)</span>~M 个孩子，所有叶节点在同一层。</p>
<p><strong>B+ 树中节点的含义？</strong></p>
<p>所有非叶节点中的元素仅用于查找。所有实际值都按从小到大的顺序存储在叶节点中。</p>
<p>如果某节点有 n 个孩子，则该节点内部有 M 个指针和 M-1 个数值。指针的前 n 个分别指向 n 个孩子，数值的前 n-1 个中第 i 个元素表示第 i+1 个孩子的最小值（第一个值）。</p>
<p><strong>B+ 树的查找？</strong></p>
<p>检查非叶节点中的数值，如果大于等于当前值、小于下一个值，就移动到对应的孩子。</p>
<p><strong>B+ 树的插入？</strong></p>
<p>空树中插入一个节点，给节点既是叶节点也是根节点。当插入节点是 <span class="arithmatex">\(M+1\)</span> 个时，分裂产生表示索引的根节点。</p>
<p>先找到插入的位置，判断是否需要分裂。</p>
<p>叶节点的分裂：如果叶节点中元素为 <span class="arithmatex">\(M+1\)</span> 个，则在 <span class="arithmatex">\(\lceil\frac{M}{2} \rceil\)</span> 个元素右边分割，将右叶子第一个元素上移到父节点，并在父节点中增加指向右叶子的指针。</p>
<p>中间节点的分裂：第 <span class="arithmatex">\(\lceil\frac{M}{2} \rceil\)</span> 个元素上移到父节点作为索引。</p>
<p>根节点的分裂：第 <span class="arithmatex">\(\lceil\frac{M}{2} \rceil\)</span> 个元素上移作为新的根，其余分裂为两个节点（左子树和右子树）。</p>
<p>（插入时即使不分裂也可能需要更新上层节点？）永远插入到搜索到的叶节点中，如果插入数值小于搜索到叶节点的最小值，则放在最左边。</p>
<p><strong>B+ 树插入和查询的时间复杂度？</strong></p>
<p>M 阶 B+ 树共 <span class="arithmatex">\(O(\log_{\lceil M/2 \rceil}N)\)</span> 层，每次操作最多改变一组叶节点，数量为 <span class="arithmatex">\(O(M)\)</span>，故整体时间复杂度为 <span class="arithmatex">\(O(\frac{M}{\log M}\log N)\)</span>。</p>
<p>查询的时间复杂度等于树高乘每层的操作数，树高为 <span class="arithmatex">\(O(\log_MN)\)</span>，每层需比较 <span class="arithmatex">\(O(\log M)\)</span> 次，总时间复杂度为 <span class="arithmatex">\(O(\log_MN\cdot \log M)=O(\log N)\)</span>。课件中写的是 <span class="arithmatex">\(O(\log N)\)</span>（<span class="arithmatex">\(M\)</span> 固定）。</p>
<div class="admonition examples">
<p class="admonition-title">插入的分裂次数</p>
<p>To perform Insert on a B+ tree of order <span class="arithmatex">\(M\)</span>, a node with <span class="arithmatex">\(M+1\)</span> keys will be split into 2 nodes. After inserting <span class="arithmatex">\(1, 2, 3, \dots, 9, 10\)</span> consecutively into an initially empty B+ tree of order 3, how many split operations have occurred in total?</p>
<hr />
<p>5 次。分裂次数为叶节点分裂和中间节点分裂之和。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">B+ 树节点个数</p>
<p>A 2-3 tree with 3 nonleaf nodes must have 18 keys at most.（T/F）</p>
<hr />
<p>T。这里的 key 指叶节点中存储的数值。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">B+ 树节点个数 2</p>
<p>A B+ tree of order 3 with 21 numbers has at least __ nodes of degree 2.</p>
<hr />
<p>0。尝试构造 B+ 树，使得所有中间节点都有 3 个孩子，能构造出。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">B+ 树判定</p>
<p>The teacher wants to write the <code>IsBpT</code> function to check if the trees submitted by students satisfy the definition of the B+ tree of a given order (e.g., order 4) learned in our class. The B+ tree structure is defined as follows:</p>
<div class="highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">C</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-0-1">1</a></span>
<span class="normal"><a href="#__codelineno-0-2">2</a></span>
<span class="normal"><a href="#__codelineno-0-3">3</a></span>
<span class="normal"><a href="#__codelineno-0-4">4</a></span>
<span class="normal"><a href="#__codelineno-0-5">5</a></span>
<span class="normal"><a href="#__codelineno-0-6">6</a></span>
<span class="normal"><a href="#__codelineno-0-7">7</a></span>
<span class="normal"><a href="#__codelineno-0-8">8</a></span>
<span class="normal"><a href="#__codelineno-0-9">9</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-0-1" name="__codelineno-0-1"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">BpTNode</span><span class="w"> </span><span class="n">BpTNode</span><span class="p">;</span>
<a id="__codelineno-0-2" name="__codelineno-0-2"></a><span class="k">struct</span><span class="w"> </span><span class="nc">BpTNode</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-0-3" name="__codelineno-0-3"></a><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">isLeaf</span><span class="p">;</span><span class="w"> </span><span class="cm">/* 1 if this node is a leaf, or 0 if not */</span>
<a id="__codelineno-0-4" name="__codelineno-0-4"></a><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">isRoot</span><span class="p">;</span><span class="w"> </span><span class="cm">/* 1 if this node is the root, or 0 if not */</span>
<a id="__codelineno-0-5" name="__codelineno-0-5"></a><span class="w">    </span><span class="n">BpTNode</span><span class="o">**</span><span class="w"> </span><span class="n">children</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Pointers to children. This field is not used by leaf nodes. */</span>
<a id="__codelineno-0-6" name="__codelineno-0-6"></a><span class="w">    </span><span class="n">ElementType</span><span class="o">*</span><span class="w"> </span><span class="n">keys</span><span class="p">;</span>
<a id="__codelineno-0-7" name="__codelineno-0-7"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_children</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Number of valid children (not NULL) */</span>
<a id="__codelineno-0-8" name="__codelineno-0-8"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_keys</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Number of valid keys */</span>
<a id="__codelineno-0-9" name="__codelineno-0-9"></a><span class="p">};</span>
</code></pre></div></td></tr></table></div>
<p>Fortunately, the students are all brilliant, so the B+ trees they submit guarantee to meet the following properties:</p>
<ul>
<li>There is a root node, and all leaf nodes are at the same depth;</li>
<li>The key values stored in all leaf nodes are arranged in strictly ascending order from left to right.</li>
</ul>
<p>Your task is to complete the function <code>IsBpT</code> as follows so that the teacher can determine whether a tree submitted by a student meets the other properties required by the definition of the B+ tree of a given order. Return true if the tree is a B+ tree, or false if not.</p>
<div class="highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">C</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-1-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-1-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-1-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-1-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-1-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-1-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-1-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-1-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-1-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-1-10">10</a></span>
<span class="normal"><a href="#__codelineno-1-11">11</a></span>
<span class="normal"><a href="#__codelineno-1-12">12</a></span>
<span class="normal"><a href="#__codelineno-1-13">13</a></span>
<span class="normal"><a href="#__codelineno-1-14">14</a></span>
<span class="normal"><a href="#__codelineno-1-15">15</a></span>
<span class="normal"><a href="#__codelineno-1-16">16</a></span>
<span class="normal"><a href="#__codelineno-1-17">17</a></span>
<span class="normal"><a href="#__codelineno-1-18">18</a></span>
<span class="normal"><a href="#__codelineno-1-19">19</a></span>
<span class="normal"><a href="#__codelineno-1-20">20</a></span>
<span class="normal"><a href="#__codelineno-1-21">21</a></span>
<span class="normal"><a href="#__codelineno-1-22">22</a></span>
<span class="normal"><a href="#__codelineno-1-23">23</a></span>
<span class="normal"><a href="#__codelineno-1-24">24</a></span>
<span class="normal"><a href="#__codelineno-1-25">25</a></span>
<span class="normal"><a href="#__codelineno-1-26">26</a></span>
<span class="normal"><a href="#__codelineno-1-27">27</a></span>
<span class="normal"><a href="#__codelineno-1-28">28</a></span>
<span class="normal"><a href="#__codelineno-1-29">29</a></span>
<span class="normal"><a href="#__codelineno-1-30">30</a></span>
<span class="normal"><a href="#__codelineno-1-31">31</a></span>
<span class="normal"><a href="#__codelineno-1-32">32</a></span>
<span class="normal"><a href="#__codelineno-1-33">33</a></span>
<span class="normal"><a href="#__codelineno-1-34">34</a></span>
<span class="normal"><a href="#__codelineno-1-35">35</a></span>
<span class="normal"><a href="#__codelineno-1-36">36</a></span>
<span class="normal"><a href="#__codelineno-1-37">37</a></span>
<span class="normal"><a href="#__codelineno-1-38">38</a></span>
<span class="normal"><a href="#__codelineno-1-39">39</a></span>
<span class="normal"><a href="#__codelineno-1-40">40</a></span>
<span class="normal"><a href="#__codelineno-1-41">41</a></span>
<span class="normal"><a href="#__codelineno-1-42">42</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-1-1" name="__codelineno-1-1"></a><span class="kt">bool</span><span class="w"> </span><span class="nf">IsBpT</span><span class="p">(</span><span class="n">BpTNode</span><span class="o">*</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-1-2" name="__codelineno-1-2"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">isLeaf</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">     </span><span class="cm">/* this is a leaf node */</span>
<a id="__codelineno-1-3" name="__codelineno-1-3"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">isRoot</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* this tree has only one node */</span>
<a id="__codelineno-1-4" name="__codelineno-1-4"></a><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_keys</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_keys</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">order</span><span class="p">)</span>
<a id="__codelineno-1-5" name="__codelineno-1-5"></a><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<a id="__codelineno-1-6" name="__codelineno-1-6"></a><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-1-7" name="__codelineno-1-7"></a><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_keys</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">order</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_keys</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">order</span><span class="p">)</span>
<a id="__codelineno-1-8" name="__codelineno-1-8"></a><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<a id="__codelineno-1-9" name="__codelineno-1-9"></a><span class="w">        </span><span class="p">}</span>
<a id="__codelineno-1-10" name="__codelineno-1-10"></a><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-1-11" name="__codelineno-1-11"></a><span class="w">        </span><span class="cm">/* check the property of the tree structure */</span>
<a id="__codelineno-1-12" name="__codelineno-1-12"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_keys</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_children</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<a id="__codelineno-1-13" name="__codelineno-1-13"></a><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<a id="__codelineno-1-14" name="__codelineno-1-14"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">isRoot</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* this is the root node */</span>
<a id="__codelineno-1-15" name="__codelineno-1-15"></a><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_keys</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_keys</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<a id="__codelineno-1-16" name="__codelineno-1-16"></a><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<a id="__codelineno-1-17" name="__codelineno-1-17"></a><span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_children</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_children</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">order</span><span class="p">)</span>
<a id="__codelineno-1-18" name="__codelineno-1-18"></a><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<a id="__codelineno-1-19" name="__codelineno-1-19"></a><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-1-20" name="__codelineno-1-20"></a><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">__________________</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_keys</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<a id="__codelineno-1-21" name="__codelineno-1-21"></a><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<a id="__codelineno-1-22" name="__codelineno-1-22"></a><span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_children</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">order</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">||</span>
<a id="__codelineno-1-23" name="__codelineno-1-23"></a><span class="w">                    </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_children</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">order</span><span class="p">)</span>
<a id="__codelineno-1-24" name="__codelineno-1-24"></a><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<a id="__codelineno-1-25" name="__codelineno-1-25"></a><span class="w">        </span><span class="p">}</span>
<a id="__codelineno-1-26" name="__codelineno-1-26"></a>
<a id="__codelineno-1-27" name="__codelineno-1-27"></a><span class="w">        </span><span class="cm">/* check the property of the value of key */</span>
<a id="__codelineno-1-28" name="__codelineno-1-28"></a><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_keys</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-1-29" name="__codelineno-1-29"></a><span class="w">            </span><span class="n">BpTNode</span><span class="o">*</span><span class="w"> </span><span class="n">key_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__________________</span><span class="w"> </span><span class="p">;</span>
<a id="__codelineno-1-30" name="__codelineno-1-30"></a><span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">key_node</span><span class="o">-&gt;</span><span class="n">isLeaf</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-1-31" name="__codelineno-1-31"></a><span class="w">                </span><span class="n">key_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key_node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<a id="__codelineno-1-32" name="__codelineno-1-32"></a><span class="w">            </span><span class="p">}</span>
<a id="__codelineno-1-33" name="__codelineno-1-33"></a><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">key_node</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<a id="__codelineno-1-34" name="__codelineno-1-34"></a><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<a id="__codelineno-1-35" name="__codelineno-1-35"></a><span class="w">        </span><span class="p">}</span>
<a id="__codelineno-1-36" name="__codelineno-1-36"></a><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_children</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-1-37" name="__codelineno-1-37"></a><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IsBpT</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">order</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span>
<a id="__codelineno-1-38" name="__codelineno-1-38"></a><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<a id="__codelineno-1-39" name="__codelineno-1-39"></a><span class="w">        </span><span class="p">}</span>
<a id="__codelineno-1-40" name="__codelineno-1-40"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-1-41" name="__codelineno-1-41"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<a id="__codelineno-1-42" name="__codelineno-1-42"></a><span class="p">}</span>
</code></pre></div></td></tr></table></div>
<hr />
<p>第一空：<code>node-&gt;num_children &lt; (order + 1) / 2 - 1</code>，因为中间节点的元素数</p>
<p>第二空：<code>node-&gt;children[i + 1]</code>，因为中间节点的第 i 个元素为第 i+1 个子树中的最小值。</p>
</div>
<hr />
<h2 id="_2">倒排索引</h2>
<p>倒排索引的结构：对每个关键词，包含一系列指向它出现在文档中位置的指针，表示为 &lt;次数; (文档 1, 位置 1); (文档 2, 位置 2); …&gt;，成为 posting list。</p>
<p>“倒排”的含义为是针对每个 term，而不是针对 document。</p>
<p><strong>倒排索引之前的想法？</strong></p>
<p>Term-Document Incidence Matrix：每个单词分配二进制序列，1 表示在文档中。多关键词搜索时，对二进制序列做与运算。</p>
<p>缺点：矩阵太稀疏，浪费空间。</p>
<p><strong>为什么需要记录出现的总次数？</strong></p>
<p>多关键词搜索时，优先用出现次数少的。</p>
<p><strong>添加索引的流程？</strong></p>
<p>Token Analyzer, Stop Filter &rarr; Vocabulary Scanner -&gt; Vocabulary Inserter &rarr; Memory Management.</p>
<p>读到一个词后：Word Stemming &rarr; Stop Words</p>
<p><strong>在索引中搜索一个词？</strong></p>
<ol>
<li>Search trees：B 树、B+ 树、Tries</li>
<li>hashing：优点为查询、插入、删除速度快，缺点为不支持范围查询、最坏情况退化为 O(n)、动态扩容代价大，随机访问不适合磁盘。</li>
</ol>
<p><strong>内存满了怎么办？</strong></p>
<p>文档分批处理，内存分块。内存满时将这块内存写到磁盘，清空并处理下一个块。最后将所有块外部合并（归并），得到最终的倒排索引。</p>
<p>内存块指当内存中的倒排索引达到预设容量时，这一批处理过的倒排列表就成为一个块，写到磁盘去。</p>
<p><strong>索引的分配？</strong></p>
<p>每个 node（计算机）存储整个倒排索引的一部分。</p>
<ol>
<li>Term-partitioned index：按词汇的编号划分</li>
<li>Document-partitioned index：按文档的编号划分</li>
</ol>
<p><strong>动态索引？</strong></p>
<p>主索引极大，通常已经写死在磁盘上，顺序存储、压缩优化、不可修改。</p>
<p>在 main index 之外新增 auxiliary index，搜索时同时在两边搜。</p>
<p>什么时候合并主索引和辅助索引？辅助索引达到一定大小，或定时合并，或 LSM Tree 原理分层合并（略）。</p>
<p>怎么删除文档？使用 delete-bit（删除标记），将删除的文档也写入辅助索引。合并时在磁盘中删除。</p>
<p><strong>压缩存储空间？</strong></p>
<p>先去除停用词，将所有的词汇放在同一个存储块内，词汇之间没有任何间隔（类似字符串）。为了从字符串中分离出词汇，需要另一张小的表记录每个词汇开头的位置。每个词汇的索引记录相邻词汇开头的差分。</p>
<p><strong>设置阈值？</strong></p>
<p>文档截断阈值、查询词阈值</p>
<p><strong>评价检测性能？</strong></p>
<ol>
<li>精确度（precision）：检索到的有意义的文档占所有检索到文档的比例。</li>
<li>召回率（recall）：检索到的有意义的文档占所有有意义的文档的比例。</li>
</ol>
<hr />
<h2 id="_3">左偏堆</h2>
<p>定义零路径长（Npl）：节点到一个没有两个儿子的节点的最短路径的长。具有 0 个或 1 个儿子的节点的 Npl 为 0，null 的 Npl 为-1。每个节点的 Npl 等于它的两个孩子的 Npl 的最小值 +1。</p>
<p>左偏堆的要求：每个节点的左孩子的 Npl 都要大于等于其右孩子的 Npl</p>
<p><strong>最右路径节点数和总节点数的关系？</strong></p>
<p>最右路径上 <span class="arithmatex">\(r\)</span> 个节点，则总节点数至少为 <span class="arithmatex">\(2^r-1\)</span>。</p>
<p>反过来，总节点数为 <span class="arithmatex">\(N\)</span>，最右路径最多有 <span class="arithmatex">\(\lfloor \log(N+1)\rfloor\)</span> 个节点。</p>
<p><strong>普通堆合并的时间复杂度？</strong></p>
<p><span class="arithmatex">\(O(n)\)</span>（先合并两数组，再从后往前调整）。</p>
<p>和搜索树不同，堆不需要查询操作。左偏堆中最右路径尽可能短，所有合并只要在右路径上进行，左边的节点不会被访问到。</p>
<p><strong>左偏堆的合并？</strong></p>
<p>（详见“左偏堆，斜堆”部分。）</p>
<ol>
<li>递归合并：从根较小的堆（o）开始，每次有两个待合并的堆，分别为 o 的右儿子和另一个左偏堆。将这两者中根较小的作为 o 的右儿子。从下往上（递归顺序）检查是否违反左偏性质，调整并更新 Npl。</li>
<li>迭代合并：用栈存储合并的父节点，合并完后弹栈调整。</li>
</ol>
<p>递归深度为两个堆最右路径长度之和，而每一层操作为常数。总 TC 为 <span class="arithmatex">\(O(\log N_1+\log N_2)=O(\log\sqrt{N_1N_2})=O(\log(N_1+N_2))\)</span>。</p>
<h2 id="_4">斜堆</h2>
<p>斜堆的要求：每次合并后交换左右孩子。不考虑 Npl。</p>
<p><strong>斜堆的合并？</strong></p>
<p>从根较小的堆（o）开始，每次有两个待合并的堆，分别为 o 的右儿子和另一个左偏堆。将这两者中根较小的作为 o 的右儿子。从下往上交换左右孩子。也可理解为先左右交换，再在左边合并。</p>
<p>注意！Always swap the left and right children except that the largest of all the nodes on the right paths does not have its children swapped. 除了最右路径上最后一个节点，所有最右路径上节点都要交换左右孩子！即使是空节点和某个节点 x 合并，只要 x 有右孩子，则 x 的左右孩子仍要交换。</p>
<p><strong>斜堆的摊还分析？</strong></p>
<p>定义重节点（heavy node）：该节点右子树的节点个数大于等于所有后代（包括自身）的一半。否则为轻节点（light node）。</p>
<p>可证明，若最右路径上有 l 个轻节点，则整个斜堆至少有 <span class="arithmatex">\(2^l-1\)</span> 个节点。即最右路径上轻节点的个数为 <span class="arithmatex">\(O(\log N)\)</span>。（归纳法证明）</p>
<p>定义势能函数：<span class="arithmatex">\(\Phi(T)\)</span> 为 T 中重节点的个数。</p>
<p>合并后只有最右路径上轻重会变，且重节点一定变化轻节点、轻节点不一定变为重节点。故一侧操作的均摊成本至多为原先两个堆的最右路径上轻节点的个数，即 <span class="arithmatex">\(O(\log N)\)</span>。</p>
<p>最坏情况下两个堆都退化为链状，合并时间为 <span class="arithmatex">\(O(N)\)</span>。插入、删除的本质都是合并，也都是最坏 <span class="arithmatex">\(O(N)\)</span>、摊还 <span class="arithmatex">\(O(\log N)\)</span>。</p>
<div class="admonition examples">
<p class="admonition-title">斜堆最右路径长度</p>
<p>The right path of a skew heap can be arbitrarily long.（T/F）</p>
<hr />
<p>T。斜堆中，最右路径上轻节点的数量有限制，但最右路径总长任意。</p>
</div>
<h2 id="_5">二项队列</h2>
<p>二项树：首先需要满足堆序性（这里默认最小堆）。定义单个节点的高度为 0，k 阶二项树由一个 k-1 阶二项树连接到另一 k-1 阶二项树的根节点构成。（二项树的阶数与二进制对应。）</p>
<p>二项队列：一系列阶数不同的二项树构成的森林。</p>
<p><strong>查询最小值的时间复杂度？</strong></p>
<p>最小值一定是某个二项树的根，一共 <span class="arithmatex">\(O(\log N)\)</span> 个二项树，故 TC 为 <span class="arithmatex">\(O(\log N)\)</span>。</p>
<p>如果额外记录全局最小值，则查询的 TC 为 <span class="arithmatex">\(O(1)\)</span>，但需要另外维护这个值。</p>
<p><strong>插入的时间复杂度？</strong></p>
<p>插入相当于二进制下加一。将插入的节点视为 0 阶二项树，和原有的二项队列合并。同阶二叉树合并时，用较小的根作为新的根，从而保证二项树的堆序性。</p>
<p>设最小的不存在该阶数的二项树的数值为 i，则这次插入的时间为 <span class="arithmatex">\(const.\times (i+1)\)</span>，最坏时间为 <span class="arithmatex">\(O(\log N)\)</span>。<br />
但对于 k 阶二项树，只可能被创建 <span class="arithmatex">\(\frac{N}{K}\)</span> 次，总代价为 <span class="arithmatex">\(O(N)\)</span>，故摊还代价为 <span class="arithmatex">\(O(1)\)</span>。</p>
<p>或势能分析：定义势能函数 <span class="arithmatex">\(\Phi\)</span> 为合并后二项树的数量。</p>
<p><strong>二项队列的删除？</strong></p>
<p>遍历根节点，找到最小值 &rarr; 删除这个根节点，将剩余二项树和删除后子树合并。</p>
<p><strong>二项树怎么合并？</strong></p>
<p>第 i 个二项树是 i-1 叉树，用 LeftChild-NextSibling 方式表示。</p>
<p>T2 连接到 T1 上（相当于从左边连接）：</p>
<div class="highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">C</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-2-1">1</a></span>
<span class="normal"><a href="#__codelineno-2-2">2</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-2-1" name="__codelineno-2-1"></a><span class="n">T2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">NextSibling</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">LeftChild</span><span class="p">;</span>
<a id="__codelineno-2-2" name="__codelineno-2-2"></a><span class="n">T1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">LeftChild</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T2</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>
<p><strong>根据节点数判断二项树个数？</strong></p>
<p>将节点数转化为二进制，其中 1 的个数即二项树的个数。</p>
<div class="admonition examples">
<p class="admonition-title">二项树连接</p>
<p>To implement a binomial queue, the subtrees of a binomial tree are linked in increasing sizes.（T/F）</p>
<hr />
<p>F。由上面连接的代码可知，同阶二项树连接时作为 LeftChild，即子树按大小（节点数）递减的方式串成链。题目描述中“linked in increasing sizes”错误。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">二项队列判断</p>
<p>Making N insertions into an initally empty binomial queue takes <span class="arithmatex">\(O(N)\)</span> time in the worst case.</p>
<p>T。单次插入的最坏时间为 <span class="arithmatex">\(O(\log N)\)</span>，但考虑二项树的创建为 <span class="arithmatex">\(O(N)\)</span>。</p>
<hr />
<p>To implement a binomial queue, left-child-next-sibling structure is used to represent each binomial tree.</p>
<p>T。</p>
<hr />
<p>For a binomial queue, delete-min takes a constant time on average.</p>
<p>F。要查找所有二项树，时间为 <span class="arithmatex">\(O(\log N)\)</span>。</p>
<hr />
<p>For a binomial queue, merging takes a constant time on average.</p>
<p>F。可能产生 <span class="arithmatex">\(O(\log N)\)</span> 次进位，时间为 <span class="arithmatex">\(O(\log N)\)</span>。</p>
<hr />
<p>Inserting a number into a binomial heap with 15 nodes costs less time than inserting a number into a binomial heap with 19 nodes.</p>
<p>F。插入第 16 个节点后进位多。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">二项队列操作时间</p>
<p>For a binomial queue, __ takes a constant time on average.</p>
<p>A. merging
B. find-max
C. delete-min
D. insertion</p>
<hr />
<p>D。其他三项均为 <span class="arithmatex">\(O(\log N)\)</span>。</p>
</div>
<h2 id="_6">回溯法</h2>
<p><strong>回溯法过程的表示？</strong></p>
<p>令 <span class="arithmatex">\(S_k\)</span> 表示第 <span class="arithmatex">\(k\)</span> 步下所有可能的选择，用 <span class="arithmatex">\((x_1, x_2,\cdots,x_i)\)</span> 表示当前的部分解，其中 <span class="arithmatex">\(x_k\in S_k\)</span>。选择 <span class="arithmatex">\(x_{i+1}\in S_{i+1}\)</span> 加入部分解，检查是否符合条件。符合则继续，不符合则回到 <span class="arithmatex">\((x_1, x_2,\cdots,x_i)\)</span>，选择新的 <span class="arithmatex">\(x_{i+1}'\)</span>。</p>
<details class="normal-comment">
<summary>回溯法 template</summary>
<div class="highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">C</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-3-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-3-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-3-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-3-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-3-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-3-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-3-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-3-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-3-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-3-10">10</a></span>
<span class="normal"><a href="#__codelineno-3-11">11</a></span>
<span class="normal"><a href="#__codelineno-3-12">12</a></span>
<span class="normal"><a href="#__codelineno-3-13">13</a></span>
<span class="normal"><a href="#__codelineno-3-14">14</a></span>
<span class="normal"><a href="#__codelineno-3-15">15</a></span>
<span class="normal"><a href="#__codelineno-3-16">16</a></span>
<span class="normal"><a href="#__codelineno-3-17">17</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-3-1" name="__codelineno-3-1"></a><span class="kt">bool</span><span class="w"> </span><span class="nf">Backtracking</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-3-2" name="__codelineno-3-2"></a><span class="w">    </span><span class="n">Found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<a id="__codelineno-3-3" name="__codelineno-3-3"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">N</span><span class="p">)</span>
<a id="__codelineno-3-4" name="__codelineno-3-4"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// (x1, …, xN) 为成功解</span>
<a id="__codelineno-3-5" name="__codelineno-3-5"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">each</span><span class="w"> </span><span class="n">xi</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">Si</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-3-6" name="__codelineno-3-6"></a><span class="w">        </span><span class="n">OK</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Check</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="err">…</span><span class="p">,</span><span class="w"> </span><span class="n">xi</span><span class="p">),</span><span class="w"> </span><span class="n">R</span><span class="p">);</span><span class="w">  </span><span class="c1">// 检查条件，不满足则剪枝</span>
<a id="__codelineno-3-7" name="__codelineno-3-7"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">OK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 满足则继续构造</span>
<a id="__codelineno-3-8" name="__codelineno-3-8"></a><span class="w">            </span><span class="n">Count</span><span class="w"> </span><span class="n">xi</span><span class="w"> </span><span class="n">in</span><span class="p">;</span>
<a id="__codelineno-3-9" name="__codelineno-3-9"></a><span class="w">            </span><span class="n">Found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Backtracking</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<a id="__codelineno-3-10" name="__codelineno-3-10"></a><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Found</span><span class="p">)</span>
<a id="__codelineno-3-11" name="__codelineno-3-11"></a><span class="w">                </span><span class="n">Undo</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="c1">// 下一步不满足则回到 (x1, …, xi-1)</span>
<a id="__codelineno-3-12" name="__codelineno-3-12"></a><span class="w">        </span><span class="p">}</span>
<a id="__codelineno-3-13" name="__codelineno-3-13"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Found</span><span class="p">)</span>
<a id="__codelineno-3-14" name="__codelineno-3-14"></a><span class="w">            </span><span class="k">break</span><span class="p">;</span>
<a id="__codelineno-3-15" name="__codelineno-3-15"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-3-16" name="__codelineno-3-16"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Found</span><span class="p">;</span>
<a id="__codelineno-3-17" name="__codelineno-3-17"></a><span class="p">}</span>
</code></pre></div></td></tr></table></div>
</details>
<div class="admonition examples">
<p class="admonition-title">暴力搜索</p>
<p>It is guaranteed that an exhaustive search can always find the solution in finite time.（T/F）</p>
<hr />
<p>F。解空间可能是无限的。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">回溯顺序</p>
<p>In backtracking, if different solution spaces have different sizes, start testing from the partial solution with the largest space size would have a better chance to reduce the time cost. （T/F）</p>
<hr />
<p>F。这里的 size of solution spaces 指的是在某种情况下可能的选择的个数，可选择数少，剪枝剪掉的多。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">回溯的时间复杂度</p>
<p>What makes the time complexity analysis of a backtracking algorithm very difficult is that the time taken to backtrack -- that is, to recover the previous state of a solution -- is hard to estimate.（T/F）</p>
<hr />
<p>F。不是因为“回溯”这个过程的时间难以分析，而是不同分支的搜索空间大小差别大、不确定什么时候回溯。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">回溯的时间和解空间</p>
<p>The time complexity of a backtracking algorithm is <span class="arithmatex">\(\Omega(S)\)</span> where <span class="arithmatex">\(S\)</span> is the total size of the solution space.（T/F）</p>
<hr />
<p>F。Solution space 指所有可能的解，但回溯中通过剪枝，不用访问所有的解空间。</p>
</div>
<h2 id="_7">八皇后问题</h2>
<p><strong>解的表示？</strong></p>
<p><span class="arithmatex">\(Q_i\)</span> 表示第 i 行的皇后，<span class="arithmatex">\(x_i\)</span> 表示 <span class="arithmatex">\(Q_i\)</span> 所在的列。Solution 表示为 <span class="arithmatex">\((x_1, x_2,\cdots,x_8)\)</span>。</p>
<p>Solution space 指 solution 的所有可能情况的数量（不一定满足所有条件）。</p>
<p>课件中画出博弈树便于理解。实际不用构造树。</p>
<p><strong>解的个数？</strong></p>
<p>N 皇后问题解的个数是指数级，但找到一个解只需多项式时间。</p>
<div class="admonition examples">
<p class="admonition-title">回溯边数</p>
<p>The problem of “N queens” is to place N queens on an N*N chessboard such that no two queens attack. If the problem is to be solved by backtracking method, we need to check __ edges of the game tree with N=3 to see that there is no solution.</p>
<hr />
<p>11。边指放棋子的操作，同一列上放棋子直接跳过、不需要尝试。</p>
</div>
<h2 id="_8">博弈树</h2>
<p><strong>树、剪枝的表示？</strong></p>
<p>边表示操作，节点表示状态。所有从根到叶节点的路径即 solution space。</p>
<p>黑色节点表示剪枝。如果一个节点标黑，则它所有的孩子都不用遍历，直接跳到同一层的下一个节点。如果一个节点的所有孩子都被标黑，则这个节点也标黑。</p>
<p>博弈树中深度优先搜索等价于后序遍历。</p>
<p><strong>遍历的顺序？</strong></p>
<p>如果不同步骤 ​<span class="arithmatex">\(S_i\)</span> 的可选项数量不同，应优先处理可选项数量较少的步骤，因为这样能更快发现冲突并进行剪枝、减少搜索空间。</p>
<h2 id="_9">收费公路问题</h2>
<p>已知 <span class="arithmatex">\(N\)</span> 个收费站排列在 x 轴，且第一个位于 x=0，给出两两间距离（共 <span class="arithmatex">\(N(N-1)/2\)</span> 个），求各个收费站的位置。</p>
<p>每次取剩余的最大距离，对应的收费站到第一个或最后一个的距离为这个最大值。假设一种情况，计算和已知所有收费站的距离，当距离超出时回溯。</p>
<details class="normal-comment">
<summary>示例代码</summary>
<div class="highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">C</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-4-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-4-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-4-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-4-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-4-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-4-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-4-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-4-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-4-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-4-10">10</a></span>
<span class="normal"><a href="#__codelineno-4-11">11</a></span>
<span class="normal"><a href="#__codelineno-4-12">12</a></span>
<span class="normal"><a href="#__codelineno-4-13">13</a></span>
<span class="normal"><a href="#__codelineno-4-14">14</a></span>
<span class="normal"><a href="#__codelineno-4-15">15</a></span>
<span class="normal"><a href="#__codelineno-4-16">16</a></span>
<span class="normal"><a href="#__codelineno-4-17">17</a></span>
<span class="normal"><a href="#__codelineno-4-18">18</a></span>
<span class="normal"><a href="#__codelineno-4-19">19</a></span>
<span class="normal"><a href="#__codelineno-4-20">20</a></span>
<span class="normal"><a href="#__codelineno-4-21">21</a></span>
<span class="normal"><a href="#__codelineno-4-22">22</a></span>
<span class="normal"><a href="#__codelineno-4-23">23</a></span>
<span class="normal"><a href="#__codelineno-4-24">24</a></span>
<span class="normal"><a href="#__codelineno-4-25">25</a></span>
<span class="normal"><a href="#__codelineno-4-26">26</a></span>
<span class="normal"><a href="#__codelineno-4-27">27</a></span>
<span class="normal"><a href="#__codelineno-4-28">28</a></span>
<span class="normal"><a href="#__codelineno-4-29">29</a></span>
<span class="normal"><a href="#__codelineno-4-30">30</a></span>
<span class="normal"><a href="#__codelineno-4-31">31</a></span>
<span class="normal"><a href="#__codelineno-4-32">32</a></span>
<span class="normal"><a href="#__codelineno-4-33">33</a></span>
<span class="normal"><a href="#__codelineno-4-34">34</a></span>
<span class="normal"><a href="#__codelineno-4-35">35</a></span>
<span class="normal"><a href="#__codelineno-4-36">36</a></span>
<span class="normal"><a href="#__codelineno-4-37">37</a></span>
<span class="normal"><a href="#__codelineno-4-38">38</a></span>
<span class="normal"><a href="#__codelineno-4-39">39</a></span>
<span class="normal"><a href="#__codelineno-4-40">40</a></span>
<span class="normal"><a href="#__codelineno-4-41">41</a></span>
<span class="normal"><a href="#__codelineno-4-42">42</a></span>
<span class="normal"><a href="#__codelineno-4-43">43</a></span>
<span class="normal"><a href="#__codelineno-4-44">44</a></span>
<span class="normal"><a href="#__codelineno-4-45">45</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-4-1" name="__codelineno-4-1"></a><span class="kt">bool</span><span class="w"> </span><span class="nf">Reconstruct</span><span class="p">(</span><span class="n">DistType</span><span class="w"> </span><span class="n">X</span><span class="p">[],</span><span class="w"> </span><span class="n">DistSet</span><span class="w"> </span><span class="n">D</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-4-2" name="__codelineno-4-2"></a><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">Found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<a id="__codelineno-4-3" name="__codelineno-4-3"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Is_Empty</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>
<a id="__codelineno-4-4" name="__codelineno-4-4"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<a id="__codelineno-4-5" name="__codelineno-4-5"></a><span class="w">    </span><span class="n">D_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Find_Max</span><span class="p">(</span><span class="n">D</span><span class="p">);</span><span class="w">                </span><span class="c1">// 假设到第一个点的距离为剩余最大值</span>
<a id="__codelineno-4-6" name="__codelineno-4-6"></a><span class="w">    </span><span class="n">OK</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Check</span><span class="p">(</span><span class="n">D_max</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">);</span><span class="w">  </span><span class="c1">// 检查这个点是否符合</span>
<a id="__codelineno-4-7" name="__codelineno-4-7"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">OK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-4-8" name="__codelineno-4-8"></a><span class="w">        </span><span class="n">X</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">D_max</span><span class="p">;</span>
<a id="__codelineno-4-9" name="__codelineno-4-9"></a><span class="w">        </span><span class="c1">// 删除用到的距离</span>
<a id="__codelineno-4-10" name="__codelineno-4-10"></a><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">left</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a id="__codelineno-4-11" name="__codelineno-4-11"></a><span class="w">            </span><span class="n">Delete</span><span class="p">(</span><span class="o">|</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">);</span>
<a id="__codelineno-4-12" name="__codelineno-4-12"></a><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a id="__codelineno-4-13" name="__codelineno-4-13"></a><span class="w">            </span><span class="n">Delete</span><span class="p">(</span><span class="o">|</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">);</span>
<a id="__codelineno-4-14" name="__codelineno-4-14"></a><span class="w">        </span><span class="c1">// 继续构建</span>
<a id="__codelineno-4-15" name="__codelineno-4-15"></a><span class="w">        </span><span class="n">Found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Reconstruct</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<a id="__codelineno-4-16" name="__codelineno-4-16"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Found</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 情况不满足，回溯</span>
<a id="__codelineno-4-17" name="__codelineno-4-17"></a><span class="w">            </span><span class="c1">// 重新插入用到的距离</span>
<a id="__codelineno-4-18" name="__codelineno-4-18"></a><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">left</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a id="__codelineno-4-19" name="__codelineno-4-19"></a><span class="w">                </span><span class="n">Insert</span><span class="p">(</span><span class="o">|</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">);</span>
<a id="__codelineno-4-20" name="__codelineno-4-20"></a><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a id="__codelineno-4-21" name="__codelineno-4-21"></a><span class="w">                </span><span class="n">Insert</span><span class="p">(</span><span class="o">|</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">);</span>
<a id="__codelineno-4-22" name="__codelineno-4-22"></a><span class="w">        </span><span class="p">}</span>
<a id="__codelineno-4-23" name="__codelineno-4-23"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-4-24" name="__codelineno-4-24"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Found</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 假设不成立，换成到最后一个点的距离为剩余最大值</span>
<a id="__codelineno-4-25" name="__codelineno-4-25"></a><span class="w">        </span><span class="n">OK</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Check</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">D_max</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<a id="__codelineno-4-26" name="__codelineno-4-26"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">OK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-4-27" name="__codelineno-4-27"></a><span class="w">            </span><span class="n">X</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="err">–</span><span class="w"> </span><span class="n">D_max</span><span class="p">;</span>
<a id="__codelineno-4-28" name="__codelineno-4-28"></a><span class="w">            </span><span class="c1">// 删除用到的距离</span>
<a id="__codelineno-4-29" name="__codelineno-4-29"></a><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">left</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a id="__codelineno-4-30" name="__codelineno-4-30"></a><span class="w">                </span><span class="n">Delete</span><span class="p">(</span><span class="o">|</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">);</span>
<a id="__codelineno-4-31" name="__codelineno-4-31"></a><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a id="__codelineno-4-32" name="__codelineno-4-32"></a><span class="w">                </span><span class="n">Delete</span><span class="p">(</span><span class="o">|</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">);</span>
<a id="__codelineno-4-33" name="__codelineno-4-33"></a><span class="w">            </span><span class="c1">// 继续构建</span>
<a id="__codelineno-4-34" name="__codelineno-4-34"></a><span class="w">            </span><span class="n">Found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Reconstruct</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<a id="__codelineno-4-35" name="__codelineno-4-35"></a><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Found</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 回溯</span>
<a id="__codelineno-4-36" name="__codelineno-4-36"></a><span class="w">                </span><span class="c1">// 重新插入用到的距离</span>
<a id="__codelineno-4-37" name="__codelineno-4-37"></a><span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">left</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a id="__codelineno-4-38" name="__codelineno-4-38"></a><span class="w">                    </span><span class="n">Insert</span><span class="p">(</span><span class="o">|</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">);</span>
<a id="__codelineno-4-39" name="__codelineno-4-39"></a><span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a id="__codelineno-4-40" name="__codelineno-4-40"></a><span class="w">                    </span><span class="n">Insert</span><span class="p">(</span><span class="o">|</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">);</span>
<a id="__codelineno-4-41" name="__codelineno-4-41"></a><span class="w">            </span><span class="p">}</span>
<a id="__codelineno-4-42" name="__codelineno-4-42"></a><span class="w">        </span><span class="p">}</span>
<a id="__codelineno-4-43" name="__codelineno-4-43"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-4-44" name="__codelineno-4-44"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Found</span><span class="p">;</span>
<a id="__codelineno-4-45" name="__codelineno-4-45"></a><span class="p">}</span>
</code></pre></div></td></tr></table></div>
</details>
<h2 id="_10">井字棋</h2>
<p><strong>策略的表示？</strong></p>
<p>课件中叉表示电脑，圆表示人，从电脑角度考虑。</p>
<p><span class="arithmatex">\(P\)</span> 表示下棋位置，<span class="arithmatex">\(W\)</span> 表示当前位置下可能赢的种类数，“可能赢”指路径上没有对方的棋。<span class="arithmatex">\(f(P)\)</span> 表示这个位置对电脑而言的 goodness，<span class="arithmatex">\(f(P)=W_{computer}-W_{human}\)</span>。</p>
<p>电脑下棋，选择 <span class="arithmatex">\(f(P)\)</span> 最大的位置；人下棋，选择 <span class="arithmatex">\(f(P)\)</span> 最小的位置。</p>
<p><strong>alpha-beta 剪枝？</strong></p>
<p>选择 max 时的剪枝称为 <span class="arithmatex">\(\alpha\)</span> 剪枝，选择 min 时的剪枝称为 <span class="arithmatex">\(\beta\)</span> 剪枝。</p>
<p><span style="color:red">（为什么？）<span class="arithmatex">\(\alpha-\beta\)</span> 剪枝能将搜索节点的数量从 <span class="arithmatex">\(O(N)\)</span> 降低到 <span class="arithmatex">\(O(\sqrt{N})\)</span>。</span></p>
<h2 id="_11">分治法</h2>
<div class="admonition examples">
<p class="admonition-title">排序与分治</p>
<p>How many of the following sorting methods use(s) Divide and Conquer algorithm?</p>
<ul>
<li>Heap Sort</li>
<li>Insertion Sort</li>
<li>Merge Sort</li>
<li>Quick Sort</li>
<li>Selection Sort</li>
<li>Shell Sort</li>
</ul>
<hr />
<p>2 个。Merge sort 是经典分治算法。Quick sort 用 pivot 将数组分成两部分，再分别处理两边，也是分治。</p>
<p>堆排序、插入排序、选择排序、希尔排序不是分治。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">时间分析</p>
<p>Recall that in the merge sort, we divide the input list into two groups of equal size, sort them recursively, and merge them into one sorted list. Now consider a variant of the merge sort. In this variant, we divide the input list into <span class="arithmatex">\(\sqrt{n}\)</span> groups of equal size, where n is the input size. What is the worst case running time of this variant? (You may use the fact that merging k sorted lists takes <span class="arithmatex">\(O(m\log k)\)</span> where m is the total number of elements in these lists.)</p>
<hr />
<p><span class="arithmatex">\(O(N\log N)\)</span>。递推式为 <span class="arithmatex">\(T(N)=\sqrt{N}T(\sqrt{N})+O(N\log N)\)</span>，猜想时间复杂度为 <span class="arithmatex">\(O(N\log N)\)</span>（根据选项猜测），代入发现符合。</p>
</div>
<h2 id="_12">主定理</h2>
<p>公式：<span class="arithmatex">\(T(n)=aT(n/b)+f(n)\)</span></p>
<p><strong>怎么求 T(n)？</strong></p>
<ol>
<li>Substitude method（代入法）：猜想 <span class="arithmatex">\(T(n)=g(n)\)</span>，即要证 <span class="arithmatex">\(T(n)&lt;c\cdot g(n)\)</span>。假设 <span class="arithmatex">\(n/b\)</span> 满足，由递推式退出 <span class="arithmatex">\(n\)</span> 满足。</li>
</ol>
<p>如果递推式不满足上述公式，可通过换元转化。先将 <span class="arithmatex">\(f(n)\)</span> 换为幂次，再换成 <span class="arithmatex">\(n/b\)</span> 的形式。如果含 n 的表达式中同时含有常数项，可直接将常数忽略。</p>
<p>esp. 当证明 <span class="arithmatex">\(T(n)\)</span> 时发现结果多了低阶项，可尝试在假设中减去这个低阶项（加强假设）来证明。</p>
<ol>
<li>Recursion-tree method（递归树法）：对于上面公式的类型，每个节点变成 <span class="arithmatex">\(f(n)\)</span>，递归树共 <span class="arithmatex">\(\log_b(N)\)</span> 层。非叶节点总和为等比数列，叶节点总和为 <span class="arithmatex">\(a^{\log_b(N)}\)</span>。</li>
</ol>
<p><strong>主定理结论？</strong></p>
<p>令 <span class="arithmatex">\(\frac{af(N/b)}{f(N)}\to c\)</span>，则</p>
<div class="arithmatex">\[
T(n) =
\begin{cases}
\Theta(f(N)), &amp;\quad c&lt;1 \\
\Theta(f(N)\log N), &amp;\quad c=1 \\
\Theta(N^{\log_b a}), &amp;\quad c&gt;1
\end{cases}
\]</div>
<p>上述只对 <span class="arithmatex">\(f(N)\)</span> 为多项式或多项式乘对数时适用。</p>
<p>进一步可加上对数项 <span class="arithmatex">\(T(n)=aT(\frac{n}{b})+\Theta\big(n^{c}(\log n)^{k}\big)\)</span>，有：</p>
<div class="arithmatex">\[
T(n) =
\begin{cases}
\displaystyle \Theta\big(n^{c}(\log n)^{k}\big), &amp;\quad a &lt; b^c \\
\displaystyle \Theta\big(n^{c}(\log n)^{k+1}\big), &amp;\quad a = b^c \\
\displaystyle \Theta\big(n^{\log_b a}\big), &amp;\quad a &gt; b^c
\end{cases}
\]</div>
<div class="admonition examples">
<p class="admonition-title">f(N)的表示</p>
<p><span class="arithmatex">\(f(N)\)</span> 由以下构成：</p>
<div class="highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">C</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-5-1">1</a></span>
<span class="normal"><a href="#__codelineno-5-2">2</a></span>
<span class="normal"><a href="#__codelineno-5-3">3</a></span>
<span class="normal"><a href="#__codelineno-5-4">4</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-5-1" name="__codelineno-5-1"></a><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
<a id="__codelineno-5-2" name="__codelineno-5-2"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a id="__codelineno-5-3" name="__codelineno-5-3"></a><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">l</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">;</span><span class="n">j</span><span class="o">+=</span><span class="n">i</span><span class="p">)</span>
<a id="__codelineno-5-4" name="__codelineno-5-4"></a><span class="w">            </span><span class="n">calc</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
</code></pre></div></td></tr></table></div>
<hr />
<p><span class="arithmatex">\(\sum_{i=1}^N\frac{N}{i}=N\log N\)</span>，故 <span class="arithmatex">\(f(N)=O(N^2\log N)\)</span>。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">分治时间的计算</p>
<div class="arithmatex">\[T(n)=2T(n/2)+n/\log n\]</div>
<p>不能使用主定理，因此用递归树，递归树我们有 <span class="arithmatex">\(\log_2 n\)</span> 层，第 <span class="arithmatex">\(i\)</span> 层时间复杂度 <span class="arithmatex">\(n / \log(n/2^i)\)</span>，叶子有 <span class="arithmatex">\(n\)</span> 个，故整体复杂度为</p>
<div class="arithmatex">\[
\sum_{i=0}^{\log_2 n - 1} \frac{n}{\log(n/2^i)} + \Theta(n) = \sum_{i=0}^{\log n - 1} \frac{n}{\log_2 n - i} + \Theta(n) = \sum_{j=1}^{\log_2 n} \frac{n}{j} + \Theta(n) = O(n \log \log n)
\]</div>
</div>
<div class="admonition examples">
<p class="admonition-title">主定理计算</p>
<p>For the recurrence equation <span class="arithmatex">\(T(N)=8T(N/2)+N^3\log N\)</span>, we obtain <span class="arithmatex">\(T(N)=O(N^3\log N)\)</span> according to the Master Theorem.</p>
<p>F。<span class="arithmatex">\(T(N)=O(N^3\log^2 N)\)</span>。</p>
<hr />
<p>For the recurrence equation <span class="arithmatex">\(T(N)=aT(N/b)+f(N)\)</span>, if <span class="arithmatex">\(af(N/b)=f(N)\)</span>, then <span class="arithmatex">\(T(N)=\Theta(N\log_b N)\)</span>.</p>
<p>F。<span class="arithmatex">\(T(N)=\Theta(f(N)\log_b N)\)</span>。</p>
<hr />
<p>For the recurrence equation <span class="arithmatex">\(T(N)=aT(N/b)+f(N)\)</span>, if <span class="arithmatex">\(af(N/b)=Kf(N)\)</span> for some constant <span class="arithmatex">\(K&gt;1\)</span>, then <span class="arithmatex">\(T(N)=\Theta(f(N))\)</span>.</p>
<p>F。<span class="arithmatex">\(\Theta(N^{\log_b a})\)</span>。</p>
<hr />
<p>For the recurrence equation <span class="arithmatex">\(T(N)=aT(N/b)+f(N)\)</span>, if <span class="arithmatex">\(af(N/b)=f(N)\)</span>, then <span class="arithmatex">\(T(N)=\Theta(f(N)\log_b N)\)</span>.</p>
<p>T。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">时间计算</p>
<p>3-way-mergesort : Suppose instead of dividing in two halves at each step of the mergesort, we divide into three one thirds, sort each part, and finally combine all of them using a three-way-merge. What is the overall time complexity of this algorithm ?</p>
<hr />
<p><span class="arithmatex">\(O(N\log N)\)</span>。combine all of them using a three-way-merge 指每次取三组中最小值、合并成一组的方法。<span class="arithmatex">\(T(N)=3T(N/3)+O(N)\)</span>，故 <span class="arithmatex">\(T(N)=O(N\log N)\)</span>。</p>
</div>
<hr />
<h2 id="_13">最近点对问题</h2>
<p><strong>怎么找跨越中间的点对？</strong></p>
<p>令 <span class="arithmatex">\(\overline{x}\)</span> 为所有 x 的中值，<span class="arithmatex">\(\delta\)</span> 为左右的最近点距离，只需考虑 <span class="arithmatex">\([\overline{x}-\delta, \overline{x}+\delta]\)</span> 的 strip。将 strip 中点按 y 排序，对于 strip 中点 <span class="arithmatex">\(q_i\)</span>，进一步只需考虑 <span class="arithmatex">\([y_i, y_i+\delta]\)</span> 区域中的点。划分成 4x2 的方格，每格中只可能有一个点，因此最多检查 7 个点。</p>
<div class="admonition examples">
<p class="admonition-title">最近点对时间</p>
<p>If devide-and-conquer strategy is used to find the closest pair of points in a plane, unless the points are sorted not only by their x coordinates but also by their y coordinates, it would be impossible to solve it in a time of <span class="arithmatex">\(O(N\log N)\)</span>, where <span class="arithmatex">\(N\)</span> is the number of points.（T/F）</p>
<hr />
<p>T。如果没有对 Y 排序，strip 内部的排序需要时间 <span class="arithmatex">\(O(N\log N)\)</span>，总时间复杂度大于 <span class="arithmatex">\(O(N\log N)\)</span>。</p>
</div>
<h2 id="_14">背包问题</h2>
<p><strong>0-1 背包？</strong></p>
<p><span class="arithmatex">\(v_i\)</span> 表示物品体积，<span class="arithmatex">\(w_i\)</span> 表示物品价值。<span class="arithmatex">\(dp_{i,j}\)</span> 表示前 i 个物品、占用 j 体积时的最大价值。</p>
<div class="arithmatex">\[dp_{i,j}=\max(dp_{i-1,j},\,dp_{i-1,j-v_i}+w_i)\]</div>
<p>滚动数组中<code>y=i&amp;1</code>，用<code>y^1</code>切换。<br />
也可用一维数组表示，略。</p>
<p><strong>完全背包？</strong></p>
<p><span class="arithmatex">\(dp_{i,j}\)</span> 表示前 i 个物品、占用 j 体积时的最大价值。</p>
<p>完全背包中同一物品可选择无穷多次，考虑选择第 i 件物品时不用由 i-1 转移。</p>
<div class="arithmatex">\[dp_{i,j}=\max(dp_{i-1,j},\,dp_{i,j-v_i}+w_i)\]</div>
<p><strong>多重背包？</strong></p>
<p>可展开（或用二进制展开）为 0-1 背包。</p>
<h2 id="_15">矩阵乘法的顺序</h2>
<p>矩阵 <span class="arithmatex">\(M_{m\times n}\)</span>、<span class="arithmatex">\(M_{n\times k}\)</span> 相乘的时间为 <span class="arithmatex">\(mnk\)</span>。</p>
<p><strong>不同乘法顺序的种数？</strong></p>
<p>令 <span class="arithmatex">\(b_n\)</span> 表示 n 个矩阵相乘的不同顺序的数量，则 <span class="arithmatex">\(b_n=\sum_{i=1}^{n-1}b_ib_{n-i}\)</span>。</p>
<p><span class="arithmatex">\(b_n\)</span> 为卡特兰数，表达式为 <span class="arithmatex">\(b_n= \frac{1}{n}\binom{2(n-1)}{n-1}\)</span>。</p>
<p><strong>线性规划求解？</strong></p>
<p>令第 i 个矩阵的大小为 <span class="arithmatex">\(r_{i-1}\times r_i\)</span>。<span class="arithmatex">\(t_{i,j}\)</span> 表示第 i 个到第 j 个矩阵相乘的最小时间。</p>
<div class="arithmatex">\[t_{i,j}=\min\limits_{i\le m\le j}\{t_{i,m}+t_{m+1,j}+r_{i-1}r_mr_j\}\]</div>
<p>时间复杂度为 <span class="arithmatex">\(O(n^3)\)</span>。</p>
<h2 id="_16">最优二叉搜索树</h2>
<p>给定一列单词 <span class="arithmatex">\(w_1, w_2,\cdots,w_n\)</span> 和对应的访问频率 <span class="arithmatex">\(p_1,p_2,\cdots,p_n\)</span>。如果单词深度为 <span class="arithmatex">\(d\)</span>，则访问的比较次数为 <span class="arithmatex">\(d+1\)</span>，需要在一棵二叉查找树中放置这些单词，使得总访问次数的期望时间最小，即 <span class="arithmatex">\(\sum p_i(d_i+1)\)</span> 最小。</p>
<p>符号表示：<span class="arithmatex">\(T_{ij}\)</span> 表示 <span class="arithmatex">\(w_i,\cdots,w_j\)</span> 的最优二叉搜索树，<span class="arithmatex">\(c_{ij}\)</span> 表示 <span class="arithmatex">\(T_{ij}\)</span> 的搜索次数期望，<span class="arithmatex">\(r_{ij}\)</span> 表示 <span class="arithmatex">\(T_{ij}\)</span> 的根，<span class="arithmatex">\(w_{ij}\)</span> 表示 <span class="arithmatex">\(T_{ij}\)</span> 中所有节点频率求和。</p>
<p>不考虑和自己的比较，访问次数为左子树的次数加右子树的次数；在考虑和自身的一次比较，需要再加上区间内所有单词的频率。</p>
<div class="arithmatex">\[c_{i,j}=\sum_{k=i}^jp_{k}+\max_{i\le k\le j}(c_{i,k-1}+c_{k+1,j})\]</div>
<h2 id="_17">全源最短路径</h2>
<p><strong>Bellman-Ford 算法？</strong></p>
<p>Bellman–Ford 是一种单源最短路径算法，边权可以为负。</p>
<p>对每个点定义 <span class="arithmatex">\(dist\)</span> 为到源点的最小距离，初始化为正无穷。对每条边松弛 <span class="arithmatex">\(dist[v]=\min(dist[v], dist[u]+l_{uv})\)</span>，最多松弛 <span class="arithmatex">\(N-1\)</span> 次。再检查所有边，如果仍存在 <span class="arithmatex">\(dist[v] &gt; dist[u] + l_{uv}\)</span>，说明存在负环。</p>
<p>令 <span class="arithmatex">\(D^k[v]\)</span> 表示从源点 s 到当前点 v，最多使用 k 条边的最短路径长度，则 <span class="arithmatex">\(D^{n-1}[v]\)</span> 表示所求的最短路。如果仍只使用 k-1 条边，则 <span class="arithmatex">\(D^k[v]=D^{k-1}[v]\)</span>；如果使用 k 条边，且令 <span class="arithmatex">\((w,v)\)</span> 是最后的边，则 <span class="arithmatex">\(D^k[v]=\min_{(w,v)\in E}(D^{k-1}[w]+l_{wv})\)</span>。</p>
<p>不包含负环等价于对任意顶点 <span class="arithmatex">\(v\)</span>，有 <span class="arithmatex">\(D^n[v]=D^{n+1}[v]\)</span>。</p>
<p><strong>Floyd-Warshall 算法？</strong></p>
<p>令 <span class="arithmatex">\(D^k[i][j]\)</span> 表示从 i 到 j、中间点只允许 <span class="arithmatex">\(\{0, 1,\cdots,k\}\)</span> 的路径的最短长度。<span class="arithmatex">\(D^{-1}[i][j]\)</span> 表示不允许任何中间点，即原有的边；<span class="arithmatex">\(D^0[i][j]\)</span> 表示允许点 0 作为中间点……<span class="arithmatex">\(D^{N-1}[i][j]\)</span> 表示允许所有点作为中间点。</p>
<p>如果路径不经过 k-1，则 <span class="arithmatex">\(D^k[i][j]=D^{k-1}[i][j]\)</span>；如果经过点 k-1，则 <span class="arithmatex">\(D^{k-1}[i][k]=D^{k-1}[k][j]\)</span>。</p>
<div class="arithmatex">\[D^k[i][j]=\min(D^{k-1}[i][j],D^{k-1}[i][k] + D^{k-1}[k][j])\]</div>
<p>因为需要逐步加入中间点，循环最外层应为遍历中转点。</p>
<p>包含负环等价于存在一个顶点 <span class="arithmatex">\(v\)</span>，使得 <span class="arithmatex">\(D^n[v][v]&lt;0\)</span>。Floyd-Warshall 算法允许负边，但不能出现负环。</p>
<h2 id="_18">产品装配问题</h2>
<p>汽车可以在两条装配线中组装，不同装配线在同一个工站的加工时间不同。在进入下一个工站时，可以留在当前线、也可以从另一条线切换过来。求最短时间。</p>
<p>共有 <span class="arithmatex">\(N\)</span> 个工站，0、1 两条装配线。令 <span class="arithmatex">\(t_{0,j}\)</span>、<span class="arithmatex">\(t_{1,j}\)</span> 分别表示 0、1 线从工站 <span class="arithmatex">\(j-1\)</span> 到 <span class="arithmatex">\(j\)</span> 的时间，<span class="arithmatex">\(t_{0\to 1,j}\)</span>、<span class="arithmatex">\(t_{1\to 0,j}\)</span> 分别表示切换所需的时间。</p>
<p>暴力搜索需要 <span class="arithmatex">\(O(2^N)\)</span> 的时间、<span class="arithmatex">\(O(N)\)</span> 的空间。</p>
<p>令 <span class="arithmatex">\(f[0][i]\)</span>、<span class="arithmatex">\(f[1][i]\)</span> 分别表示进行到 0、1 条线的第 i 个工站的最短时间。状态转移：<span class="arithmatex">\(f[0][i]=\min{f[0][i-1]+t_{0,i},f[1][i-1]+t_{1\to 0,j}}\)</span>（前者记为 <span class="arithmatex">\(f_{stay}\)</span>，后者记为 <span class="arithmatex">\(f_{move}\)</span>。）</p>
<h2 id="_19">动态规划</h2>
<p><strong>子序列和子数组？</strong></p>
<p>子序列（subsequence）可以有间隔，而子数组/子串/子区间（subarray/substring/interval）要求连续。</p>
<p><strong>什么时候不能用动态规划？</strong></p>
<ol>
<li>出现 history-dependency，当前决策不仅取决于当前状态，还取决于“过去发生过什么”，而过去的信息不能被压缩成有限维的状态。</li>
<li>子问题没有 overlapping</li>
<li>子问题数量太大，问题是在线的……</li>
</ol>
<div class="admonition examples">
<p class="admonition-title">完全平方数的和</p>
<p>给你一个整数 n，返回和为 n 的完全平方数的最少数量。例如 n = 13，则 n 至少需要写成两个完全平方数相加的形式，即 n = 4 + 9。</p>
<hr />
<p>令 <span class="arithmatex">\(dp[i]\)</span> 表示和为 i 时，所需完全平方数的最少个数。状态转移：<span class="arithmatex">\(dp[i]=\min_{1\le j^2\le i}(dp[i-j^2]+1)\)</span>。</p>
<div class="highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">C++</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-6-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-6-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-6-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-6-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-6-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-6-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-6-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-6-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-6-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-6-10">10</a></span>
<span class="normal"><a href="#__codelineno-6-11">11</a></span>
<span class="normal"><a href="#__codelineno-6-12">12</a></span>
<span class="normal"><a href="#__codelineno-6-13">13</a></span>
<span class="normal"><a href="#__codelineno-6-14">14</a></span>
<span class="normal"><a href="#__codelineno-6-15">15</a></span>
<span class="normal"><a href="#__codelineno-6-16">16</a></span>
<span class="normal"><a href="#__codelineno-6-17">17</a></span>
<span class="normal"><a href="#__codelineno-6-18">18</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-6-1" name="__codelineno-6-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">numSquares</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-6-2" name="__codelineno-6-2"></a><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">INF</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e9</span><span class="p">;</span>
<a id="__codelineno-6-3" name="__codelineno-6-3"></a><span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dp</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">INF</span><span class="p">);</span>
<a id="__codelineno-6-4" name="__codelineno-6-4"></a><span class="w">    </span><span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-6-5" name="__codelineno-6-5"></a>
<a id="__codelineno-6-6" name="__codelineno-6-6"></a><span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">squares</span><span class="p">;</span>
<a id="__codelineno-6-7" name="__codelineno-6-7"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-6-8" name="__codelineno-6-8"></a><span class="w">        </span><span class="n">squares</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<a id="__codelineno-6-9" name="__codelineno-6-9"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-6-10" name="__codelineno-6-10"></a>
<a id="__codelineno-6-11" name="__codelineno-6-11"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-6-12" name="__codelineno-6-12"></a><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">squares</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-6-13" name="__codelineno-6-13"></a><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sq</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<a id="__codelineno-6-14" name="__codelineno-6-14"></a><span class="w">            </span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sq</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<a id="__codelineno-6-15" name="__codelineno-6-15"></a><span class="w">        </span><span class="p">}</span>
<a id="__codelineno-6-16" name="__codelineno-6-16"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-6-17" name="__codelineno-6-17"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<a id="__codelineno-6-18" name="__codelineno-6-18"></a><span class="p">}</span>
</code></pre></div></td></tr></table></div>
</div>
<div class="admonition examples">
<p class="admonition-title">切割最大利益问题</p>
<p>Rod-cutting Problem: Given a rod of total length <span class="arithmatex">\(N\)</span> inches and a table of selling prices <span class="arithmatex">\(P_L\)</span> for lengths <span class="arithmatex">\(L = 1, 2, \cdots, M\)</span>. You are asked to find the maximum revenue <span class="arithmatex">\(R_N\)</span> obtainable by cutting up the rod and selling the pieces. For example, based on the following table of prices, if we are to sell an 8-inch rod, the opti   mal solution is to cut it into two pieces of lengths 2 and 6, which produces revenue <span class="arithmatex">\(R_8 = P_2 + P_6 = 5 + 17 = 22\)</span>. And if we are to sell a 3-inch rod, the best way is not to cut it at all.</p>
<table>
<thead>
<tr>
<th>Length <span class="arithmatex">\(L\)</span></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>Price <span class="arithmatex">\(P_L\)</span></td>
<td>1</td>
<td>5</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>17</td>
<td>17</td>
<td>20</td>
<td>23</td>
<td>28</td>
</tr>
</tbody>
</table>
<hr />
<p>先剪一段得到收益 <span class="arithmatex">\(P_i\)</span>，再将剩下的视为子问题。<span class="arithmatex">\(R_N=\max\limits_{1\le i\le N}(P_i+R_{N-i})\)</span>。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">字符串匹配</p>
<p>Given two words <code>word1</code> and <code>word2</code>, the minimum number of operations required to transform <code>word1</code> into <code>word2</code> is defined as the edit distance between the two words.
The operations include:</p>
<ul>
<li>Inserting a character</li>
<li>Deleting a character</li>
<li>Replacing a character</li>
</ul>
<p>Example:</p>
<p>Input: <code>word1 = "horse"</code>, <code>word2 = "ros"</code>
Edit Distance: 3</p>
<p>Explanation:</p>
<ol>
<li>horse → rorse (replace 'h' with 'r')</li>
<li>rorse → rose (remove 'r')</li>
<li>rose → ros (remove 'e')</li>
</ol>
<p>We can use dynamic programming to solve it.</p>
<p>Definition:</p>
<ul>
<li><code>dp[i][j]</code> represents the minimum edit distance between the substring of word1 ending at index i-1, and the substring of word2 ending at index j-1.</li>
<li><code>word[i]</code> represents the i-th character of the word</li>
</ul>
<hr />
<p>初始化：<span class="arithmatex">\(dp[0][i]=dp[i][0]=0\)</span></p>
<p>若最后一个字母相同，则 <span class="arithmatex">\(dp[i][j]=dp[i-1][j-1]\)</span>。
若最后一个字母不同，可以选择删除 word1 最后一个字符、在 word1 末尾插入字符、将 word1 最后的字符替换为 word2 最后的字符。删除的代价为 <span class="arithmatex">\(dp[i-1][j]+1\)</span>，插入的代价为 <span class="arithmatex">\(dp[i][j-1]+1\)</span>，替换的代价为 <span class="arithmatex">\(dp[i-1][j-1]+1\)</span>，最终代价为三者取 min。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">判断 时间复杂度</p>
<p>If a problem can be solved by dynamic programming, it must be solved in polynomial time. T/F.</p>
<hr />
<p>F. 因为 TSP 的时间复杂度为 <span class="arithmatex">\(O(n^2 2^n)\)</span>。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">动态规划的循环顺序</p>
<p>In dynamic programming, we derive a recurrence relation for the solution to one subproblem in terms of solutions to other subproblems. To turn this relation into a bottom up dynamic programming algorithm, we need an order to fill in the solution cells in a table, such that all needed subproblems are solved before solving a subproblem. Among the following relations, which one is impossible to be computed?</p>
<ul>
<li>A. <span class="arithmatex">\(A(i,j) = \min(A(i-1,j), A(i,j-1), A(i-1,j-1))\)</span></li>
<li>B. <span class="arithmatex">\(A(i,j) = F(A(\min\{i,j\}-1,\min\{i,j\}-1), A(\max\{i,j\}-1,\max\{i,j\}-1))\)</span></li>
<li>C. <span class="arithmatex">\(A(i,j) = F(A(i,j-1), A(i-1,j-1), A(i-1,j+1))\)</span></li>
<li>D. <span class="arithmatex">\(A(i,j) = F(A(i-2,j-2), A(i+2,j+2))\)</span></li>
</ul>
<hr />
<p>A 可以。</p>
<p>B 可以。<span class="arithmatex">\(A(i,j)\)</span> 的值都依赖于 <span class="arithmatex">\(A(i-1,i-1)\)</span> 和 <span class="arithmatex">\(A(j-1,j-1)\)</span>，而这两个值严格更小。可按照对角线顺序填表。</p>
<p>C 可以。<span class="arithmatex">\(A(i,j-1)\)</span> 为左、<span class="arithmatex">\(A(i-1,j-1)\)</span> 为左上、<span class="arithmatex">\(A(i-1,j+1)\)</span> 为右上，可以按行（i）逐个填表。</p>
<p>D 不可以。循环依赖。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">动态规划顺序 2</p>
<p>Given a recurrence equation <span class="arithmatex">\(f_{i,j,k} = f_{i,j+1,k} + \min\limits_{0 \le l \le k}\{f_{i-1,j,l} + w_{j,l}\}\)</span>. To solve this equation in an iterative way, we cannot fill up a table as follows:</p>
<ul>
<li>A. <code>for k in 0 to n: for i in 0 to n: for j in n to 0</code></li>
<li>B. <code>for i in 0 to n: for j in 0 to n: for k in 0 to n</code></li>
<li>C. <code>for i in 0 to n: for j in n to 0: for k in n to 0</code></li>
<li>D. <code>for i in 0 to n: for j in n to 0: for k in 0 to n</code></li>
</ul>
<hr />
<p>B。<span class="arithmatex">\(f_{i,j+1,k}\)</span> 需要同一层 i、同一 k、j+1 列的值，说明 j 从 n 到 0 遍历。<span class="arithmatex">\(f_{i-1,j,l}\)</span> 需要上一层 i、同一 j、所有 l 的值，说明 i 从 0 到 n 遍历，而 k 的遍历顺序无关，因为 i-1 层全部 k 都计算完。</p>
<p>循环的方向取决于其他量固定时，这个量依赖于更小的值还是更大的值。但如果状态转移的依赖的所有值都是某变量的上一个值，这个变量必须优先循环。</p>
<p>因此要求为：<code>i++</code>, <code>j--</code>。B 中 j 递增，不符。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">动态规划顺序 3</p>
<p>To solve the optimal binary search tree problem, we have the recursive equation <span class="arithmatex">\(c_{ij} = \min_{i \le l \le j}\{w_{ij} + c_{i,l-1} + c_{l+1,j}\}\)</span>. To solve this equation in an iterative way, we must fill up a table as follows:</p>
<p>A. <code>for i = 1 to n-1 do; for j = i to n do; for l = i to j do</code>
B. <code>for k = 1 to n-1 do; for i = 1 to n-k do; set j = i+k; for l = i to j do</code>
C. <code>for j = 1 to n-1 do; for i = 1 to j do; for l = i to j do</code>
D. <code>for k = 1 to n-1 do; for i = 1 to n do; set j = i+k; for l = i to j do</code></p>
<hr />
<p>B。状态转移依赖的 <span class="arithmatex">\(c_{i,l-1}\)</span> 和 <span class="arithmatex">\(c_{l+1,j}\)</span> 都长度小于 <span class="arithmatex">\(c_{i,j}\)</span>，因此最外层按区间长度遍历。</p>
<p>其他选项可通过列举前几项排除。</p>
</div>
<h2 id="_20">贪心算法</h2>
<p>只有当局部最优解（local optimum）和全局最优解（global optimum）相同时，贪心算法才有效。</p>
<p>贪心算法不能保证找到最优解，但通常会产生数值非常接近的解（启发式算法）。</p>
<h2 id="_21">活动选择问题</h2>
<p>给定一个活动集合 <span class="arithmatex">\(S = \{a_1, a_2, \ldots, a_n\}\)</span>，其中活动 <span class="arithmatex">\(a_i\)</span> 占用时间 <span class="arithmatex">\([s_i,f_i)\)</span> ，且 <span class="arithmatex">\(0 \leq s_i &lt; f_i &lt; \infty\)</span>。如果活动 <span class="arithmatex">\(a_i\)</span> 和 <span class="arithmatex">\(a_j\)</span> 满足 <span class="arithmatex">\(f_i \leq s_j\)</span> 或者 <span class="arithmatex">\(f_j \leq s_i\)</span>，则称活动 <span class="arithmatex">\(a_i\)</span> 和 <span class="arithmatex">\(a_j\)</span> 是兼容的（compatible）。要求找到一个最大的彼此兼容的子集。</p>
<p><strong>线性规划求解？</strong></p>
<p>方法一：</p>
<p>令 <span class="arithmatex">\(S_{ij}\)</span> 表示活动 <span class="arithmatex">\(a_i\)</span> 与 <span class="arithmatex">\(a_j\)</span> 之间（不包括 <span class="arithmatex">\(a_i\)</span>、<span class="arithmatex">\(a_j\)</span>）的最大彼此兼容的集合，记大小为 <span class="arithmatex">\(c_{ij}\)</span>。则 <span class="arithmatex">\(c_{ij}=\max(c_{ik}+c_{kj}+1\mid f_i\le s_k&lt;f_k\le s_j)\)</span>，即遍历所有 <span class="arithmatex">\(a_i\)</span>、<span class="arithmatex">\(a_j\)</span> 之间的活动 <span class="arithmatex">\(a_k\)</span>。</p>
<p>方法二：</p>
<p>令 <span class="arithmatex">\(S_{ij}\)</span> 表示第 i 到第 j 个活动的最大兼容活动集合，记大小为 <span class="arithmatex">\(c_{i,j}\)</span>。令 <span class="arithmatex">\(k(i)\)</span> 表示前 i 个活动中，结束时间在 <span class="arithmatex">\(s_i\)</span> 之前、且 <span class="arithmatex">\(c_k\)</span> 最大的 k 值，则 <span class="arithmatex">\(c_i=\max(c_{i-1},c_{k(i)}+1)\)</span>。如果活动有权值 <span class="arithmatex">\(w_i\)</span>，将这里的 1 替换为 <span class="arithmatex">\(w_j\)</span>。</p>
<p><strong>贪心算法求解？</strong></p>
<p>按各个活动的结束时间排序，每次取不冲突且结束时间最早的活动。（也可以从后往前选择最晚开始的活动。）</p>
<p>证明：交换参数法。假设不取结束时间最早的，证明替换后更优或等价。<br />
需要用到以下步骤：1. 考虑任意非空子问题 <span class="arithmatex">\(S_k\)</span>，令 <span class="arithmatex">\(a_m\)</span> 是 <span class="arithmatex">\(S_k\)</span> 中结束时间最早的活动，则 <span class="arithmatex">\(a_m\)</span> 在 <span class="arithmatex">\(S_k\)</span> 的某个最大兼容的活动子集中。2. 用贪心策略选择 <span class="arithmatex">\(a_1\)</span> 之后得到子问题 <span class="arithmatex">\(S_1\)</span>，那么 <span class="arithmatex">\(a_1\)</span> 和子问题 <span class="arithmatex">\(S_1\)</span> 的最优解合并，一定可以得到原问题的一个最优解。</p>
<p>动态规划求解的时间复杂度为 <span class="arithmatex">\(O(N\log N)\)</span>，而贪心算法的时间为 <span class="arithmatex">\(O(N)\)</span>。</p>
<div class="admonition examples">
<p class="admonition-title">活动选择判断</p>
<p>Let S be the set of activities in Activity Selection Problem. Then the earliest finish activity <span class="arithmatex">\(a_m\)</span> must be included in all the maximum-size subset of mutually compatible activities of S.</p>
<p>F。可能有多个子集大小都为 maximum-size，而 <span class="arithmatex">\(a_m\)</span> 不一定在每个这样的子集中都出现。</p>
<hr />
<p>Let S be the set of activities in Activity Selection Problem. Then there must be some maximum-size subset of mutually compatible activities of S that includes the earliest finish activity.</p>
<p>T。即贪心算法能找到最优解，但不一定是唯一的最优解。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">动态规划判断</p>
<p>Let <span class="arithmatex">\(c_{1,j}\)</span> be the optimal solution for <span class="arithmatex">\(a_1\)</span> to <span class="arithmatex">\(a_j\)</span>, and <span class="arithmatex">\(a_{k(j)}\)</span> is the nearest compatible activity to <span class="arithmatex">\(a_j\)</span> that is finished before <span class="arithmatex">\(a_j\)</span>. If each activity has a weight <span class="arithmatex">\(w\)</span>, then</p>
<div class="arithmatex">\[
c_{1,j} =
\begin{cases}
1 &amp; \text{if } j=1 \\
\max\{ c_{1,j-1}, c_{1,k(j)} + w_j \} &amp; \text{if } j&gt;1
\end{cases}
\]</div>
<p>（T/F）</p>
<hr />
<p>F。考虑第 j 个活动选或者不选，状态转移为 <span class="arithmatex">\(c_{i,j}=\max\{ c_{1,j-1}, c_{1,k(j)} + w_j \}\)</span>。但由于活动有权值，当 j=1 时应初始化为 <span class="arithmatex">\(w_1\)</span> 而不是 1。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">空间调度问题比较</p>
<p>Let us consider the following problem: given the set of activities <span class="arithmatex">\(S\)</span>, we must schedule them all using the minimum number of rooms.</p>
<p>Greedy1: Use the optimal algorithm for the Activity Selection Problem to find the max number of activities that can be scheduled in one room. Delete and repeat on the rest, until no activities left.</p>
<p>Greedy2:</p>
<ul>
<li>Sort activities by start time. Open room 1 for <span class="arithmatex">\(a_1\)</span>.</li>
<li>for i=2 to n if <span class="arithmatex">\(a_i\)</span> can fit in any open room, schedule it in that room; otherwise open a new room for <span class="arithmatex">\(a_i\)</span>.</li>
</ul>
<p>Which of the following statements is correct?</p>
<p>A. None of the above two greedy algorithms are optimal.
B. Greedy1 is an optimal algorithm and Greedy2 is not.
C. Greedy2 is an optimal algorithm and Greedy1 is not.
D. Both of the above two greedy algorithms are optimal.</p>
<hr />
<p>C。Greedy2 是正确的贪心做法，假设某个活动要新开房间，则前面所有房间在某个时间都重叠，不可能用更少的房间。而 Greedy1 可能选择结束时间早但重叠多的活动，导致房间数更多（可举反例）。</p>
</div>
<h2 id="_22">哈夫曼编码</h2>
<p>给定字母表 <span class="arithmatex">\(C\)</span>，<span class="arithmatex">\(C_i\)</span> 表示第 i 个字符，<span class="arithmatex">\(f_i\)</span> 表示 <span class="arithmatex">\(C_i\)</span> 的频率。为每个字符分配一个前缀码，用字典树表示每个字符的编码，令 <span class="arithmatex">\(d_i\)</span> 表示 <span class="arithmatex">\(C_i\)</span> 在字典树中的深度，即编码的长度。加权编码总长度 <span class="arithmatex">\(cost=\sum f_id_i\)</span>，要求这个值最小。</p>
<p><strong>无歧义解码的要求？</strong></p>
<p>前缀码的要求：不存在一个编码是另一个编码的前缀。</p>
<p>编码对应的哈夫曼树需要为前缀树，每个字符对应树中的一个叶节点。为了使总编码长度最小，每个内部节点必须有两个孩子（是满二叉树）。</p>
<p><strong>哈夫曼编码的方法？</strong></p>
<p>每次取频率最低的两个节点合成一个节点。重复 <span class="arithmatex">\(C-1\)</span> 次，构造哈夫曼树。</p>
<div class="highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">C</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-7-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-7-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-7-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-7-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-7-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-7-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-7-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-7-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-7-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-7-10">10</a></span>
<span class="normal"><a href="#__codelineno-7-11">11</a></span></pre></div></td><td class="code"><div><pre><span></span><code><a id="__codelineno-7-1" name="__codelineno-7-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">Huffman</span><span class="p">(</span><span class="n">PriorityQueue</span><span class="w"> </span><span class="n">heap</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-7-2" name="__codelineno-7-2"></a><span class="w">    </span><span class="n">Consider</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">characters</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">single</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">binary</span><span class="w"> </span><span class="n">trees</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">initialize</span><span class="w"> </span><span class="n">them</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="n">heap</span><span class="p">;</span>
<a id="__codelineno-7-3" name="__codelineno-7-3"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">C</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-7-4" name="__codelineno-7-4"></a><span class="w">        </span><span class="n">Create</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">node</span><span class="p">;</span>
<a id="__codelineno-7-5" name="__codelineno-7-5"></a><span class="w">        </span><span class="n">Delete</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="n">heap</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">attach</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">left_child</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">node</span><span class="p">;</span>
<a id="__codelineno-7-6" name="__codelineno-7-6"></a><span class="w">        </span><span class="n">Delete</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="n">heap</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">attach</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">right_child</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">node</span><span class="p">;</span>
<a id="__codelineno-7-7" name="__codelineno-7-7"></a><span class="w">        </span><span class="n">weight</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">weights</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">children</span><span class="p">;</span>
<a id="__codelineno-7-8" name="__codelineno-7-8"></a><span class="w">        </span><span class="c1">// 树的 cost 等于所有叶节点的代价之和</span>
<a id="__codelineno-7-9" name="__codelineno-7-9"></a><span class="w">        </span><span class="n">Insert</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="n">heap</span><span class="p">;</span>
<a id="__codelineno-7-10" name="__codelineno-7-10"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-7-11" name="__codelineno-7-11"></a><span class="p">}</span>
</code></pre></div></td></tr></table></div>
<p><strong>贪心策略的证明？</strong></p>
<p>引理 1：<span class="arithmatex">\(C\)</span> 为一个字母表，其中每个字符 <span class="arithmatex">\(c \in C\)</span> 频率为 <span class="arithmatex">\(c.freq\)</span>。令 <span class="arithmatex">\(x\)</span> 和 <span class="arithmatex">\(y\)</span> 是 <span class="arithmatex">\(C\)</span> 中频率最低的两个字符。那么存在 <span class="arithmatex">\(C\)</span> 的一个最优前缀码，<span class="arithmatex">\(x\)</span> 和 <span class="arithmatex">\(y\)</span> 的码字长度相同，且只有最后一个二进制位不同，即在哈夫曼树中为兄弟叶节点。</p>
<p>引理 1 证明：由于最优前缀码树是满二叉树，必然存在一对兄弟叶子，它们所在的深度是树中最大。分别将 <span class="arithmatex">\(x\)</span> 和 <span class="arithmatex">\(y\)</span> 换到这两个位置，交换之后总代价只会变小、不会变大。</p>
<p>引理 2：令 <span class="arithmatex">\(x\)</span> 和 <span class="arithmatex">\(y\)</span> 是 <span class="arithmatex">\(C\)</span> 中频率最低的两个字符。令 <span class="arithmatex">\(C'\)</span> 为 <span class="arithmatex">\(C\)</span> 去掉字符 <span class="arithmatex">\(x\)</span> 和 <span class="arithmatex">\(y\)</span>、加入新字符 <span class="arithmatex">\(z\)</span> 且 <span class="arithmatex">\(z.freq = x.freq + y.freq\)</span> 后的新字母表，令 <span class="arithmatex">\(T'\)</span> 为 <span class="arithmatex">\(C'\)</span> 的任意一个最优前缀码树。将 <span class="arithmatex">\(T'\)</span> 中的叶节点 <span class="arithmatex">\(z\)</span> 替换为一个以 <span class="arithmatex">\(x\)</span> 和 <span class="arithmatex">\(y\)</span> 为孩子的内部节点，则得到一个 <span class="arithmatex">\(C\)</span> 的一个最优前缀码树 <span class="arithmatex">\(T\)</span>。</p>
<div class="admonition examples">
<p class="admonition-title">前缀树判断</p>
<p>A binary tree that is not full cannot correspond to an optimal prefix code.（T/F）</p>
<hr />
<p>T。这里的 full binary tree（满二叉树）指所有非叶节点都有两个孩子。最优前缀树必须为满二叉树。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">哈夫曼编码长度分析</p>
<p>Given 4 cases of frequences of four characters. In which case(s) that the total bits taken by Huffman codes are the same as that of the ordinary equal length codes?</p>
<p>(1) 4 2 11 6
(2) 6 5 7 12
(3) 3 2 3 4
(4) 8 3 10 7</p>
<hr />
<p>（3）和（4）。哈夫曼编码长度为每个字符的编码长度乘出现次数求和，ordinary equal length codes 长度指编码长度乘所有字符的出现次数。</p>
</div>
<div class="admonition examples">
<p class="admonition-title">最优前缀码判断</p>
<p>Given four characters (a, b, c, d) with distinct frequencies in a text. Suppose that a and b are the two characters having the lowest frequencies. Which of the following sets of code is a possible Huffman code for this text?</p>
<p>A. a: 000, b: 001, c: 01, d: 1
B. a: 000, b: 001, c: 01, d: 11
C. a: 000, b: 001, c: 10, d: 1
D. a: 010, b: 001, c: 01, d: 1</p>
<hr />
<p>A。B 中前缀树不是满二叉树，d 可以上移一层。C 中 d 是 c 的前缀。D 中 a 和 b 不是兄弟节点。</p>
</div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date" title="2025年11月20日 11:43:09 UTC">2025-11-20</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date" title="2025年11月17日 00:31:05 UTC">2025-11-17</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var labels=set.querySelector(".tabbed-labels");for(var tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
</div>
      
        
<div class="md-social">
  
    
    
    
    
    <a href="https://github.com/Abiesjqq" target="_blank" rel="noopener" title="Abies on Github" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
    
    
    
    
    <a href="https://github.com/Noflowerzzk" target="_blank" rel="noopener" title="Noflower on Github" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
      <div class="md-progress" data-md-component="progress" role="progressbar"></div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["announce.dismiss", "navigation.instant", "header.autohide", "navigation.instant.progress", "navigation.prune", "navigation.tracking", "navigation.tabs", "navigation.tabs.sticky", "navigation.top", "navigation.footer", "search.suggest", "search.highlight", "search.share", "toc.follow", "navigation.indexes", "content.tabs.link", "content.tooltips", "content.code.copy", "content.code.select", "content.code.annotate", "git-revision-date", "git-revision-date-localized"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="https://cdn.jsdelivr.net/gh/Wcowin/Wcowin.github.io@main/docs/javascripts/extra.js"></script>
      
        <script src="../../../javascripts/animate-details.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="../../../javascripts/cursor.js"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="../../../javascripts/busuanzi.pure.mini.js"></script>
      
        <script src="https://cdn.jsdelivr.net/gh/Wcowin/Wcowin.github.io@main/docs/javascripts/view.js"></script>
      
    
  </body>
</html>