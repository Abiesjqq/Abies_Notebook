## :rocket:Class One

### 时间复杂度

$O(f(n))$:上界  
$\Omega(f(n))$:下界  
$\Theta(f(n))$:最好最坏情况的平均    
$o(f(n))$:真上界(最坏情况下上界)  

**nlogn 推导:**  
（这一段显示放弃修改了。。）  
$$\begin{aligned}
T(n) &= 2T\left(\frac{n}{2}\right) + Cn \\[1.5ex]
T(\frac{n}{2}) &= 2T(\frac{n}{4}) + Cn \\[1.5ex]
&\ \, \vdots \\
\end{aligned}$$

## :smiley:Class Two

### 最大和连续子数组

1. **暴力法:O(n^3)**
2. **暴力法优化:O(n^2)** 确定 i 后,遍历 j 时即完成求和

```c
int MaxSum(int a[],int len) {
    int nsum,maxsum;
    maxsum=0;
    for (int i=0;i<len;i++) {
        nsum=0;
        for (int j=1;j<len;j++) {
            nsum+=a[j]; //j右移时加
            if (nsum>maxsum) maxsum=nsum;
        }
    }
    return maxsum;
}
```

3. **搜索区间+前缀和:O(n^2)**
4. **分治法:O(nlogn)** 分成左半边,右半边,中间

```c
int MaxSum(int l,int r) {
    if (l==r) return a[l]; //返回条件

    int mid=(l+r)>>1;
    int max1=MaxSum(l,mid); //计算左半边
    int max2=MaxSUm(mid,r); //计算右半边

    int max3,lmax=0,rmax=0,sum=0;
    for (int i=mid;i>=l;i--) {
        sum+=a[i];
        lmax=max(lmax,sum);
    }
    sum=0;
    for (int i=mid+a;i<=r;i++) {
        sum+=a[i];
        ramx=max(ramx,sum);
    }
    max3=lmax+rmax;

    return max(max1,max2,max3);
}
```

5. **线性 dp:O(n)** 状态转移方程:`dp[i]=max(dp[i-1]+a[i],a[i])`
6. **扫描法:O(n)**

```c
int MaxSum() {
    int res=-INF,sum=0;
    for (int i=1;i<=len;i++) {
        if (sum<0) sum=a[i];
        else sum+=a[i];

        res=max(res,sum);
    }
    return res;
}
```

### 链表(略)

### HW2

> If the most commonly used operations are to visit a random position and to insert and delete the last element in a linear list, then which of the following data structures is the most efficient?
> A.doubly linked list
> B.singly linked circular list
> C.doubly linked circular list with a dummy head node
> D.sequential list
> 访问随机节点:相同
> 最后位置:循环链表可通过虚拟头结点后移一位直接找到最后一位

## :star2:Class Three

### 引言

- Taylor 展开本质是多项式逼近复杂函数,神经网络本质也是逼近,用数据训练求出权重,得到数据结构.
- 能量转化为结构(关系).通过不断改进数据结构,获得智能.
- 均摊代价分析:将代价与结构结合.

### 有序的序列是线性表

**多项式(The Polynomial ADT)**

- 用数组表示多项式.为了防止稀疏数组浪费空间,只表示非零项.使用结构数组或链表.

**多重线性表**

- e.g. 表示很多学生选几门课.列出学生为列,课程为行的稀疏矩阵.只表示选的节点并按纵向,横向连成链表.
- 每个节点都在纵向,横向两个链表中.

**内存管理**

- 怎么管空闲位置?操作系统管怎么分配,释放内存.用链表管理
- 编译器编译时分配相对位置(相对地址),等代码运行时操作系统分配存储空间(绝对地址)

### 内存管理过程

1. 理想情况下,申请释放的内存大小都相同,内存中利用一小块作为指针表示地址,将不同地址串成链表,每个指针指向下一个空闲空间.
2. malloc 申请空间时,分配头上的空闲空间的指针.修改链表,将头指针指向下一个空闲位置.
3. free 释放空间时,将释放的空间连到头指针.
4. 使用时间长后,内存的链表更无序,但头节点始终维持头.
5. 实际情况中,申请和释放的内存大小任意,每个节点大小不同.此时每个节点中包含这个节点大小,下一个空闲空间位置,标记该空间是否被占用的标记 flag 这三个信息.
6. 每次申请时,先看该节点大小是否满足.若节点小,看下一个节点;若节点满足,从该节点中切一块.
7. 防止多次使用后内存碎片化,释放内存时尽量使下一块或上一块连续.根据该节点大小找到下一节点,检查下一节点的 flag.
8. 为了能和前一节点,需要在节点末尾加 size,next,flag 信息.

### 堆栈(The Stack ADT)

**后缀表达式计算**

- 每次遇到运算符号,计算前两个数,并压入计算结果.
- 怎么把中缀表达式变为后缀表达式?
  - 遇到数,放入;遇到符号,记住.如果已有的符号优先级高,高的出去;如果已有的符号优先级低,记住新符号;如果已有的和新的优先级一样,先读到的出去.
  - 由括号怎么办?将括号视为运算.左括号优先级低.遇到右括号抛出之前的符号,直到左括号.

**堆栈与函数调用**

- 连续多次调用函数,函数执行后回答上一个调用它的函数.
- 利用堆栈:先放 main 函数,再每次调用一次压入函数名.每次返回时栈顶的函数为调用它的函数.
- 解决递归调用的问题.

### 队列(The Queue ADT)

- 用链表实现时,front 删除元素,rear 插入元素(front 指向 next,删除后可以直接找到下一个).
- 指针指向右,则从右插入,从左删除
- 队列空间用满后怎么办?循环队列.
- 循环队列空和满:front==rear+1(取余)
  - 为什么无法判断?队列中 n 个位置,共有 n+1 中情况,但 front 和 rear 的状态共有 n 种(信息量不够)
  - 怎么增加信息?加入 tag,插入时设置为 1,删除时设置为 0.无法判断时看 tag.
  - 或者使队列状态一共 n 种.空时 rear+1\==front,一个元素时 front\==rear,满时 front\==rear+2.
  - **一般使用** rear 不指实际的位置,而是指下一个要放的位置.空:`front\==rear`,满:`front\==rear+1`.
  - 或者 front 指向第一个元素的前一个位置(哑头),空:front\==rear,满:front\==rear+1.

## :fire:Class Four

### 博弈树

- 用树解决零和博弈的问题(e.g.棋类)
  - 每个节点的儿子表示下一步所有可能的走法,使用 minmax 算法和$\alpha\beta$剪枝
  - 核心 1:评估每个节点.AlphaGo:根据之前人类棋谱学习,计算各种棋局获胜概率(收益)
  - 核心 2:自己层取 max,对手层取 min
  - 对围棋而言 minmax 计算量太大,利用蒙特卡洛按概率选择方向

### 树的概念

- 树和图的区别:树一定连通,没有回路.
- 对于图而言,连通,没回路,n 个点 n-1 条边,这三个条件知二推一
- 森林:树的集合
- degree of tree:每个节点有几个儿子;degree of graph:每个节点有几条出边
- 树上任何两点之间的 path 一定唯一
- depth:该点到根的距离
- height:该点到最低点的距离

### 树的实现

- 用链表,怎么解决每个节点儿子数不确定的问题?每个节点都有且仅有 FirstChild,NextSibling 两个指针
- 这样的树即化为二叉树
- 利用中缀表达式构建树：
  - 读入数,存储指针
  - 读入符号,抛出两个数,将符号的指针压入,抛出的数作为该符号的儿子
  - 表达式前序遍历得到前序表达式，后序遍历得到后序表达式
- 遍历的本质:将二维结构变成一维的序列
- 线索树:根节点和叶节点浪费的指针指向遍历时的前一个点和后一个点.需要标记是指向的下一个节点还是根或叶的指针.每次判断是不是线索.
- 线索二叉树可增加哑头节点.

### HW4

#### 二叉树概念

- 树的度：一个节点有 m 个分叉，那么这个节点的度就为 m。叶子节点的度为 0，因为它没有分叉。二叉树节点的度只有 0，1，2 这三种，其中为 0 的肯定是叶子节点。
- 二叉树的深度：max(左子树深度，右子树深度)+1。
- 二叉树的分类
  - 满二叉树：一棵深度为 k 且有个$2^k-1$节点的二叉树称为满二叉树。
  - 完全二叉树：一棵深度为 k 的有 n 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为 i（1≤i≤n）的结点与满二叉树中编号为 i 的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。
  - 平衡二叉树(AVL 树)：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。
- 完全二叉树的性质
  - 在二叉树上的第 i 层上至多有$2^{i-1}$个节点(i>=1)
  - 深度为 k 的二叉树至多有$2^k-1$个节点(k >= 1)
  - 比较重要的一条性质：n0、n1、n2 分别代表度数为 0、1、2 的节点总数。n 为总结点数，则有：
    n=所有节点度之和+1 (所有树的性质)
    $n_0=n_2+1;$ (满二叉树$n_0=2^k,n_2=2^k-1$,非满二叉树$n_0,n_2$同时减小)
    $n=n_0+n_1+n_2;$
    $分支总线=n-1=n_1+2n_2;$ (连通无回路图的边为 n-1，将 n0 用 n2 代入)

#### 线索二叉树

1. 线索二叉树的基本概念：

- 对一棵二叉树中所有结点的空指针域按照某种遍历方式加线索的过程叫作线索化，被线索化了的二叉树称为线索二叉树(Threaded binary tree)。
- 引入线索二叉树的目的是：加快查找结点前驱和后继的速度。

2. 线索二叉树的构造

- 线索二叉树的存储结构：lchild ltag data rtag rchild
- ltag=0,表示指示节点的左儿子;ltag=1,表示指示节点的前驱.rtag=0,表示指示节点的右孩子;ltag=1,表示指示节点的后继.

## :sunglasses:Class Five

### 前序,中序,后序和栈

- 前序,中序推后序:前序确定根,中序确定左右子树的集合
- 中序,后序推前序:后序确定根,中序确定左右子树的集合
- 前序,后序推中序:不能实现,因为不能确定子树在左还是在右.
  - e.g. 前序 AB,后序 BA
- 树的堆栈操作:一直向左 push 到底,到叶节点时 pop 一个元素,再从 pop 出的元素开始向右走.
- 栈推前序:push 的顺序
- 栈推中序:pop 的顺序
- 栈推后序:
  - 第一个 push 的是根.
  - 后面 push 的元素,如果前一个是 push,则是左儿子;如果前一个是 pop,则是 pop 出元素的右儿子
- 树和栈
  - 每个合法的堆栈操作序列,都唯一确定一棵树.
  - m 个节点构成的树,共有 Catalan(n)种.$C_n=\sum\limits_{i=0}^{n-1}C_iC_{n-i-1}$
  - Catalan 数递推:m 个节点左右分配

### 几种特殊的树

#### Skewed Binary Trees 偏斜二叉树

#### Complete Binary Trees 完全二叉树

- 优点:能用数组存储
- 第 k 层,这一层最多节点数为$2^{k-1}$,所有层最多节点数$2_k-1$
- $n_0=n_2+1$
  Pf:从下往上,总边数为 n0+n1+n2;从下往上,总边数为 n1+2n2.联立两式得到.

#### Binary Search Trees 二叉搜索树

每个节点左子树均比其小,右子树都比其大.

- find:每次向左或向右查找
  使用尾递归实现.所有尾递归都能化成循环.
- insert:先向左或向右找到合适位置,走到 NULL 时 malloc 内存,将 NULL 变为节点.
- delete:
  1. 没有儿子或只有 1 个儿子:直接删除
  2. 有 2 个儿子:从左子树找最大值(或右子树找最小值),替换要删除的节点,再在左(或右)子树种删除相应值.
     PS:每次删除操作多,可使用懒标记(lazy tag).

#### 平衡树

几种决定是否平衡的指标:

1. AVL 树(平衡树)
   由左右子树的高度决定.任意节点,左右子树高度相差为 0 或 1,认为树平衡.
2. 红黑树
   将每个节点标记为红或黑.任意分支满足: 1. 第一个和最后一个节点为红 2. 红节点数相同 3. 黑节点不相邻
   则认为该树平衡.
   平衡的红黑树最长分支和最短分支最多相差 1 倍.
3. B+树
   满足所有分支节点数最多为 m,最少为 m/2,所有叶节点在同一层的树,认为平衡.
   B+树应用于数据库管理.

## 一些判断题

（粘贴自 csdn，不确保正确）

1-1
数据元素是数据的最小单位。F  
1-2
数据的逻辑结构是指数据的各数据项之间的逻辑关系。F  
1-3
数据结构概念包括数据之间的逻辑结构、数据在计算机中的存储方式和数据的运算三个方面。T  
1-4
数据元素可以由类型互不相同的数据项构成。T  
1-5
数据的逻辑结构说明数据元素之间的顺序关系，它依赖于计算机的存储结构。F  
1-6
2N 和 N 具有相同的增长速度。F  
1-7
算法分析的两个主要方面是时间复杂度和空间复杂度的分析。T  
1-8
n! is O(n^n).T  
1-9
O(N2) is the same as O(1+2+3+⋯+N).T  
1-10
对于顺序存储的长度为 N 的线性表，访问结点和增加结点的时间复杂度分别对应为 O(1)和 O(N)。T  
1-11
若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用顺序表存储最节省时间。T  
1-12
对于顺序存储的长度为 N 的线性表，删除第一个元素和插入最后一个元素的时间复杂度分别对应为 O(1)和 O(N)。F  
1-13
(neuDS)在顺序表中逻辑上相邻的元素，其对应的物理位置也是相邻的。T  
1-14
(neuDS)所谓随机存取，就是通过首地址和元素的位序号值可以在 O(1)的时间内找到指定的元素。T  
1-15
(neuDS)顺序存储的线性表不支持随机存取。F  
1-16
(neuDS)在顺序表上进行插入、删除操作时需要移动元素的个数与待插入或待删除元素的位置无关。F  
1-17
(neuDS)顺序存储方式只能用于存储线性结构。F  
1-18
在具有 N 个结点的单链表中，访问结点和增加结点的时间复杂度分别对应为 O(1)和 O(N)。F  
1-19
若用链表来表示一个线性表，则表中元素的地址一定是连续的。F  
1-20
将 N 个数据按照从小到大顺序组织存放在一个单向链表中。如果采用二分查找，那么查找的平均时间复杂度是 O(logN)。F  
1-21
通过对堆栈 S 操作：Push(S,1), Push(S,2), Pop(S), Push(S,3), Pop(S), Pop(S)。输出的序列为：123。F  
1-22
若一个栈的输入序列为 1，2，3，…，N，输出序列的第一个元素是 i，则第 j 个输出元素是 j−i−1。F  
1-23
若一个栈的输入序列为{1, 2, 3, 4, 5}，则不可能得到{3, 4, 1, 2, 5}这样的出栈序列。T  
1-24
栈和队列的存储方式，既可以是顺序方式，也可以是链式方式。T  
1-25
栈底元素是不能删除的元素。F  
1-26
顺序栈中元素值的大小是有序的。F  
1-27
在 n 个元素连续进栈以后，它们的出栈顺序和进栈顺序一定正好相反。T  
1-28
栈顶元素和栈底元素有可能是冋一个元素。T  
1-29
栈是一种特殊的线性表，它的插入和删除操作都是在表的同一端进行。 T  
1-30
链栈的插入在栈顶，删除在栈底。F  
1-31
所谓“循环队列”是指用单向循环链表或者循环数组表示的队列。F  
1-32
在用数组表示的循环队列中，front 值一定小于等于 rear 值。F  
1-33
循环队列执行出队操作时会引起大量元素的移动。F  
1-34
队列中允许插入的一端叫队头，允许删除的一端叫队尾。 F  
1-35
队列结构的顺序存储会产生假溢出现象。 T  
1-36
二叉树通常有顺序存储结构和链式存储结构。T  
1-37
在含有 n 个结点的树中，边数只能是 n-1 条。T  
1-38
完全二叉树中，若一个结点没有左孩子，则它必是树叶。T  
1-39
一棵有 n 个结点的二叉树，从上至下，从左到右用自然数依次编号，则编号为 i 的结点的左儿子的编号为 2i(2i< n),右儿子的编号是 2i+1(2i+1< n)。F  
1-40
用树的前序遍历和中序遍历可以导出树的后序遍历。F？  
1-41
二叉树只能用二叉链表表示。F  
1-42
树形结构中元素之间存在一个对多个的关系。T  
1-43
度为二的树就是二叉树。F 二叉树还要有区分左右儿子的顺序  
1-44
某二叉树的后序和中序遍历序列正好一样，则该二叉树中的任何结点一定都无右孩子。T  
1-45
某二叉树的前序和中序遍历序列正好一样，则该二叉树中的任何结点一定都无右孩子。F  
1-46
一棵有 124 个结点的完全二叉树，其叶结点个数是确定的。T  
1-47
任何二叉搜索树中同一层的结点从左到右是有序的（从小到大）。T  
1-48
二叉搜索树的查找和折半查找的时间复杂度相同。F  
1-49
二叉排序树的后序遍历序列必然是递增的。F  
1-50
若一搜索树（查找树）是一个有 n 个结点的完全二叉树，则该树的最大值一定在叶结点上 F  
1-51
N 个结点的二叉排序树有多种，其中树高最小的二叉排序树是最佳的。 T 根节点选取不同，BST 不同  
1-52
中根遍历二叉查找树所得序列一定是有序序列。T  
1-53
在二叉排序树中，每个结点的关键字都比左孩子关键字大，比右孩子关键字小。T  
1-54
二叉排序树的查找效率和二叉排序树的髙度有关。T  
1-55
任何最小堆的前序遍历结果是有序的（从小到大）。F  
1-56
任何最小堆中从根结点到任一叶结点路径上的所有结点是有序的（从小到大）。T  
1-57
对 N（≥2）个权值均不相同的字符构造哈夫曼树，则树中任一非叶结点的权值一定不小于下一层任一结点的权值。T  
1-58
哈夫曼编码是一种最优的前缀码。对一个给定的字符集及其字符频率，其哈夫曼编码不一定是唯一的，但是每个字符的哈夫曼码的长度一定是唯一的。F 多个字符频率相同时，在树中的位置可交换，可能导致哈夫曼码的长度不唯一  
1-59
哈夫曼树是带权路径长度最短的树，路径上权值较大的结点离根较近。F？  
1-60
无向连通图所有顶点的度之和为偶数。T  
1-61
无向连通图边数一定大于顶点个数减 1。F 可以等于  
1-62
用邻接表法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关。F  
1-63
用邻接矩阵法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关。T  
1-64
在一个有向图中，所有顶点的入度与出度之和等于所有边之和的 2 倍。T  
1-65
在任一有向图中，所有顶点的入度之和等于所有顶点的出度之和。T  
1-66
图的深度优先遍历非递归算法通常采用队列实现，广度优先遍历非递归算法通常采用堆栈实现。F  
1-67
如果无向图 G 必须进行两次广度优先搜索才能访问其所有顶点，则 G 中一定有回路。F  
1-68
采用邻接表存储的图，其广度优先遍历类似于二叉树的先序遍历。F  
1-69
若有向图不存在回路，即使不用访问标志位同一结点也不会被访问两次。F  
1-70
在一个有权无向图中，若 b 到 a 的最短路径距离是 12，且 c 到 b 之间存在一条权为 2 的边，则 c 到 a 的最短路径距离一定不小于 10。T  
1-71
P 是顶点 S 到 T 的最短路径，如果该图中的所有路径的权值都加 1，P 仍然是 S 到 T 的最短路径。F  
1-72
对于带权无向图 G = (V, E)，M 是 G 的最小生成树，则 M 中任意两点 V1 到 V2 的路径一定是它们之间的最短路径。F  
1-73
对 N 个记录进行归并排序，归并趟数的数量级是 O(NlogN)。F  
1-74
对 N 个记录进行堆排序，需要的额外空间为 O(N)。F  
1-75
对 N 个记录进行简单选择排序，比较次数和移动次数分别为 O(N2)和 O(N)。T  
1-76
对 N 个记录进行快速排序，在最坏的情况下，其时间复杂度是 O(NlogN)。F  
1-77
希尔排序是稳定的算法。F  
1-78
对 N 个不同的数据采用冒泡排序进行从大到小的排序，当元素基本有序时交换元素次数肯定最多。F  
1-79
要从 50 个键值中找出最大的 3 个值，选择排序比堆排序快。T  
1-80
基于比较的排序算法中，只要算法的最坏时间复杂度或者平均时间复杂度达到了次平方级 O(N \* logN)，则该排序算法一定是不稳定的。F  
1-81
在堆排序中，若要进行升序排序，则需要建立大根堆。T  
1-82
堆是完全二叉树，完全二叉树不一定是堆。T  
1-83
直接插入排序是不稳定的排序方法。F  
1-84
内排序要求数据一定要以顺序方式存储。F  
1-85
排序的稳定性是指排序算法中的比较次数保持不变，且算法能够终止。F  
1-86
当待排序记录已经从小到大排序或者已经从大到小排序时，快速排序的执行时间最省。F  
1-87
快速排序的速度在所有排序方法中为最快，而且所需附加空间也最少。F  
1-88
对 N 个不同的数据采用冒泡排序进行从大到小的排序，当元素基本有序时交换元素次数肯定最多。F  
1-89
快速排序是稳定的算法。F  
1-90
用希尔(shell)方法排序时，若关键字的初始排序杂乱无序，则排序效率就低。F  
1-91
直接选择排序的时间复杂度为 O(n2)，不受数据初始排列的影响。T  
1-92
冒泡排序算法的最坏时间复杂性是 O(n2)，而快速排序算法的最坏时间复杂性是 O(nlog2n)，所以快速排序比冒泡排序效率好。F  
1-93
（101,88,46,70,34,39,45,58,66,10）是堆。T  
1-94
有一大根堆，堆中任意结点的关键字均大于它的左右孩子关键字，则其具有最小值的结点一定是一个叶子结点并可能在堆的最后两层中。T  
1-95
在任何情况下，归并排序都比简单插入排序快。F  
1-96
在散列表中，所谓同义词就是被不同散列函数映射到同一地址的两个元素。F  
1-97
将 M 个元素存入用长度为 S 的数组表示的散列表，则该表的装填因子为 M/S。T  
1-98
在散列中，函数“插入”和“查找”具有同样的时间复杂度。T  
1-99
即使把 2 个元素散列到有 100 个单元的表中，仍然有可能发生冲突。T  
1-100
将 10 个元素散列到 100 000 个单元的哈希表中，一定不会产生冲突。F

## HW 总结

---

**The Fibonacci number sequence \(\{F*N\}\) is defined as: \(F_0 = 0\), \(F_1 = 1\), \(F_N = F*{N-1} + F\_{N-2}\), \(N=2, 3, ...\) The time complexity of the function which calculates \(F_N\) recursively is \(\Theta(N!)\).**

- [ ] T
- [x] F

\( T(N)=T(N-1)+T(N-2)+O(1)\),时间复杂度为\(\Theta(\phi^n)\).

---

**The Fibonacci number sequence \(\{F*N\}\) is defined as: \(F_0 = 0\), \(F_1 = 1\), \(F_N = F*{N-1} + F\_{N-2}\), \(N=2, 3, ...\) The space complexity of the function which calculates \(F_N\) recursively is:**

- [ ] A. \(O(\log N)\)
- [x] B. \(O(N)\)
- [ ] C. \(O(F_N)\)
- [ ] D. \(O(N!)\)

每个\(F(N)\)虽然在不同递归过程中产生,但是存储在统一空间,空间复杂度为\(O(N)\).

---

**For a sequentially stored linear list of length \(N\), the time complexities for deleting the first element and inserting the last element are \(O(1)\) and \(O(N)\), respectively.**

- [ ] T
- [x] F

顺序存储的线性表通常指的是数组（Array）或顺序表（Sequential List），其特点是元素在内存中连续存储，且必须从第一位开始。
删除第一个后，后面的所有元素都需要向前移动一位以填补空缺，时间为\(O(N)\).
如果数组空间足够（未满），直接在 A[N] 的位置写入新元素，无需移动其他元素,时间复杂度为\(O(1)\).

---

**If the most commonly used operations are to visit a random position and to insert and delete the last element in a linear list, then which of the following data structures is the most efficient?**

- [ ] A. doubly linked list
- [ ] B. singly linked circular list
- [ ] C. doubly linked circular list with a dummy head node
- [x] D. sequential list

链表不能快速随机访问
而插入删除只需要对末尾进行,线性表操作时不用移动其他位.

---

**It is always possible to represent a tree by a one-dimensional integer array.**

- [x] T
- [ ] F

树是一种非线性数据结构，但可以通过一定的方式用线性结构（如一维数组）表示。常见的用一维数组表示树的方法包括：

1. 父节点表示法：用一维数组存储每个节点的父节点索引。
2. 左孩子右兄弟表示法：用两个一维数组分别存储每个节点的左孩子和右兄弟。（这里要两个数组，不符合）
3. 完全二叉树的数组表示：补全成完全二叉树，直接用一维数组按层级顺序存储。

关键在于存储的不是节点的数值，而是节点的编号。

---

**There exists a binary tree with 2016 nodes in total, and with 16 nodes having only one child.**

- [ ] T
- [x] F

n=2016，n1=16
n=n0+n1+n2
总边数：
e=n-1 =n0+n1+n2 -1(树的性质：边数=点数-1)
e=n1+2\*n2
结论:
n2=n0 -1
n=n1+2\*n2 -1
2\*n2=1001,不存在

---

**Given a tree of degree 3. Suppose that there are 3 nodes of degree 2 and 2 nodes of degree 3. Then the number of leaf nodes must be \_\_\_\_.**

- [ ] A. 5
- [ ] B. 6
- [ ] C. 7
- [x] D. 8

树中节点的度是什么？树中节点的度是指该节点的子节点（直接后代）的数量。它的“度”就是它拥有的子树的个数（即直接连接的子节点数）。
Given a tree of degree 3 什么意思？树的 degree 通常指节点的最大度数（即某个节点的最大子节点数）。这里"degree 3 的树"可能指每个非叶节点最多有 3 个子节点（即 3 叉树，ternary tree）。
n2=3, n3=2
n0+n1+n2+n3-1=n1+2\*n2+3\*n3
n0+n1+5-1=n1+12
n0=8

---

**If a general tree \( T \) is converted into a binary tree \( BT \), then which of the following \( BT \) traversals gives the same sequence as that of the post-order traversal of \( T \)?**

- [ ] A. Pre-order traversal
- [x] B. In-order traversal
- [ ] C. Post-order traversal
- [ ] D. Level-order traversal

怎么把普通的树转化成二叉树？

1. 选择根节点：
   - 保持原树的根节点作为二叉树的根节点。
2. 处理子节点：
   - 将节点的第一个子节点作为其左孩子（left child）。
   - 将该节点的其他子节点（按顺序）作为第一个子节点的右子树（right siblings）。
3. 递归应用：
   - 对每个子节点递归应用相同的规则。

转化成二叉树后的中序遍历等价于原树的后序遍历。

---

**In a binary search tree, the keys on the same level from left to right must be in sorted (non-decreasing) order.**

- [x] T
- [ ] F

对于任意节点，左子树所有节点的值一定小于右子树所有节点的值。
同一层的节点，左边的一定在某个节点的左子树，右边的在这个节点的右子树。
所以从左到右一定单调递增。

---

**In a binary search tree which contains several integer keys including 4, 5, and 6, if 4 and 6 are on the same level, then 5 must be their parent.**

- [ ] T
- [x] F

如果 4 和 6 是兄弟，5 一定是父亲；
如果 4 和 6 在同一层但不相邻，5 一定在中间，矛盾；
如果 4 和 6 相邻但不是兄弟，可以举出反例:

```
      5
     / \
    3   7
   / \ / \
  1  4 6  8
```

---

**In a max-heap with \( n \) (\( > 1 \)) elements, the array index of the minimum key may be \_\_\_\_.**

- [ ] A. 1
- [ ] B. \(\lfloor n/2 \rfloor - 1\)
- [ ] C. \(\lfloor n/2 \rfloor\)
- [x] D. \(\lfloor n/2 \rfloor + 2\)

最小值一定是叶节点。
一共 n 层的完全二叉树，最后一层第一个是\(2^{n-1}\)，最后一个是\(2^n-1\)，
总节点数\(2^{n-1} < N <2^n-1\)，\(\lfloor N/2 \rfloor + 1\)得到最后一行第一个

---

**Using the linear algorithm to build a min-heap from the sequence {15, 26, 32, 8, 7, 20, 12, 13, 5, 19}, and then insert 6. Which one of the following statements is FALSE?**

- [ ] A. The root is 5
- [ ] B. The path from the root to 26 is {5, 6, 8, 26}
- [x] C. 32 is the left child of 12
- [ ] D. 7 is the parent of 19 and 15

Using the linear algorithm to build a min-heap 是怎么样建堆？
建堆的两种方法：

1. 自底向上（Bottom-up，Linear-time Heapify）：从最后一个非叶节点开始，将每个节点和其子树变为堆。时间复杂度：$O(n)$。
2. 逐个插入（Top-down，Incremental Heap Construction）：排成完全二叉树，每个数插入到最后再调整。时间复杂度：$O(nlogn)$。

---

**If a \(d\)-heap is stored as an array, for an entry located in position \(i\), the parent, the first child and the last child are at:**

- [ ] A. \(\lceil (i + d - 2) / d \rceil\), \((i - 2)d + 2\), and \((i - 1)d + 1\)
- [ ] B. \(\lceil (i + d - 1) / d \rceil\), \((i - 2)d + 1\), and \((i - 1)d\)
- [ ] C. \(\lfloor (i + d - 2) / d \rfloor\), \((i - 1)d + 2\), and \(id + 1\)
- [ ] D. \(\lfloor (i + d - 1) / d \rfloor\), \((i - 1)d + 1\), and \(id\)

d-heap 什么意思?
d-heap 是堆（Heap）的一种泛化形式，其中每个节点最多有 d 个子节点（而非二叉堆的 2 个子节点）。它是完全 d 叉树（Complete d-ary Tree）。
可用 d=3 代入验证，排除错误选项

---

**If a binary search tree of \(N\) nodes is complete, which one of the following statements is FALSE?**

- [ ] A. the average search time for all nodes is \(O(\log N)\)
- [ ] B. the minimum key must be at a leaf node
- [x] C. the maximum key must be at a leaf node
- [ ] D. the median node must either be the root or in the left subtree

完全二叉树要求上面全满，最后一层从左到右填，不一定是满二叉树。
BST 的平均搜索时间是树的高度。平衡二叉树的高度是$log(N)$,故平均搜索时间是\(O(\log N)\)。
中位数（median node）的定义：

- 奇数个节点：正中间的节点（第 $\lfloor(N/2)\rfloor$个）。
- 偶数个节点：中间两个节点的第一个（即第 N/2 个节点，称为下中位数）。

N 为奇数时，中位数是根；N 为偶数时，中位数在左子树中。

---

**In Union/Find algorithm, if Unions are done by size, the depth of any node must be no more than \(N/2\), but not \(O(\log N)\).**

- [ ] T
- [x] F

通过按大小合并，任意节点的深度不超过\(O(\log N)\)（其中 N 是总元素数）。

---

**The array representation of a disjoint set containing numbers 0 to 8 is given by { 1, -4, 1, 1, -3, 4, 4, 8, -2 }. Then to union the two sets which contain 6 and 8 (with union-by-size), the index of the resulting root and the value stored at the root are:**

- [ ] A. 1 and -6
- [x] B. 4 and -5
- [ ] C. 8 and -5
- [ ] D. 8 and -6

disjoint set 是什么？ 并查集
习惯的并查集写法：root 和 merge，初始化为自环
上课讲的并查集写法：所有的根为负数，绝对值为这个连通块的大小

---

**A relation \( R \) is defined on a set \( S \). If for every element \( e \) in \( S \), "\( e \, R \, e \)" is always true, then \( R \) is said to be \_\_\_\_ over \( S \).**

- [ ] A. consistent
- [ ] B. symmetric
- [ ] C. transitive
- [x] D. reflexive

在数学中，关系 \( R \) 在集合 \( S \) 上可以有以下几种重要性质：

1. **自反性（Reflexive）**：

   - 定义：对于所有的 \( e \in S \)，有 \( e \, R \, e \)。
   - 例子：实数上的“≤”关系是自反的，因为对于任何实数 \( x \)，\( x \leq x \) 都成立。

2. **对称性（Symmetric）**：

   - 定义：对于所有的 \( a, b \in S \)，如果 \( a \, R \, b \)，那么 \( b \, R \, a \)。
   - 例子：“=”关系是对称的，因为如果 \( a = b \)，那么 \( b = a \)。

3. **传递性（Transitive）**：

   - 定义：对于所有的 \( a, b, c \in S \)，如果 \( a \, R \, b \) 且 \( b \, R \, c \)，那么 \( a \, R \, c \)。
   - 例子：“≤”关系是传递的，因为如果 \( a \leq b \) 且 \( b \leq c \)，那么 \( a \leq c \)。

4. **一致性（Consistent）**：
   - 这个术语在关系的性质中不常见，通常不是关系的基本性质之一。可能是指关系在某些上下文中的一致性，但一般不作为关系的标准性质。

---

**数据元素是数据的最小单位。F**

数据的最小单位是数据项（Data Item），而不是数据元素（Data Element）。

- 数据项：是不可分割的最小数据单位，也称为字段或属性。例如，学生的“学号”或“姓名”是一个数据项。
- 数据元素：是由若干数据项组成的，是数据的基本单位。例如，一个学生的完整记录（包括学号、姓名、年龄等数据项）是一个数据元素。

修正说法：

- “数据项是数据的最小单位。”（T）
- 或“数据元素是数据的基本单位。”（T）

---

**数据的逻辑结构是指数据的各数据项之间的逻辑关系。F**

错误原因：

- 逻辑结构的定义是数据元素之间的关系，而非数据项之间的关系。
  - 逻辑结构：描述数据元素之间的关联方式（如线性结构、树形结构、图结构等）。
  - 例如，学生记录（数据元素）按学号顺序排列是线性结构。
- 数据项之间的关系：属于数据元素的内部细节，是物理存储或具体实现的范畴。

混淆逻辑结构与物理结构：

- 逻辑结构是抽象的（如链表、树），与存储无关。
- 数据项之间的关系更接近物理存储（如结构体中的字段排列）。

修正说法：

- “数据的逻辑结构是指数据元素之间的逻辑关系。”（T）

---

**所谓随机存取，就是通过首地址和元素的位序号值可以在 O(1)的时间内找到指定的元素。T**

随机存取是指可以直接访问存储介质中的任意位置的数据，而无需按顺序遍历前面的数据。这种访问方式的特点是访问时间与数据位置无关，无论数据存储在哪个位置，都能以相同的速度直接读取或写入。

---

**将 N 个数据按照从小到大顺序组织存放在一个单向链表中。如果采用二分查找，那么查找的平均时间复杂度是 O(logN)。F**

**1. 二分查找的前提是“随机存取”**
二分查找（Binary Search）的核心操作是 **“通过下标直接访问中间元素”**（即 `arr[mid]`），这要求数据结构必须支持 **随机存取**（Random Access），例如：

- **数组**：通过下标可在 \( O(1) \) 时间内访问任意元素。
- **支持随机存取的线性结构**（如动态数组）。

但 **单向链表（Singly Linked List）** 的存储特性是：

- **不支持随机存取**：无法直接通过下标访问元素（如 `list[5]`）。
- **必须顺序遍历**：要访问第 \( k \) 个节点，必须从头节点开始逐个移动 \( k-1 \) 次。

---

**在任意一棵非空二叉搜索树，删除某结点后又将其插入，则所得二叉搜索树与删除前原二叉搜索树相同。 F**

删除非叶节点后该点被其他节点代替，树的结构发生改变。重新插入后一定是叶节点，一定不在原来的位置。

---

## 一些笔记

- 队列假溢出是什么？队头已满，队尾空，但会误认为队列已满。可用循环队列解决。
- 度为 2 的树不一定是二叉树。二叉树要求所有节点的度<=2，且子节点有顺序。可能存在树的子节点无顺序，即交换两个子节点不影响树的定义。
- 树的前序遍历和中序遍历不一定能推出后序遍历。要求为二叉树（或普通树但子节点有顺序）。
- 自然数认为包括零吗？包括。
- 图中顶点的度是什么？与该点直接相连的边的数量。有向图分入度和出度。
- 深度优先和广度优先搜索的数据结构：DFS 调用堆栈，实现深度优先；BFS 调用队列，保证按层遍历。
- 有向图中不存在回路，同一节点也可能被多次访问。因为同一节点入度可能大于 1，即可能被多个节点指向，遍历时可通过每个指向它的节点访问到该节点。
- 堆排序进行升序排序，必须建大根堆；降序排序，必须建小根堆。因为堆排序的规定操作为堆顶元素和最后一个未排序的元素交换。
- 虽然给出关键字序列的顺序不一样，但依次生成的二叉搜索树可能不一样。
- 拓扑排序可以用来检验图中是否有环。排序时入度为零的节点加入，并依次为基础修改其他点的入度。若所有点都被排序，则没有环（DAG）；若有的点没有被排序，则有环。
- Partial order is a precedence relation which is both transitive and irreflexive.偏序关系是一种优先关系，满足传递性和非自反性。

### AOE 网和 AOV 网是什么

**AOE 网（Activity On Edge network）**，即**边表示活动的网络**，是一种用于描述工程项目中活动及其依赖关系的有向无环图（DAG）。

AOE 网与 AOV 网的区别：

| 特性         | AOE 网                   | AOV 网（Activity On Vertex） |
| ------------ | ------------------------ | ---------------------------- |
| **表示方式** | 边表示活动，顶点表示事件 | 顶点表示活动，边表示依赖关系 |
| **权值**     | 边有权值（活动时间）     | 边无权值（仅表示顺序）       |
| **应用重点** | 计算关键路径和工期       | 拓扑排序（确定活动执行顺序） |

### 自底向上和逐个插入建堆的时间复杂度比较

自底向上建堆（Bottom-up Heap Construction）的时间复杂度为 **O(n)**，而非直观认为的 **O(n log n)**，这是由**堆的树状结构特性**和**每层节点数与调整成本的平衡**决定的。以下是详细分析：

**1. 复杂度分析的数学推导**
假设堆是一棵完全二叉树，高度为 **h = log₂n**，各层节点数和调整成本如下：

| 层级（从下到上）    | 节点数 | 最多下沉步数（高度） |
| ------------------- | ------ | -------------------- |
| 第 **h** 层（叶子） | ≈ n/2  | 0（无需调整）        |
| 第 **h-1** 层       | ≈ n/4  | 1                    |
| 第 **h-2** 层       | ≈ n/8  | 2                    |
| ...                 | ...    | ...                  |
| 第 **0** 层（根）   | 1      | h                    |

**总调整次数** **T(n)** 为各层节点数 × 其下沉步数之和：  
\[
T(n) = \sum*{i=0}^{h-1} (\text{第 } i \text{ 层节点数}) \times (\text{下沉步数}) = \sum*{i=0}^{h-1} \frac{n}{2^{i+1}} \cdot i
\]

简化求和（令 **k = h - i**）：  
\[
T(n) \leq n \sum*{k=1}^{h} \frac{k}{2^{k+1}} < n \sum*{k=1}^{\infty} \frac{k}{2^{k}} = n \cdot 2 = O(n)
\]  
（注：级数 \(\sum\_{k=1}^{\infty} \frac{k}{2^k} = 2\) 是收敛的）

**2. 直观理解**

- **大部分节点位于底层**：约 **n/2** 的叶子节点无需调整，**n/4** 的节点只需下沉 1 步。
- **高层节点少但代价高**：仅有 1 个根节点需下沉 **h** 步，但因其数量极少（1 个），对总复杂度的贡献被低层节点平衡。

**3. 对比自顶向下建堆（O(n log n)）**

- **自顶向下（插入式建堆）**：  
  每次插入一个新节点并执行 **上浮（Sift Up）**，共 **n** 次操作，每次最坏 **O(log n)**，总复杂度 **O(n log n)**。
- **自底向上**：  
  利用已有子树结构，从倒数第二层开始调整，**越上层节点调整次数越多，但节点数指数级减少**，总和收敛为 **O(n)**。

### 各种排序算法的时间和空间复杂度

**排序算法复杂度总表**

| 排序算法     | 平均时间复杂度    | 最坏时间复杂度    | 最优时间复杂度    | 空间复杂度             | 稳定性 | 适用场景                     |
| ------------ | ----------------- | ----------------- | ----------------- | ---------------------- | ------ | ---------------------------- |
| **冒泡排序** | \(O(n^2)\)        | \(O(n^2)\)        | \(O(n)\)          | \(O(1)\)               | 稳定   | 教学、小规模数据             |
| **选择排序** | \(O(n^2)\)        | \(O(n^2)\)        | \(O(n^2)\)        | \(O(1)\)               | 不稳定 | 简单实现，交换次数少         |
| **插入排序** | \(O(n^2)\)        | \(O(n^2)\)        | \(O(n)\)          | \(O(1)\)               | 稳定   | 小规模或部分有序数据         |
| **希尔排序** | \(O(n^{1.3})\)    | \(O(n^2)\)        | \(O(n)\)          | \(O(1)\)               | 不稳定 | 中等规模数据，插入排序优化版 |
| **归并排序** | \(O(n \log n)\)   | \(O(n \log n)\)   | \(O(n \log n)\)   | \(O(n)\)               | 稳定   | 大规模数据，外部排序         |
| **快速排序** | \(O(n \log n)\)   | \(O(n^2)\)        | \(O(n \log n)\)   | \(O(\log n)\)~\(O(n)\) | 不稳定 | 通用高效，内存排序           |
| **堆排序**   | \(O(n \log n)\)   | \(O(n \log n)\)   | \(O(n \log n)\)   | \(O(1)\)               | 不稳定 | 需要原地排序                 |
| **计数排序** | \(O(n + k)\)      | \(O(n + k)\)      | \(O(n + k)\)      | \(O(n + k)\)           | 稳定   | 非负整数，范围 k 较小        |
| **桶排序**   | \(O(n + k)\)      | \(O(n^2)\)        | \(O(n)\)          | \(O(n + k)\)           | 稳定   | 数据均匀分布                 |
| **基数排序** | \(O(n \times k)\) | \(O(n \times k)\) | \(O(n \times k)\) | \(O(n + k)\)           | 稳定   | 多关键字排序（如字符串）     |

---

**关键说明**

1. **时间复杂度**：

   - **快速排序**：平均性能最优，但最坏情况（如已排序数组）退化为 \(O(n^2)\)，可通过随机化枢轴避免。
   - **堆排序**：时间复杂度稳定，但常数因子较大，实际慢于快速排序。
   - **计数/桶/基数排序**：均基于非比较排序，时间复杂度突破 \(O(n \log n)\)，但需特定条件（如数据范围有限）。

2. **空间复杂度**：

   - **原地排序**：冒泡、选择、插入、希尔、堆排序的空间复杂度为 \(O(1)\)。
   - **递归开销**：快速排序平均 \(O(\log n)\)（递归栈），最坏 \(O(n)\)；归并排序需 \(O(n)\) 额外空间。

3. **稳定性**：
   - 稳定算法（如归并、冒泡）保持相等元素的原始顺序，适用于多关键字排序。
   - 不稳定算法（如快速、堆排序）可能改变相等元素的相对位置。

---

**各算法特点及适用场景**

1. **快速排序**：

   - **优点**：平均效率最高，缓存友好。
   - **缺点**：最坏情况性能差，需优化枢轴选择。
   - **适用**：通用场景，内存排序（如 C++ `std::sort`）。

2. **归并排序**：

   - **优点**：稳定，时间复杂度稳定。
   - **缺点**：需额外空间。
   - **适用**：外部排序（大数据文件）、链表排序。

3. **堆排序**：

   - **优点**：原地排序，无最坏情况风险。
   - **缺点**：缓存不友好，实际速度较慢。
   - **适用**：内存受限场景（如嵌入式系统）。

4. **计数/桶/基数排序**：
   - **优点**：线性时间复杂度。
   - **缺点**：对数据分布有要求（如范围小、均匀分布）。
   - **适用**：特定数据类型（如整数、字符串）。

---

### 栈、队列、树、图各种基本操作的时间复杂度

**一、栈（Stack）**
栈通常用 **数组** 或 **链表** 实现，操作时间复杂度相同：

| 操作            | 时间复杂度 | 说明                 |
| --------------- | ---------- | -------------------- |
| 入栈 `push`     | \(O(1)\)   | 直接添加到栈顶       |
| 出栈 `pop`      | \(O(1)\)   | 直接移除栈顶元素     |
| 查看栈顶 `peek` | \(O(1)\)   | 访问栈顶元素，不删除 |
| 判空 `isEmpty`  | \(O(1)\)   | 检查栈是否为空       |
| 搜索元素        | \(O(n)\)   | 需要遍历所有元素     |

---

**二、队列（Queue）**
**1. 普通队列（数组或链表实现）**

| 操作            | 时间复杂度 | 说明                                              |
| --------------- | ---------- | ------------------------------------------------- |
| 入队 `enqueue`  | \(O(1)\)   | 添加到队尾                                        |
| 出队 `dequeue`  | \(O(1)\)   | 移除队头元素（链表实现）                          |
|                 | \(O(n)\)   | 数组实现需移动元素（若用循环数组优化为 \(O(1)\)） |
| 查看队头 `peek` | \(O(1)\)   | 访问队头元素                                      |

**2. 优先队列（Priority Queue）**

| 操作              | 时间复杂度    | 说明               |
| ----------------- | ------------- | ------------------ |
| 插入              | \(O(\log n)\) | 基于堆（Heap）实现 |
| 删除最大值/最小值 | \(O(\log n)\) | 堆调整             |
| 查看最大值/最小值 | \(O(1)\)      | 访问堆顶元素       |

---

**三、树（Tree）**
**1. 二叉搜索树（BST，未平衡）**

| 操作 | 平均          | 最坏（退化为链表） | 说明         |
| ---- | ------------- | ------------------ | ------------ |
| 插入 | \(O(\log n)\) | \(O(n)\)           | 依赖树的高度 |
| 删除 | \(O(\log n)\) | \(O(n)\)           |              |
| 查找 | \(O(\log n)\) | \(O(n)\)           |              |

**2. 平衡二叉搜索树（AVL/红黑树）**

| 操作 | 时间复杂度    | 说明             |
| ---- | ------------- | ---------------- |
| 插入 | \(O(\log n)\) | 旋转操作保持平衡 |
| 删除 | \(O(\log n)\) |                  |
| 查找 | \(O(\log n)\) |                  |

**3. 堆（Heap，以二叉堆为例）**

| 操作             | 时间复杂度    | 说明             |
| ---------------- | ------------- | ---------------- |
| 插入 `push`      | \(O(\log n)\) | 上浮调整         |
| 删除堆顶 `pop`   | \(O(\log n)\) | 下沉调整         |
| 查看堆顶 `peek`  | \(O(1)\)      |                  |
| 构建堆 `heapify` | \(O(n)\)      | 从无序数组构建堆 |

**4. Trie（字典树）**

| 操作      | 时间复杂度 | 说明               |
| --------- | ---------- | ------------------ |
| 插入/删除 | \(O(L)\)   | \(L\) 为字符串长度 |
| 查找      | \(O(L)\)   |                    |

---

**四、图（Graph）**
**1. 图的表示方式**

- **邻接矩阵**：

  - 查询边是否存在：\(O(1)\)
  - 遍历相邻节点：\(O(V)\)（\(V\) 为顶点数）
  - 空间复杂度：\(O(V^2)\)

- **邻接表**：
  - 查询边是否存在：\(O(k)\)（\(k\) 为相邻节点数）
  - 遍历相邻节点：\(O(k)\)
  - 空间复杂度：\(O(V + E)\)（\(E\) 为边数）

**2. 常见算法时间复杂度**

| 算法                  | 时间复杂度            | 说明                     |
| --------------------- | --------------------- | ------------------------ |
| 深度优先搜索（DFS）   | \(O(V + E)\)          | 邻接表表示               |
| 广度优先搜索（BFS）   | \(O(V + E)\)          |                          |
| Dijkstra（优先队列）  | \(O((V + E) \log V)\) | 单源最短路径（无负权边） |
| Bellman-Ford          | \(O(VE)\)             | 允许负权边               |
| Floyd-Warshall        | \(O(V^3)\)            | 多源最短路径             |
| 拓扑排序              | \(O(V + E)\)          | 有向无环图（DAG）        |
| Kruskal（最小生成树） | \(O(E \log E)\)       | 基于并查集优化           |
| Prim（优先队列）      | \(O(E \log V)\)       |                          |

---

### 栈,顺序栈和链式栈

栈分为顺序栈(数组存储)和链式栈(链表存储)两种.

| **特性**     | **顺序栈**                        | **普通栈（泛指）**                      |
| ------------ | --------------------------------- | --------------------------------------- |
| **实现方式** | 数组（连续内存）                  | 不限定（可能是链式栈、顺序栈等）        |
| **存储结构** | 内存连续                          | 可能连续（顺序栈）或非连续（链式栈）    |
| **容量**     | 固定大小（需预分配）              | 可固定（顺序栈）或动态（链式栈）        |
| **扩容成本** | 需复制全部元素（高成本）          | 链式栈动态扩展（低成本）                |
| **操作速度** | 所有操作 \( O(1) \)（无指针开销） | 链式栈操作需维护指针（仍为 \( O(1) \)） |
| **适用场景** | 元素数量已知、高频操作            | 元素数量不确定或需频繁增删              |

### 倒序输出单链表

不反转链表，递归倒序输出:

> 1. 先递归处理下一个节点
> 2. 在递归返回后输出当前节点的值

倒序输出单链表:

```c
void printReverse(Node* head) {
  if (head == NULL) // 返回条件:空链表
   return;

  printReverse(head->next); // 先递归处理下一个节点
  printf("%d ", head->data); // 递归返回后输出当前节点数据
}
```

### 中缀转后缀

数据结构:stack,用于存放运算符;output,用于存放后缀表达式
步骤:

> 1. 输入变量:直接放入 output
> 2. 输入(:放入 stack
> 3. 输入):将 stack 中(之前的符号全部弹出,放入 output
> 4. 输入比栈顶优先级高的运算符:放入 stack
> 5. 输入比栈顶优先级低的运算符:弹出优先级高的栈顶符号,再将该符号放入 stack
> 6. 输入结束:将 stack 中剩余符号依次弹出,放入 output
>    代码:

```c
char postfix[N]; // 存放后缀表达式
char stk[N];     // 存放运算符

void infixToPostfix (char* infix, char* postfix) {
  for (int i = 0; i < 表达式长度; i++) {
    char ch = infix[i];
    int j = 0; // 跟踪postfix中位置
    if (ch是数字或变量) {
      postfix[j++] = ch;
    } else if (ch == '(') {
      push(stk, ch);
    } else if (ch == ')') {
      while (栈非空 && 栈顶 != '(') {
        postfix[j++] = pop(stk);
      }
      pop(stk); // 弹出左括号
    } else {    // 运算符处理
      while (栈非空 && 栈顶元素优先级 >= ch的优先级) {
        postfix[j++] = pop(stk);
      }
      push(stk, ch);
    }
  }
  while (栈非空) { // 弹出剩余运算符
    postfix[j++] = pop(stk);
  }
  postfix[j] = '\0'; // 添加字符串结束符
}
```

### BST 树操作

特点:左子树所有节点都比根小,右子树所有节点都比根大.
BST 树的中序遍历结果按从小到大排列
最小值和最大值是叶节点或只有一个儿子的节点
BST 树插入:

> 1. 找到插入位置:如果插入的数比根大,往左走;如果插入的数比根小,往右走
> 2. 新建节点并连接(插入形成的节点一定是叶节点)
>    BST 树删除:
> 3. 叶节点:直接删除
> 4. 有一个儿子:删除父亲,用儿子代替
> 5. 有两个儿子:找到左子树最大节点或右子树最小节点并删除,删除根,用该节点代替

BST 树插入节点(递归,链表):

```c
BSTNode* insert(BSTNode* rt, int val) {
  if (rt为空)
    return 建立新节点; // 返回条件

  if (val < rt的值) {
    rt的左儿子 = insert(rt的左子树, val);
  } else if (val > rt的值) {
    rt的右儿子 = insert(rt的右子树, val);
  }
  return rt;
}
```

BST 树插入节点(循环,数组):

```c
void insert(int* bst, int val) {
  if (bst[1]为初始值) {
    bst[1] = val; // val是根
    return;
  }

  int cur = 1; // 从根开始
  if (val < bst[cur]) {
    if (cur左子树空) {
      bst[cur * 2] = val;
      break;
    } else {
      cur = cur * 2;   // 下移cur
    }
  } else if (val > bst[cur]) {
    if (cur右子树空) {
      bst[cur * 2 + 1] = val;
      break;
    } else {
      cur = cur *2 + 1; // 下移cur
    }
  } else { // val已存在
    break;
  }
}
```

BST 树删除节点(递归,链表):

```c
BSTNode* delete(BSTNode* rt, int val) {
  if (rt为空)
    return rt;

  if (val < rt的值) {
    rt的左儿子 = delete(rt的左子树, val);
  } else if (val > rt的值) {
    rt的右儿子 = delete(rt的右子树, val);
  } else { // 要删除rt
    // 情况1:是叶节点或只有一个儿子
    if (rt的左儿子 == NULL) {
      BSTNode* tmp = rt的右儿子;
      free(rt);
      return tmp;
    } else if (rt的右儿子 == NULL) {
      BSTNode* tmp = rt的左儿子;
      free(rt);
      return tmp;
    }
    // 情况2:rt有两个儿子
    BSTNode* tmp = rt左子树的最大节点;
    rt的值 = tmp的值;
    rt的左儿子 = delete(rt的左子树, tmp的值);
  }
  return rt;
}
```

辅助函数,找到左子树中最大节点:

```c
BSTNode* findMax(BSTNode* node) {
  while (node的左子树非空) {
    node = node的左儿子;
  }
  return node;
}
```

### AVL 树平衡

平衡因子 BF:左子树高度-右子树高度
平衡因子绝对值需要<=1
每次插入或删除后通过旋转保持平衡

| 失衡类型 | 失衡节点 BF | 失衡节点儿子 BF | 旋转方式            |
| -------- | ----------- | --------------- | ------------------- |
| LL 型    | 2           | 左 1            | 右旋                |
| RR 型    | -2          | 右 -1           | 左旋                |
| LR 型    | 2           | 左 -1           | 左旋左儿子,然后右旋 |
| RL 型    | -2          | 右 1            | 右旋右儿子,然后左旋 |

AVL 树左旋(递归,链表):

```c
AVLNode* leftRotate(AVLNode *y) {
    // 保存节点指针
    AVLNode *x = y->right;
    AVLNode *B = x->left;

    // 旋转操作
    x->left = y;
    y->right = B; // 冲突的左儿子变为右儿子

    // 更新高度（必须先更新y，再更新x）
    updateHeight(y);
    updateHeight(x);

    return x; // 返回新的根节点
}
```

图示:
y x
\ / \
 x -- 左旋(y) --> y C
/ \ \
 B C B

AVL 树左旋(递归,链表):

```c
AVLNode* rightRotate(AVLNode *x) {
    // 保存节点指针
    AVLNode *y = x->left;
    AVLNode *B = y->right;

    // 旋转操作
    y->right = x;
    x->left = B; // 冲突的右儿子变为左儿子

    // 更新高度（必须先更新x，再更新y）
    updateHeight(x);
    updateHeight(y);

    return y; // 返回新的根节点
}
```

图示:
x y
/ / \
 y -- 右旋(x) --> A x
/ \ /
A B B

### 堆的操作(大根堆为例)

大根堆的特点:对于任何一个节点,节点的值大于所有子树中节点的值
堆一定是完全二叉树
将普通完全二叉树改为大根堆:

> 从第一个非叶节点开始倒着遍历,将每个子树改为堆
> (1) 如果根的值大于左右儿子,continue
> (2) 如果根的值小于一个儿子,用该儿子代替根,将根下移
> (3) 如果根比两个儿子都小,用较大的儿子代替根,将根下移

大根堆中插入元素:

> 1. 插入末尾
> 2. 上浮到正确位置

大根堆排序:

> 1. 建立大根堆
> 2. 将堆顶和最后一个未排序的元素交换,调整未排序的部分,直到全部排序

堆化:

```c
// 辅助函数,将i为根的子树堆化
void heapify(int* arr, int n, int i) {
  int largest = i;
  if (左儿子位置 < n && arr[左儿子] > arr[largest]) {
    largest = 左儿子位置;
  }
  if (右儿子位置 < n && arr[右儿子] > arr[largest]) {
    largest = 右儿子位置;
  }

  if (largest != i) {
    交换arr[i]和arr[largest];
    heapify(arr, n, largest);  // 递归调整受影响的子树
  }
}

// 将完全二叉树转换为大根堆
void buildMaxHeap(int arr[], int n) {
    // 从最后一个非叶子节点开始，向前遍历到根节点
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
}
```

堆中插入节点:

```c
// 辅助函数,上浮
void siftUp(int* heap, int idx) {
  while (idx > 0) {
    int pa = idx父亲的索引;
  }
  if (heap[idx] > heap[pa]) {
    交换heap[idx]和heap[pa];
    idx = pa; // 更新索引,向上检查
  } else {
    break;
  }
}

// 向大根堆中插入新元素
void insertMaxHeap(int* heap, int size, int capacity, int val) {
  if (size > capacity)
    return;

  heap[size++] = val; // 添加到末尾
  siftUp(heap, size-1);
}
```

堆排序:

```c
void heapSort(int* arr, int n) {
    // 1. 构建大根堆（从最后一个非叶子节点开始）
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // 2. 逐个提取元素
    for (int i = n - 1; i > 0; i--) {
        交换arr[0]和arr[i]; // 将当前根（最大值）移动到数组末尾
        heapify(arr, i, 0); // 对缩减后的堆进行调整
    }
}
```

## :smile:Class Six

### 优先队列(堆)

#### 目标功能

insert 和 delete,且每次 delete 删除最大值或最小值

#### 实现(小根堆为例)

- 几种传统方法:数组,链表,有序数组,有序链表...
- 小根堆:每个节点都是它所在子树的最小节点(order property).
- 从根节点到叶节点的任何路径都是从小到大.每次插入新节点时,在当前节点调成从小到大即可.(类似插入排序,由 i 跟 i-1 比换成 i 跟 i/2 比)
- 一层一层插入,得到完全二叉树(structure property).
- 多叉堆?树的高度降低,但总时间不变.
- 插入:

```c
// 插入元素
bool Insert(Heap H, int x){
  if (堆已满) return false

  i表示当前堆的大小(原先大小+1)
  for (i的父亲比i处的值大,i/2) {
    i的父亲下移到i处
  }
  // 此时i的父亲比i小,i表示要插入的位置
  第i位的值赋为x
}

// 删除(小根堆)
int DeleteMin(Heap H) {
  if (堆是空的)
    return ERROR

  min表示最小值(根)
  x表示当前堆的最后一个元素(堆的大小为原先大小-1)
  pa表示遍历的节点,child表示较小的子节点

  for (pa从根开始,pa的儿子不超过堆的大小,pa更新为child) {
    假设较小的child是pa的左儿子
    if (child不是最后一个,而且右儿子的值更小) {
      child更新为pa的右儿子
    }

    if (child的值比最后一个元素大)
      break
    else
      pa的值下移到child
  }

  // 此时pa表示x要插入的位置
  将第pa位赋为x

  return min
}

```

### 动态等价关系

给定元素和几个元素之间的等价关系,求任意两个元素之间是否等价.

```
// 构建
while (读入a和b等价) {
  if (a的集合!=b的集合) {
    合并两个集合
  }
}

// 查询
读入两个要查询的元素
if (a的集合==b的集合) {
  print (true)
}
```

用数组表示:下标代表元素,值代表根

## :cloud_with_lightning_and_rain:Class Seven

### 考试题型

选择题,函数填空,函数编程题(1 题)

### 等价类问题

给定集合,给定谁和谁等价,根据此等价划分集合. e.g.谁和谁是一组,图中最小生成树(城市之间连通道路的最小长度)
**最小生成树的一种方法**:

> 将所有边从小到大排序,一个一个放入生成的图检验.
> 当放入边后形成回路时,该边不正确.
> 核心是给定一条边,判定这条边的两个点分别属于什么集合.如果在同一组,放入;在不同组,不放入.
> 用`find`函数实现,同一组的点用`union`连接.

- 用树表示:这样的树不需要找儿子,只需要找父亲.因此所有节点都只有一个指针指向父亲.
- 用数组表示:索引代表当前节点,数值代表上一个父亲.如果`s[i]==0`,表示是根.
  集合的并:`s[rt1]=rt2`.

找到 parent 的代码:

```
  while (s[i]>0) {
    i=s[i];
  }
  return i;
```

- 合并方法:union by height,union by size(可推导树的高度不超过$log_2 N$),每次调整较小的树
- 怎么判断树的大小?之前树根用 0 表示,可以用负数表示树根,数值的绝对值表示树的大小.`s[root]=-size`.
- 路径压缩:找到树根时,这一条路上所有节点都经过.将这条路上的节点都直接指向树根.

```
数值 find(位置x,数组s) {
  if (s[x]<=0)               // 是树根
    return
  else
    return s[x]=find(s[x],s) // 找x上一个父亲的根,并用根更新s[x]
}
```

或使用两层循环:

```
数值 find(位置x,数组s) {
  for (root=x;s[root]>0;root=s[root]); // 不断更新root,先找到根

  for (trail=x;trail!=root;trail=lead) {
    lead=s[trail]; // 用于保存路径上的值
    s[trail]=root; // 将路径上的值更新为根
  }

  return root;
}
```

使用该方法时近似常量.

### 图

#### 人工智能原理

用简答的模型实现复杂的映射.其中的变量是权重.
设计评估函数判断设计的模型和训练数据之间的差距,成为误差函数$L(w_i)$.该函数是权重$w_i$的函数.不断调整权重使该函数的值最小.
相当于求函数的极小值.向导数为零的方向调整.利用的方法为梯度递降法.
神经网络的本质是图.大模型训练的本质是将能量转化为结构.

#### 图的描述

- G(V,E)分别表示点,边
- 一般考虑:没有自环,没有重边
- **完全图**:所有能连的边都连接.无向图边的条数为$C_n^2$.
- **子图**:点和边都是子集
- **路径**:点的序列,任何前后两点之间都有边连接
- **路径长度**:路径上有多少条边
- **简单路径**:路径上的点没有重叠
- **环**:简单路径,且头尾连接
- **连通图**:无向图:任何两个点都是连通的;有向图:任何两个点之间都有路径能走到.
- **连通子图(component)**:最大的连通的子图
- **树**:连通的,没有回路的图
- **DAG(directed acyclic graph)**:有向无环图,节点前后有依赖关系
- **强连通图(strong connected directed graph)**:任何两个点之间都有路径连接的有向图
- **弱连通图(weakly connected directed graph)**:任何两个点之间都有路径连接的无向图
- **强连通分量(strongly connected component)**
- **度(degree)**:每个点有几个点和它连通
- **入度(in-degree)**:有向图中,对于一个点,有多少其他点指向它
- **出度(out-degree)**:有向图中,对于一个点,它指向几个其他点

#### 图的表示(有向图)

**邻接表**:把所有该点出去的边都用链表串在一起
**逆邻接表**:将指向该点的点串在一起.
邻接表和逆邻接表完整地表示整个图

**十字链表(只用于有向图)**:用节点表示边,每个节点有 4 个分量,分别为 2 个数据和 2 个指针.用数组表示所有节点.数组中 vi 指向 vi 开头的节点.
前面的指针表示第一个数据指向谁,第二个指针表示什么数据指向第二个数据.

**多重链表 multilist(只用于无向图)**:数组出发的每个点将含有该点的节点串在一起.

#### 图的作用

1. 社群挖掘:将不同人之间的联系表示成图.根据每条边的权重划分社群.
   - 一种判断社群是否紧密的方法:里面的边和外面直接相连的边的比值
   - 可以根据点的入度,出度的权重判断点的性质

## :crystal_ball:Class Eight

### 拓扑排序

- **例子:**
  不同课程之间有依赖关系,有些课程需要其他课作为前置课程.用图表示依赖关系,有以下关系:
  - 形成无回路的有向图(DAG,有向无环图)
  - 用点或边表示要素(AOV)
- **目标:**
  根据课程的依赖关系,列出不矛盾的选课的顺序.
- **拓扑排序方法:**

  > 1. 找到第一门:入度为零的点
  > 2. 每找到一个点后,删除该点.(每次处理后图发生一点改动.)修改下一个点的入度.
  > 3. 每次随机选取入度为零的点,重复前两步.

- **部分有序(partial order)**
  有些点有序,有些点无序
- **代码:**

```c
void topSort(图 g) {
  for (int cnt = 0; cnt < 点的总数; cnt++) {
    int v = 找到一个入度为零的点;
    print(v);
    for (所有v指向的点w)
      w的入度--; // 从一个点出发,根据这个点修改周围点的信息
  }
}
```

- **怎么查找入度为零的点?**
  构建队列.每次修改入度时如果改后为零,加入队列.

```c
void topSort(图 g) {
  队列 Q;
  for (遍历所有点v) {
    if (v的入度 == 0)
      enqueue(v, Q);
  }
  while (Q非空) {
    v = dequeue(Q);
    print(v);
    for (所有v指向的点w) {
      if (--w的入度 == 0)
        enqueue(w, Q);
    }
  }
}
```

### 最短路径问题

单源最短路问题:Dijkstra

> 1. 初始化所有点的路径为无穷大
> 2. 找出没有被拓展过且距离源点最近的点
> 3. 将这个点标记为已经拓展过
> 4. (利用该点修改与它相连的点的信息.)判断新添加的路径长度是否小于原有长度,如果小于则更新长度

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1e3 + 5;
const ll inf = 4e18;

struct Node {
    int x, w;  // x表示出点，w表示权值
};
vector<Node> g[N];
ll d[N], n, m;

void dijkstra(int st) {
    memset(d, 0x3f, sizeof(ll) * (n + 1));  // 初始化为无穷大
    d[st] = 0;
    bitset<N> vis;  // vis表示是否拓展过,每个点只被拓展一次

    for (int i = 1; i <= n; i++) {
        // 找出距离源点最近的点
        int u = 1;
        for (int j = 1; j <= n; j++) {
            if (vis[u] || (!vis[j] && d[j] < d[u]))
                u = j;
        }

        vis[u] = true;  // 表示u已经拓展过

        // 此时d[u]已经为最优
        for (auto& [v, w] : g[u]) {
            if (!vis[v] && d[v] > d[u] + w)
                d[v] = d[u] + w;
        }
    }
}

// 用优先队列代替寻找最近点的过程
void dijkstra1(int st) {
    memset(d, 0x3f, sizeof(ll) * (n + 1));
    d[st] = 0;
    bitset<N> vis;  // vis表示是否拓展过

    priority_queue<Node> pq;
    pq.push((Node){st, d[st]});  // 起点作为拓展点

    while (pq.size()) {
        int x = pq.top().x;
        pq.pop();

        if (vis[x])
            continue;
        vis[x] = true;

        for (auto& [y, w] : g[x]) {
            if (!vis[y] && d[y] > d[x] + w) {
                d[y] = d[x] + w;
                pq.push((Node){y, d[y]});
            }
        }
    }
}

void solve() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        if (u != v)
            g[u].push_back({v, w});
    }

    dijkstra1(1);

    cout << (d[n] >= 4e18 ? -1 : d[n]) << '\n';
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int _ = 1;
    while (_--)
        solve();
    return 0;
}
```

不适用于负边情况:被拓展过一次后不再拓展
负边代码:

```c
void dijkstra(图 g) {
  队列 Q;
  enqueue(源点, Q);
  while (Q非空) {
    v = dequeue(Q);
    for (v指向的点w) {
      if (v的距离 + 边长度 < w的距离) {
        w的距离 = v的距离 + 边长度;
        if (w不在Q中)
          enqueue(w, Q);
      }
    }
  }
}
```

## :milky_way:Class Nine

### 所有点对的最短路径(All-Pairs Shortest Paths)

一点出发到其他点的最短路径：算一行（n 个值）
所有点对的最短路径(All-Pairs Shortest Paths)：算一个矩阵（n\*n 矩阵）

**动态规划：**
大问题分解为小问题。在某些场景下，分治法或递归时小问题可能重复计算，效率低（分治法是 top-down，从上到下计算）。
动态规划为 botton-up，先求基础解再求高层解。基础解可能有很多，需要用数组等结构存储。
分析问题的思路是 top-down，解答问题的流程是 botton-up。

**动态规划实现最短路径问题：**
D(i,j)表示 vi 出发到 vj 为最短路径，中间可能经过点集。
如果中间不经过任何点（为空集），答案为边长。
如果允许经过 v1 这个点，分为 vi 到 vj，和 vi 到 v1 再 v1 到 vj（这两段之间都是空集）。
如果允许经过 v1，v2 两个点，分为 vi 允许经过 v1 到 vj，和 vi 允许经过 v1 到 v2 再允许经过 v1 到 vj。

**Floyd**
初始化：边或无穷大
状态转移：允许经过点
基本框架:

```c
for (中转点k)
    for (起点i)
        for (终点j)
        //判断是否更新
        d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
```

### AOE 网(Activity On Edge)

从一个点出发有多个任务可以做。一个节点表示时间点，所有入边的任务都完成后才能做节点以后的任务。
为什么找关键路径？如果要把时间缩短，需要加快哪些任务才能使整体时间减少。
最早完成时间：所有之前的支路所需时间的最大值
可能建立 dummy activity（所需时间为 0），建立不同任务之间的关联。

EC(Early Complete time)：max{所有入点的 EC + 入边的时间} （表示每个任务最少多长时间才能到达）
LC(Last Complete time)：min{所有出点的 LC - 出边的时间} （表示每个任务能偷懒多长时间，最晚什么时候出发）
如果节点的 EC == LC，该点是关键点。关键点组成关键路径。

## :compass:Class Ten

### Network Flow Problems 网络流问题

城市改造涉及地下管网工程。从起点到终点有不同管道，不同管道的流量不同，用有向图表示。要求计算出最大流量。
一种方法：

> 遍历图，找到一条从起点到终点的路径，这条路径的最大流量为管道权值的最小值。
> 然后每条边减去取到的路径最大流量，剩余图重新遍历。
> 直到没有从起点到终点的路径时，得到的流量和为最大流量。

有什么问题？选择路径时可能与其他路径冲突，导致其他路径上路径被删除。
修改：建立反悔机制，某条线段流向可改变。
具体操作：

> 在某条路径删除后，添加流量相同的反向边。相当于将来可以反悔，重新经过被删除的边。
> 直到所有和起点相连的边都指向起点，终止。

时间复杂度：$T=O(f\cdot \left| E\right|)$，f 是最大流量
改进：

1. 下一步有不同选择时，优先选择流量大的边。
2. 每次选择边最少。

进一步强化：最大流量可能有不同路径，各个路径通过时有代价。需要找到最大流量且最低代价的路径。

### 最小生成树(Mininum Spanning Tree)

给定一个图，找到权重最小的生成树。
贪心算法(Greedy Method)
数学优化：给定函数和区间，求函数在区间上的最大值。随机选一个点，找出这个点的值 f(x0)。到左右 x0+d，x0-d，取三个值中最大值。每次找左右 d
的距离。当左右值都小于当前值时停止。
这种方法取到局部最优解。
得到全局最优解，每次移动时有一定概率跳到其他位置。

如何求最小生成树？

1. prim：以点为中心。
   > 随机找一个点，找和它连接的最短的边加入。
   > 再找和这个局部的树和外部连接的最短的边（边的一个端点局部的树中，另一个端点在树外），加入。
   > 重复找最短边、加入，直到所有的点都在树内。
2. kruskal：以边为中心（选择 n-1 条边，使得它构成树且权值和最小）。
   > 将所有边从小到大排列。从最短边开始，每次放一条边进去
   > 检查是否构成回路（这条边的两个端点是否连通），如果构成回路则跳过。
   > 当放入的边数到达 n-1 时停止。

### DFS 深度优先搜索

```c
void dfs(点 v) {
  vis[v] = true;
  for (与v相连的点w) {
    if (!vis[w]) {
      dfs(w);
    }
  }
}
```

如果整体不连通，在外面套 for 循环遍历图中所有点。

```c
void dfsConn(图 g) {
  for (g中的点v) {
    if (!vis[v]) {
      dfs(v);
      // ????
    }
  }
}
```

## :wind_chime:Class Eleven

### 深度优先遍历

```c
void dfs(点v) {
	for (与v相邻的点w) {
		if (w没有被访问过) {
			dfs(w);
		}
	}
}
```

### 判断连通块

```c
void solve(图 g) {
	for (g中的点v) {
		if (没访问过v) {
			dfs(v);
			cnt++;
		}
	}
}
```

### 双连通图问题

**双连通**：任意删除节点后，图不分裂成两个
删除后图分裂的点成为 articulation（关节点），没有 articulation 的图是 biconnected。
只有两个节点，中间用一条边连接，也是双连通图。
biconnected component: a maximum biconnected subgraph.
关键是找到关节点

> dfs 对图进行整理，根据 dfs 顺序形成树。起点是根结点，通过 v 找到 w，则 v 是 w 的父节点。
> 转化后缺少部分边，在树中补上。
> 这些新添加的边一定连接祖先和后裔，成为 back edge。（如果连接不同分支的边，一定通过这条边 dfs 时直接访问到。）
>
> > 什么点是关节点？
> >
> > 1.  至少含两个儿子的根节点
> > 2.  所有儿子都没有向上的回边。
>
> 同一分支上用数字表示层级，数字越小层级越大。回边将低层次与高层次的关系。
> 每个节点有两个数值，一个表示自己的层级 num，一个表示自己和所有儿子的最高层级 low。
> 当存在一个分支的 low< num，该点为关节点。

```
low(u) = min{num(u),
             min{low(w) | w is a child of u},
             min{num(w) | (u,w) is a back edge} }
```

u is an articulation point iff:

1. u is the root and has et least 2 children
2. u is not the root, and has at least 1 child such that low(child) >= num(u)

### 欧拉回路问题

**欧拉回路**：从任意一点出发，将所有边走一遍并回到起点。
**结论**：所有点的度都是偶数，则一定存在欧拉回路。
所有点的度之和一定是偶数。
度为奇数的点有两个，一定能从其中一个点出发走过所有边到达另外一个点。

怎么构造解？

> 所有点的度都是偶数，从任意一点出发 dfs，最后一定回到起点，但不一定把所有边走完。
> （每个点入和出的次数一定相等）
> 删除 dfs 回到起点后经过的路，剩下的所有点的度还是都为偶数。
> 在路径上选取还有边的点继续 dfs，直到所有边走完。

**哈密尔顿回路问题（旅行商问题）**
将所有点都走一遍

## :banjo:Class Twelve

### 排序

**简单排序：**

1. **选择排序 seection**：每次找最大的元素，放在末尾
2. **交换排序 exchange**：从头到尾遍历，看两个相邻元素是否符合，位置不对则交换（冒泡）
3. **插入排序 insertion**：每次之前的元素都排好，插入一个元素使其保持排序的特性。
   最坏时间复杂度和平均时间复杂度都是 O(n^2)
   但最好时间复杂度不同，选择排序为 O(n^2)，冒泡排序可通过标签优化，插入排序最优为 O(n)。

**inversion 逆序对**：大的在前小的在后，成为一对逆序对。
如果长度为 n 的序列，最多 n*(n-1)/2 个逆序对，平均约 n*n/4 个逆序。
相邻两个元素对调，改变一个逆序对。
排序算法突破：跳着比较
**希尔排序**：分组比较+插入排序

**分治法：归并排序**
T(n)=2T(n/2)+Cn => T(n)=O(nlogn)

**快速排序**：选择 pivot，将所有元素分为比它小和比它大。

**堆排序**：构建树，每次选出最大后。每层只有一个元素可能是第二大。

**桶排序**：

**基数排序**：先按个位数放入不同的桶，排成序列。再按十位数放入不同的桶，再按百位数……最后排成从小到大的序列。
循环的次数等于位数。

**排序的稳定性**：相等的元素排序前后顺序是不是相同。

插入排序对输入顺序敏感.如果输入数据基本排好,则排序时间短.

### 希尔排序

跨区域比较:分组

> 将数据间隔分组,每组排序
> 减少组数,再将每组排序
> 继续减少分组,直到只分一组,完成排序

若数据基本有序,插入排序时间接近线性.
分组多,单组时间复杂度低;分组少时,数据接近有序,时间线性.
开始时分 k 组,组内有序的时间复杂度为全部有序的 1/k.

```c
void shellsort(int arr[], int n) {
    for (int step = n / 2; step > 0; step /= 2) {  // step表示步长
        for (int i = step; i < n; i++) {
            int tmp = arr[i];
            int j;
            for (j = i; j >= step; j -= step) {  // 插入排序
                if (tmp < arr[j - step])
                    arr[j] = arr[j - step];
                else
                    break;
            }
            arr[j] = tmp;
        }
    }
}
```

按`step = n / 2; step > 0; step /= 2`分组,最坏时间复杂度:$O(N^2)$
Hibbard's Increment Sequence: 按$step=2^k-1$分组

### 堆排序

方法 1(不好)

```c
void heapsort(int arr[]) {
    BuildHeap(H);
    for (int i = 0; i < n; i++)
        tmpH[i] = DeleteMin(H);
    for (int i = 0; i < n; i++)
        H[i] = tmpH[i];
}
```

堆排序:

```c
void heapSort(int* arr, int n) {
    // 1. 构建大根堆（从最后一个非叶子节点开始）
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // 2. 逐个提取元素
    for (int i = n - 1; i > 0; i--) {
        交换arr[0]和arr[i]; // 将当前根（最大值）移动到数组末尾
        heapify(arr, i, 0); // 对缩减后的堆进行调整
    }
}
```

时间复杂度:$N\log N-N\log\log N$

### 归并排序(分治法)

先分别排序,再 merge.
时间复杂度:
分成两组:$O(1)$
递归将两组分别排序:$2T(N/2)$
merge: $O(N)$

quicksort: merge 的步骤减小时间.分组时选择 pivot,将所有元素分成比 pivot 小和比 pivot 大的两组.
这样分组不一定是 n/2 的两组,时间复杂度为$T(i)+T(N-i)$

```c
#include <stdio.h>

// 避免每次调用生成temp临时数组,在外部同一申请temp,作为参数传入
void merge(int a[],
           int left,
           int leftend,
           int right,
           int temp[]) {  // 合并两个有序数组
    int i, j, k;
    i = left;
    j = leftend + 1;
    k = left;

    while (i <= leftend && j <= right) {
        if (a[i] <= a[j])
            temp[k++] = a[i++];
        else
            temp[k++] = a[j++];
    }
    while (i <= leftend)
        temp[k++] = a[i++];
    while (j <= right)
        temp[k++] = a[j++];
}

// 设计成递归函数,必须将边界作为参数传入
void mergesort(int a[],
               int left,
               int right,
               int temp[]) {  // 排序，用temp临时存储
    if (left >= right)
        return;

    int mid = (left + right) / 2;
    mergesort(a, left, mid, temp);
    mergesort(a, mid + 1, right, temp);
    merge(a, left, mid, right, temp);
    for (int i = left; i <= right; i++) {
        a[i] = temp[i];
    }
}

int main() {
    int a[101], tempa[101];
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    mergesort(a, 0, n - 1, tempa);

    for (int i = 0; i < n; i++) {
        printf("%d ", a[i]);
    }
    printf("\n");

    return 0;
}
```

时间复杂度比较
和$T(n)=2T(n/2)+Cn$比较
$T(n)=3T(n/2)+Cn$: 更复杂
$T(n)=2T(n/3)+Cn$: 更简单

临时数组

1. 外部统一申请,作为参数传入
2. 每次合并新申请空间
3. 原地排序,不额外申请空间(复杂)
4. 两个相同长度的数组,一个排序时占用另一个数组
5. 三个已排序数组合并,用堆(??)

### 快速排序

**关键**:分组时选择 pivot,将所有元素分成比 pivot 小和比 pivot 大的两组.

**难点**:

1. 怎么选择 pivot
2. 原地排序,不额外申请数组

**选择 pivot 的方法**:

1. 选第一个(不好)
2. 随机选择(仍不好)
3. 头,尾,中间值三个中选中间值
4. 五等分点选中间值
5. 随便选一个分组,看两组是否均匀(可 1/4 为界),若均匀则继续进行,若不均匀则重来(按期望为做两次)

蒙塔卡洛:做特定次数,做完后停止,不管是否符合最佳条件
拉斯维加斯:按特定要求,若一直不符合要求则一直进行

但是,数组小时选 pivot 快排效率低.
在数组规模小于阈值时,直接使用简单排序.

**怎么原地分类?**

**两边扫描**

> 基准元素放在最后
> 指针 i 放在开头,比 pivot 小时向右走,>=时停下
> 指针 j 放在结尾,比 pivot 大时向左走,<=时停下
> 都停下时交换 i 和 j 的值
> 直到 i==j 或 i>j,将 pivot 放在最终位置

**一边扫描**

> 一个指针向右走,左边是小的一堆和大的一堆
> 如果指针处大,继续向右走
> 如果指针处小,和大的那堆的第一个元素交换(需要标记大的那堆的第一个元素位置)

**荷兰旗问题** 三种数据排序

> 一个指针向右走,左边是 R 的一堆,G 的一堆,B 的一堆
> 如果指针处是 B,继续向右走
> 如果指针处是 G,和 B 堆的第一个交换
> 如果指针处是 R,指针处元素放在 G 堆第一个位置,G 堆第一个放在 B 堆第一个位置,B 堆第一个放在指针位置

指针移动要求:维护扫过的区域符合要求.
双边扫描:左指针左侧都小,右指针右侧都大
一边扫描:指针左侧是分好的堆

## Class Thirteen

**循环不变式**

cutoff：当数组中元素数量小于该值时，不再调用递归（防止小数组时效率低）

```
int median3(int a[], int left, int right) {
	if (a[left] < a[mid])
		交换左，中；
	if (a[left] < a[right])
		交换左，右；
	if (a[mid] < a[right])
		交换中，右；
	// 此时已达到左 < 中 < 右
	交换中，右-1； // 将pivot 放在端位
	return a[right - 1];
}
```

```
void Qsort(int a[], int let, int right) {
	if (left + cutoff <= right) {
		for ( ; ; ) {
			while (a[++i] < pivot) ;
			while (a[- -j] > pivot) ;
			if (i < j) swap(i, j);
			else break;
		}
	} else {
		InsertionSort(a);
	}
}
```

时间复杂度： T(N) = T(i) + T(N-i-1) + cN
最坏：T(N) = T(N-1) + cN, T(N) = O(N^2)
最好：T(N) = 2T(N/2) +cN, T(N) = O(N logN)

**问题：给 n 个整数，求第 k 大的数**

1. 从大到小排序，取第 k 个 -> O(N logN)
2. 找基准元素，将所有元素分为比它小和比它大。如果大的元素有 k-1 个，则第 k 位基准元素；如果小于 k-1 个，从大的元素中找；……小，从小的元素中找 -> O(1+1/2+1/4+…N)=O(N)

**大结构的排序问题**
和数组排序不同，大结构交换的代价高。用 keyword 代替，根据大结构的性质对 keyword 排序。
关键问题：给定第几个元素放到编号几的位置，怎么重新编排数组？？

> 证明：通过比较、交换，不可能找到时间复杂度小于 O(N logN)的算法
> 任何基于比较的算法，都对应一个决策树。
> 其中，每个节点表示比较语句，分支表示 T 或 F 的情形，叶节点为最终排序结果。
> 叶节点总数为 n！，则树的高度至少 log N！。
> O(log N!) = O(N logN)

不用比较进行排序，时间复杂度可以小于 O(N logN)：如桶排序。

**基数排序**：分别按个位数、十位数……进行桶排序。（最不重要的数开始）
每次排序时按上一次排序结果遍历。先把一个桶中的数依次遍历完，再遍历下一个桶。

快速排序的需要 O(logN)的空间。（递归需要不断压栈）

**稳定性：**
插入排序 稳定
堆排序 不稳定（没有依次比较）
分组排序 不稳定
快速排序 不稳定

还可能考：经过几轮后数据序列，判断是什么排序方法

### 哈希

设计哈希函数，对每个 x 生成 y，且不同 x 得到不同的 y。

### 区块链应用

目的：让数组不可篡改不可替代
数据组织和管理技术：数据库（增删改查）、区块链（增查）
核心思想：

1. 把数据放在多个地方（分布式账本技术），多个备份
2. 把数据前后关联

每隔一定时间记录的所有数据形成一个区块。
将各个区块串联，形成区块链。
怎么将数据串联？用哈希函数。
给每个区块编号，前一个编号通过哈希函数得到下一个编号。
（哈希值可以作为 index，这里作为数据的指纹）

作用：建立可信机制

## Class Fourteen

### 比特币

**发行**:比特币总量一定,每十分钟发行,每四年每十分钟发行量减半
**流通**

- 怎么证明是自己的? 中心式数据库,每个人有账号和密码
- 怎么防止"双花"? 每个账号记录余额

比特币不受统一控制,不能建立中心式数据库.采用分布式账本.
解决分布式账本之间可能不同的问题:每隔一定时间选择一个人记录,将账本复制后分发,后续可补充

新交易创建 -> 交易通过 P2P 网络传播 -> 交易验证 -> 验证结果通过 P2P 网络传播 -> 交易写入账本

记账有好处,竞争计算速度.给定哈希函数生成值,计算输入值.(容易形成共识)
矿机:专门计算输入值的计算机
矿池:多台矿机
挖矿:猜输入值

怎么控制输出值 y?
y 有 128 位.如果 128 位全部随机生成,最大有 2^128 种,计算时间很长.
根据最近挖矿的计算机数量,限制 y 中 0 的个数,保证 10 分钟左右能挖到.

智能合约:普通程序,用来执行合同规定的某些条款.
问题:程序在信息空间,怎么判断物理空间中是否完成业务?
解决:找中间媒介,证明业务完成.
防止中间媒介造假:将数据传入区块链

### 哈希

哈希函数:以空间换时间,哈希值代表位置(区块链中代表指纹)
**应用:** 字典,搜索引擎({键:值})
搜索引擎:用爬虫爬取所有网页信息,将页面看成节点,构成巨大的图
-> 可能由不同路径到达同一个网页,需要对网页做标记(URL 地址),存储到 URL 集合
-> 直接比较 URL 则时间长,利用哈希函数,计算 URL 的哈希值

倒排索引:按关键词存储. 查询时找不同关键词的交集

哈希表:计算出 f(x)放到一行
identifier density : n/T (要存储的数据总数 / 通过哈希函数算出的值的所有可能值的总数)
loading density : n/(sb) (要存储的数据总数 / (slots \* buckets))

collision : 不同输入值有相同输出
overflow : 要存储的数据总数大于空间总数(同一输出值对应的输入值数量 > slots)

### 哈希函数的设计

**要求:**: 容易计算,输出均匀

整数:

1. 求余法: x -> x%p,一般取 p 为素数
2. 折叠法: 将长整数映射为两位数,则两位一段再相加,中间可以颠倒等
3. 平方取中: 平方后取中间的一段,使结果能被多位影响
4. 分析法

字符串:
字符串怎么变成数据?

1. 相加求余数. 防止输出值集中在较小值,可以`str[0]+str[1]*27+str[2]*27*27...`.(用 32 代替 27 可加快计算,从最高位开始乘一次,每次加新的值再移位)

### 冲突解决方法

1. **seperate chaining 链地址法**

   ```c
   struct HashTbl {
     int tableSize;
     List *theList;
   };
   ```

   `theList`中存储带头链表

2. **open address 开放地址法**
   `h(k) + f(i)`,冲突时`i++`或`+-i`,f(i)为线性时称为线性探测
   删除时可能判断错误,故删除时要做标记
   average search time 平均成功查找次数: 所有 search time 相加求平均
   平均不成功查找次数: 按入口分类

   线性探测冲突多,换成二次探测,依次调整为`f(i)=i^2`, `f(i)=i^3`..., 超出范围时求模返回
   二次探测可能发生二次聚集
   缺点:不一定能探测到空位

3. 公共区域
   冲突时开辟统一的新区域，存放冲突值。每次访问时先看原来的位置，空表示要访问的数不在；有数再看新区域，访问要访问的值。

## 补充

### Loading Density 是什么

**1. 定义**
Loading Density（也称为 Load Factor，装载因子）表示哈希表中已存储元素数量与哈希表总容量的比值：  
\[
\text{Loading Density} = \frac{\text{已插入的元素数量}}{\text{哈希表的总槽位数（Size）}}
\]

**2. 作用**

- **衡量空间利用率**：值越高，说明哈希表越“满”。
- **影响性能**：
  - 装载密度越高，发生哈希冲突的概率越大，查找/插入操作可能变慢。
  - 通常需要设定一个阈值（如 0.7），超过时触发扩容（Rehashing）。

**3. 与冲突的关系**

- **低装载密度（<0.5）**：冲突概率低，但空间浪费较多。
- **高装载密度（>0.7）**：冲突概率显著增加，线性探测等方法的性能下降。

**常见策略**：

- 当装载密度超过阈值（如 0.75），哈希表会扩容（通常加倍大小），并重新哈希所有元素。

## Class Fifteen

### 哈希动态查找问题

1. 查找树，只要解决树的平衡的问题
2. 计算，设计函数（哈希函数）

避免冲突：

1. 牺牲空间（以空间换时间）

开放地址法,二次探测
Thm. 如果满足:

1. 求余时用素数
2. 至少有一半位置空
   则可以证明有新的元素,则一定可以找到位置.

Pf:首先证明,如果 i,j 满足$0<i\neq j\le tablesize/2$, 则

$(h(x)+i^2)\% tablesize \neq (h(x)+j^2)\%tablesize $.

```c
position find (int key, hash H) {
  position pos;
  int colliNum;
  pos = hash(key, H.size());
  while (H[pos]非空 && H[pos].Element != key) {
    pos += 2 * ++colliNum - 1;   // 将平方变为乘2，加快计算速度
    if (pos > H.size())
      pos -= H.size();
  }
  return pos;
}
```

f(i)也可以时哈希函数(double hash 方法)
示例：`f(i) = i * hash(key)`, `f(i) = R - i * hash(key)`

Rehashing 方法
将原来的哈希表扩大一倍，将原来其中所有元素重新算一遍
什么时候需要 rehash？可能有以下几种情况：

1. 插入时冲突多，设置几次插入中冲突在几次以上，进行 rehash
2. 表的装载率超过设定时 rehash
3. 插入时找不到位置

## 另外

### 堆合并

每次取两树顶点的最小值作为合成后顶点，一颗子树直接作为合并后顶点的一个子树，另一个子树和合并前的另一个树合并（递归）
最左堆：不维护完全二叉树的特性，全部偏向左边

### 需要熟练掌握的程序

出入栈，出入队列，二叉树的左中右层次遍历，非递归遍历，堆的插入删除，查找树的查找插入删除，
图的 bfs dfs，最短路径，拓扑排序，
（森林的遍历）

### 课上复习

线性表
顺序存储：数组
链式存储：链表
数组与链表存储的优缺点
链表的操作
典型习题：实现单链表的原地逆转（循环不变式），
分别用一元多项式的两种表示实现多项式加法

堆栈
顺序栈：数组，top++, top--
lianzhan：链表，top 即头指针
应用：括号匹配检验，表达式求值，n 节汉诺塔问题（典型递归），迷宫问题
快速排序递归用堆栈怎么实现？每次递归偶参数，这个参数代表起点终点大小，一种方法将参数压到堆栈中，每次循环从堆栈中抛出元素，拆成两个再压到堆栈中
可以把所有递归用循环实现，核心是将参数压到堆栈中
迷宫问题：用数组表示迷宫，0 表示通路，1 表示墙。一直沿着某个方向走。每次将（位置坐标，方向选择）压栈，回头表示先不断压栈再不断抛出。回溯法。

两个堆栈实现队列
入队：
如果栈 1 满但栈 2 空，将栈 1 中元素倒入栈 2，再将新元素放入栈 1
如果栈 1 有元素但没满，将栈 2 倒回栈 1，再新元素入栈
出队：
如果栈 2 有元素，直接抛出
如果栈 2 空，将栈 1 所有元素倒入栈 2，再抛出

再一个数组中表示两个堆栈，实现空间共享：
两头表示两个堆栈，从两边向中间放。满的判定：`top_right == top_left + 1`

树，level 和 degree
中序遍历时，n 在 m 前的条件是：n 在 m 的左方
任意两点之间路径的长度的最大值定义未树的直径。给定树求直径

给定链表表示的二叉树，判断其是否为完全二叉树

左边是查找树，右边是查找树，根节点比左儿子打，比右儿子小，是不是查找树？ 不是
左边是堆，右边是堆，根比左右儿子大，是不是堆？ 是

设计算法，判断一个序列可不可能是查找顺序
初始为负无穷到正无穷。每次碰到小的元素，更新左边界；碰到大的元素，更新右边界。

树的双亲表示法和孩子表示法，左儿子右兄弟表示法。

图的表示：邻接矩阵，邻接表，逆邻接表，十字链表（有向图）

用 Floyd 算法判断图是否有回路？
Floyd：邻接矩阵的幂相加。检查对角线上元素，如果对角线上有非零元，则有环。

给定村庄和不同村庄间道路的长度。寻找位置，使其到各个村庄的距离之和最小。

哈希，求等概率成功与不成功查找的平均查找次数。

给定哈希函数和哈希结果，求最小的输入序列：构建有向图，求最小的拓扑序列

排序的辅助空间
堆排序：无辅助空间
快速排序：递归需要栈空间
归并排序：额外需要数组

排序算法是否稳定：需要交换的肯定不稳定

很大的数据，在不完全排序的前提下找出前 m 小的元素：
建立大小为 m 的堆，将所有元素依次插入

用快速排序找到第 k 大的元素

快速排序的非递归算法？
将递归转化为循环？

### 一些代码

BST.c

```c
#include <stdio.h>
#include <stdlib.h>

typedef int ElementType;
typedef struct TNode* Position;
typedef Position BinTree; /* 二叉树类型 */
struct TNode {            /* 树结点定义 */
    ElementType Data;     /* 结点数据 */
    BinTree Left;         /* 指向左子树 */
    BinTree Right;        /* 指向右子树 */
};

Position Find(ElementType X, BinTree BST) {
    if (!BST)
        return NULL; /*查找失败*/
    if (X > BST->Data)
        return Find(X, BST->Right); /*在右子树中继续查找*/
    else if (X < BST->Data)
        return Find(X, BST->Left); /*在左子树中继续查找*/
    else                           /* X == BST->Data */
        return BST;                /*查找成功，返回结点的找到结点的地址*/
}

Position IterFind(ElementType X, BinTree BST) {
    while (BST) {
        if (X > BST->Data)
            BST = BST->Right; /*向右子树中移动，继续查找*/
        else if (X < BST->Data)
            BST = BST->Left; /*向左子树中移动，继续查找*/
        else                 /* X == BST->Data */
            return BST;      /*查找成功，返回结点的找到结点的地址*/
    }
    return NULL; /*查找失败*/
}

Position FindMin(BinTree BST) {
    if (!BST)
        return NULL; /*空的二叉搜索树，返回NULL*/
    else if (!BST->Left)
        return BST; /*找到最左叶结点并返回*/
    else
        return FindMin(BST->Left); /*沿左分支继续查找*/
}

Position FindMax(BinTree BST) {
    if (BST)
        while (BST->Right) /*沿右分支继续查找，直到最右叶结点*/
            BST = BST->Right;
    return BST;
}

BinTree Insert(BinTree BST, ElementType X) {
    if (!BST) { /* 若原树为空，生成并返回一个结点的二叉搜索树 */
        BST = (BinTree)malloc(sizeof(struct TNode));
        BST->Data = X;
        BST->Left = BST->Right = NULL;
    } else { /* 开始找要插入元素的位置 */
        if (X < BST->Data)
            BST->Left = Insert(BST->Left, X); /*递归插入左子树*/
        else if (X > BST->Data)
            BST->Right = Insert(BST->Right, X); /*递归插入右子树*/
        /* else X已经存在，什么都不做 */
    }
    return BST;
}

BinTree Delete(BinTree BST, ElementType X) {
    Position Tmp;
    if (!BST)
        printf("要删除的元素未找到");
    else {
        if (X < BST->Data)
            BST->Left = Delete(BST->Left, X); /* 从左子树递归删除 */
        else if (X > BST->Data)
            BST->Right = Delete(BST->Right, X); /* 从右子树递归删除 */
        else {                                  /* BST就是要删除的结点 */
            /* 如果被删除结点有左右两个子结点 */
            if (BST->Left && BST->Right) {
                /* 从右子树中找最小的元素填充删除结点 */
                Tmp = FindMin(BST->Right);
                BST->Data = Tmp->Data;
                /* 从右子树中删除最小元素 */
                BST->Right = Delete(BST->Right, BST->Data);
            } else { /* 被删除结点有一个或无子结点 */
                Tmp = BST;
                if (!BST->Left) /* 只有右孩子或无子结点 */
                    BST = BST->Right;
                else /* 只有左孩子 */
                    BST = BST->Left;
                free(Tmp);
            }
        }
    }
    return BST;
}
```

表达式树

```c
/*
二元表达式可以很自然的联系到二叉树:
以基本运算对象作为叶节点中的数据,
以运算符作为非叶节点中的数据,
其两棵子树是它的运算对象,
子树可以是基本运算对象，也可以是复杂表达式.

算式表达式和表达式树的关系如下：
    表达式树的先根遍历：前缀表达式
    表达式树的中根遍历：中缀表达式
    表达式树的后根遍历：后缀表达式

构建表达式树:
1. 给定一个表达式的中缀形式：(4+1*(5-2))-6/3
2. 首先将每个运算加上括号，区分优先级，得到(4+(1*(5-2)))-(6/3)
3. 括号外的-优先级最低，作为根节点，(4+(1*(5-2)))作为左子树，(6/3)作为右子树；
4. 递归的转换4+(1*(5-2))，+最为根节点，4是左子树，
    (1*(5-2))是右子树。*是右子树的根节点，1是左子树，(5-2)是右子树。
    最后计算(5-2)，-是根节点，5是左子树，2是右子树。
构造好表达式树之后，前缀表达式和中缀表达式可根据先根遍历和后根遍历得到。
    前缀表达式：- + 4 * 1 - 5 2 / 6 3
    后缀表达式：4 1 5 2 - * + 6 3 / -
*/

#include <stdio.h>
#define MAXN 1000

int lch[MAXN], rch[MAXN];
char op[MAXN];
int nc = 0;  // 结点数

int build_tree(char* s, int x, int y) {
    int i, c1 = -1, c2 = -1, p = 0;
    int u;
    if (y - x == 1)  // 仅一个字符，建立单独结点
    {
        u = ++nc;
        lch[u] = rch[u] = 0;
        op[u] = s[x];
        return u;
    }
    for (i = x; i < y; i++) {
        switch (s[i]) {
            case '(':
                p++;
                break;
            case ')':
                p--;
                break;
            case '+':
            case '-':
                if (!p)
                    c1 = i;
                break;
            case '*':
            case '/':
                if (!p)
                    c2 = i;
                break;
        }
    }
    if (c1 < 0)
        c1 = c2;  // 找不到括号外的加减号，就用乘除号
    if (c1 < 0)
        return build_tree(s, x + 1, y - 1);  // 整个表达式被一对括号括起来
    u = ++nc;
    lch[u] = build_tree(s, x, c1);
    rch[u] = build_tree(s, c1 + 1, y);
    op[u] = s[c1];
    return u;
}

```

线索二叉树

```c
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

// 线索二叉树
typedef struct ThreadNode {
    int data;
    struct ThreadNode *left, *right;
    int ltag, rtag;  // tag为0表示有孩子
} ThreadNode;

// 指向当前访问变量的前驱
ThreadNode* pre = NULL;

void visit(ThreadNode* node);

// 初始化节点
ThreadNode* initNode() {
    ThreadNode* Node = (ThreadNode*)malloc(sizeof(ThreadNode));
    Node->left = NULL;
    Node->right = NULL;
    Node->ltag = 0;  // 默认节点有左右孩子
    Node->rtag = 0;
    return Node;
}

// 插入新节点并赋值
bool insertNode(ThreadNode* node, int data, int contain) {
    ThreadNode* newNode = initNode();
    // contain为0时向左插入,为1时向右插入
    if (node->left == NULL && contain == 0) {
        node->left = newNode;
        newNode->data = data;
        return true;
    } else if (node->right == NULL && contain == 1) {
        node->right = newNode;
        newNode->data = data;
        return true;
    }
    free(newNode);
    return false;
}

// 边中序遍历边线索化二叉树
void InThread(ThreadNode* node) {
    if (node != NULL) {
        InThread(node->left);   // 遍历左子树
        visit(node);            // 访问根节点
        InThread(node->right);  // 遍历右子树
    }
}

// 创建中序线索化二叉树
void createInThread(ThreadNode* node) {
    // 重置全局变量
    pre = NULL;
    InThread(node);
    // 最后一个遍历的节点的后继设置为NULL
    pre->right = NULL;
    pre->rtag = 1;
}

// 找到以node为根的子树中，最先被中序遍历的节点
ThreadNode* FirstNode(ThreadNode* node) {
    // 当为空时
    if (node == NULL) {
        return NULL;
    }
    while (node->ltag == 0) {
        node = node->left;
    }
    return node;
}

// 找到以node为根的子树中，最后被中序遍历的节点
ThreadNode* LastNode(ThreadNode* node) {
    if (node == NULL) {
        return NULL;
    }
    while (node->rtag == 0) {
        node = node->right;
    }
    return node;
}

// 访问根节点
void visit(ThreadNode* node) {
    if (node->left == NULL) {
        node->left = pre;
        node->ltag = 1;
    }

    if (pre != NULL && pre->right == NULL) {
        pre->right = node;
        pre->rtag = 1;
    }
    pre = node;
}

// 在中序二叉树中找到p的后继节点
ThreadNode* NextNode(ThreadNode* p) {
    if (p->rtag == 0) {
        return FirstNode(p->right);
    }
    return p->right;
}

void visit0(ThreadNode* thread_node) {
    printf("%d  ", thread_node->data);
}

// 利用线索对二叉树进行非递归遍历
void Inorder(ThreadNode* rootNode) {
    for (ThreadNode* p = FirstNode(rootNode); p != NULL; p = NextNode(p)) {
        visit0(p);
    }
}

// 在中序二叉树中找到p的前驱节点
ThreadNode* BeforeNode(ThreadNode* p) {
    if (p->ltag == 0) {
        return LastNode(p->left);
    }
    return p->left;
}

// 利用线索对二叉树进行非递归逆序遍历
void InorderNi(ThreadNode* rootNode) {
    for (ThreadNode* p = LastNode(rootNode); p != NULL; p = BeforeNode(p)) {
        visit0(p);
    }
}

int main(void) {
    // 初始化二叉树
    ThreadNode* rootNode = initNode();
    // 测试根节点插入数据
    rootNode->data = 1;
    printf("根节点数据:%d\n", rootNode->data);
    // 测试往二叉树创建节点
    insertNode(rootNode, 2, 0);
    insertNode(rootNode, 3, 1);
    printf("第二层左节点数据:%d\n第二层右节点数据:%d\n", rootNode->left->data,
           rootNode->right->data);
    insertNode(rootNode->left, 4, 1);
    insertNode(rootNode->right, 5, 1);
    printf("第三层第一个节点右指针数据:%d\n第三层第二个节点右指针数据:%d\n",
           rootNode->left->right->data, rootNode->right->right->data);
    insertNode(rootNode->left->right, 6, 0);
    printf("第四层第一个节点左指针数据:%d\n",
           rootNode->left->right->left->data);

    createInThread(rootNode);

    printf("中序遍历:\n");
    Inorder(rootNode);
    printf("\n逆中序遍历:\n");
    InorderNi(rootNode);
}
```
