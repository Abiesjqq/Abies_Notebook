机器视觉：利用传感器（摄像头，激光雷达） + 算法（图像处理，深度学习）  
核心功能：识别，定位，跟踪，理解

## 基本概念

数字图像性质：

- 光度值（亮度或彩色），有不同颜色空间
- 位置按规则方式排列
- 坐标值隐含

数字图像的矩阵表示：$N\times M$的图像用$3\times N\times M$的矩阵表示（3 表示 RGB）

**空间分辨率**：数字图像中可分辨的细节程度，通常用单位长度内的像素数量（如每英寸像素数 PPI）来衡量，数值越高，图像越清晰细腻。

**灰度级分辨率**：数字图像中每个像素点能够表示的亮度层次多少，级数越高，图像的明暗过渡越平滑自然。

## 几何变换和灰度变换

仿射变化：经过旋转、平移、错切等变换后，相邻像素本身的性质不变

旋转：左乘旋转矩阵

灰度变换是指根据某种目标条件按一定变换关系逐点改变原图像中每一个选告诉灰度值的方法。  
设原灰度值$D=f(x,y)$，处理后灰度值为$D'=g(x,y)$，则灰度增强表示为：

$$g(x,y)=T[f(x,y)]\quad \text{or}\quad D'=T(D)$$

### 二值化算法——非零元素取一法

（传统方法）

对于灰度图像 f，若某像素灰度值为 0，则不变；若不为 0，则全部变为 255  
阈值 T 可自行设置

### 灰度线性变换

将图像中所有的点的灰度按照线性灰度变换函数进行变换  
令原灰度范围为$[z_1,z_2]$,线性变换后为$[z_1',z_2']$，则

$$g(x,y)=z_1'+\frac{z_2'-z_1'}{z_2-z_1}(f(x,y)-z_1)$$

### 窗口灰度变换

限定窗口为$[L,U]$，函数为：

$$
f(x)=
\begin{cases}
0, x<L \\
x,L\le x\le U \\
255, x>U
\end{cases}
$$

分段灰度变换同理。

### 灰度直方图

横坐标是灰度，用 r 表示；纵坐标是灰度值像素的个数，用 H 表示（也可以用图像灰度概率密度函数$P_r(r)$表示，它等于具有 r 灰度级的像素个数与图像总像素个数的比例）  
根据灰度直方图设置阈值

## 图像平滑处理和边缘检测

消除图像噪声的工作称之为图像平滑或滤波。  
平滑的目的：改善图像质量和抽出对象特征。

常见的平滑滤波算法有：线性平滑、非线性平滑、自适应平滑

- 线性平滑：对每一个像素点的灰度值用它的邻域值来代替，其邻域大小为：$N\times N$,$N$一般取奇数
- 非线性平滑：不对所有像素都用它的邻域平均值来代替，而是取一个阈值，当像素灰度值与其邻域平均值之间的差值大于已知值时才以均值代替；当像素灰度值与其邻域平均值之间的差值不大于阈值时取其本身的灰度值
- 自适应平滑：自适应平滑法是以尽量不模糊边缘轮廓为目标

### 二值图像黑白点噪声滤波

消去二值图像$f(i,j)$上的黑彩的噪声，当像$f(i,j)$周围的 8 个像素的平均值为 a 时，若$|f(i,j)-a|$的值在阈值（127.5）以上，则对$f(i,j)$的黑白进行翻转；否则不变。

对图像像素的处理方式上可以划分为点处理和区域处理。

- 点处理：输出像素值仅取决于输入像素值的图像处理方法
- 区域处理（卷积核）：输出像素值与输入像素在一定的范围内的相邻像素值有关

### 领域平均法

1.$3 \times 3$均值滤波：用当前像素及其周围$3 \times 3$邻域内所有像素的平均值替代当前像素，实现平滑降噪。 2. 超限邻域平均法：只有当邻域内某些像素与中心像素差异超过设定阈值时，才将这些像素替换为邻域平均值，从而减少异常值影响。 3.$N \times N$均值滤波器：与$3 \times 3$均值滤波类似，但窗口大小可扩展为任意$N \times N$，通过邻域平均实现更强平滑。 4. 选择式掩模平滑：通过设定规则（如与中心像素的灰度差阈值）来筛选邻域像素，仅对符合条件的像素进行加权或平均，从而在去除噪声的同时尽可能保留图像边缘与细节。

### 中值滤波

-$N \times N$中值滤波：窗口内各点的中值

- 十字型中值滤波：十字型屏蔽窗口 -$N \times N$最大值滤波：窗口内各点的最大值

### Roberts 边缘检测

Roberts 算子又称为交叉微分算法，基于交叉差分的梯度算法，通过局部差分计算检测边缘线条。  
Roberts 算子的模板分为水平方向$dx$和垂直方向$dy$，像素点处 x 和 y 方向上的梯度$Gx$、$Gy$为：

$$
dx=\begin{bmatrix}
-1 & 0 \\
0 & 1
\end{bmatrix},\quad
dy=\begin{bmatrix}
0 & -1 \\
1 & 0
\end{bmatrix}
$$

$$G_x=\frac{\partial f}{\partial x},\quad G_y=\frac{\partial f}{\partial y}$$

### Prewitt 边缘检测算子

Prewitt 算子采用$3 \times 3$模板对区域内的像素值进行计算，而 Robert 算子的模板为$2 \times 2$，
故 Prewitt 算子的边缘检测结果在水平方向和垂直方向均比 Robert 算子更加明显。

$$
dx=\begin{bmatrix}
-1 & 0 & 1 \\
-1 & 0 & 1 \\
-1 & 0 & 1
\end{bmatrix},\quad
dy=\begin{bmatrix}
-1 & -1 & -1 \\
0 & 0 & 0 \\
1 & 1 & 1
\end{bmatrix}
$$

### Sobel 边缘检测算子

Sobel 算子在 Prewitt 算子的基础上增加了权重的概念，认为相邻点的距离远近对当前像素点的影响是不同的，
距离越近的像素点对应当前像素的影响越大，从而实现图像锐化并突出边缘轮廓。

### 拉普拉斯(Laplacian)算子

拉普拉斯（ Laplacian ）算子是 n 维欧几里德空间中的一个二阶微分算子，常用于图像增强领域和边缘提取。
采用灰度差分，计算邻域内的像素。中心减去领域平均。

## 特征提取与匹配

关键点提取 K 个（远小于像素数 N），每个关键点的特征用 K 维向量表示  
用$K\times K$的矩阵表示图像特征  
对环境变化、遮挡和少量位姿变化的鲁棒性增强

### Harris 角点响应（Harris Corner Response）

表示图像中某个像素位置是角点、边缘还是平坦区域的“响应值”（response value），由**图像梯度的二阶矩阵（结构张量）**决定  
当窗口沿任意方向移动时，图像强度变化都较大，则为角点。

对每个像素，计算梯度：

$$
I_u = \frac{\partial I}{\partial u}, \quad
I_v = \frac{\partial I}{\partial v}
$$

构造二阶矩阵（结构张量）：

$$
M =
\begin{bmatrix}
\sum w\,I_u^2 & \sum w\,I_u I_v \\
\sum w\,I_u I_v & \sum w\,I_v^2
\end{bmatrix}
$$

其中$w$是窗口函数（通常是高斯加权）。

Harris 响应函数：

$$
R = \det(M) - k\,(\operatorname{trace}(M))^2
$$

-$\det(M) = \lambda_1 \lambda_2$ -$\operatorname{trace}(M) = \lambda_1 + \lambda_2$ -$k$为经验参数（通常$k = 0.04 \sim 0.06$）

解释响应值 R：

- R > 0 且较大 → 角点（两个方向梯度都大）
- R < 0 → 边缘（一个方向梯度大，另一个小）
- R ≈ 0 → 平坦区域（无显著梯度）

### SIFT 算子

局部特征描述子，用于图像匹配、目标识别和三维重建。  
对尺度、旋转不变，对光照和少量仿射变换具有鲁棒性。

1. 关键点检测：在图像的不同缩放层（高斯金字塔）中，找到局部最亮或最暗的点，这些点通常是角点或纹理丰富的位置，容易被识别。
2. 关键点精确定位：对找到的点进一步微调位置，去掉对比度太低或位于边缘的点，保证稳定可靠。
3. 方向分配：看关键点周围的梯度方向，把最显著的方向设为主方向，样即使图像旋转，描述子也能保持一致。
4. 描述子生成：取关键点周围一块小区域，划分成$4\times4$个小格子，每个小格子统计梯度方向分布（8 个方向）。把所有格子的统计结果连起来，得到 128 维向量。向量归一化，提高对光照变化的鲁棒性。

### 重复纹理？

采用相对度量方案 Ratio ，并结合阈值，通常取 0.7-0.9  
最接近的描述子，要比第二接近的描述子接近很多，解决重复纹理带来的问题

$$x'=argmin\frac{||F(x)-F(x')||}{||F(x)-F(x'')||}$$

### 剔除错误匹配

所有正确的特征匹配应当符合本质矩阵的关系

离群点不符合本质矩阵关系，但不知道本质矩阵

用 8 对匹配关系求解本质矩阵 E ，再将其他的匹配代入，检查方差是否满足

## 分割与检测

**目标检测 vs 图像分割**

- 目标检测：回答“图像中有什么”和“在哪里”
- 图像分割：将图像划分为有语义意义的区域（语义/实例/全景分割）

  **图像分割方法的发展**

- 传统方法：基于阈值的分割、基于边缘的分割、基于区域的分割
- 语义分割：对每个像素赋予语义类别（如道路、天空、行人），但不区分同类实例。
- 实例分割：同时识别语义类别和不同个体（如区分不同的行人）。
- 全景分割：结合语义分割和实例分割，对所有物体包括背景都要进行检测和分割，提供完整的场景理解。

**传统图像分割算法**

- 基于阈值的分割方法
- 基于边缘的分割方法
- 基于区域的分割方法

## 深度视觉感知

深度学习：以端到端的方式逐层抽象、逐层学习

### 人工神经网络

#### MCP 模型

给定 n 个二值化（0，1）的输入数据与连接参 MCP 神经元对输入数据线性加权求和，然后使用函数$\Phi(\cdot)$将加权累加结果映射为 0 或 1。

**激活函数：**

对输入信息进行非线性变换  
神经网络使用非线性函数作为激活函数（activation function），通过对多个非线性函数进行组合，来实现对输入信息的非线性变换。

**Softmax 函数：**

Softmax 函数一般用于多分类问题中，其将输入数据 xi 映射到第 i 个类别的概率 yi 如下：

$$y_i=softmax(x_i)=\frac{e^{x_i}}{\sum_{j=1}^k e^{x_j}}$$

输入通过 softmax 变换后，映射到(0,1)之间的概率值。

由于 Softmax 输出结果的值累加起来为 1，因此可将输出概率最大的作为分类目标。

**神经元：**

神经元是深度学习模型中基本单位，可以如下刻画神经元功能：

1. 对相邻前向神经元输入信息进行加权累加：$In=\sum_{i=1}^n w_i*a_i$
2. 对累加结果进行非线性变换（通过激活函数）：$g(x)$
3. 神经元的输出：$Out=g(In)$

神经元越多，非线性映射越复杂

**损失函数（代价函数）：**

损失函数（Loss Function）又称为代价函数（Cost Function），用来计算模型预测值与真实值之间的误差。

损失函数是神经网络设计中的一个重要组成部分。通过定义与任务相关的良好损失函数，在训练过程中可根据损失函数来计算神经网络的误差大小，进而优化神经网络参数。

两种最常用损失函数：

- 均方误差损失函数

均方误差损失函数通过计算预测值和实际值之间距离（即误差）的平方来衡量模型优劣。

假设有 n 个训练数据 xi，每个训练数据 xi 的真实输出为 yi，模型对 xi 的预测值为$\hat{y_i}$。该模型在 n 个训练数据下所产生的均方误差损失可定义如下：

$$MSE=\frac{1}{n}\sum_{i=1}^n (y_i-\hat{y_i})^2$$

- 交叉熵损失函数

交叉熵（cross entropy）是信息论中的重要概念，主要用来度量两个概率分布间的差异。

假定 p 和 q 是数据 x 的两个概率分布，通过 q 来表示 p 的交叉熵可如下计算：

$$H(p,q)=-\sum_x p(x) * \log q(x)$$

交叉熵刻画了两个概率分布之间的距离，旨在描绘通过概率分布 q 来表达概率分布 p 的困难程度。交叉熵越小，两个概率分布 p 和 q 越接近

假设数据 x 属于类别 1。记数据 x 的类别分布概率为 y，显然 y = (1,0,0)代表数据 x 的实际类别分布概率。记$\hat{y}$代表模型预测所得类别分布概率。

那么对于数据 x 而言，其实际类别分布概率 y 和模型预测类别分布概率$\hat{y}$的交叉熵损失函数定义为：

$$\text{cross entropy}=-y\times\log(\hat{y})$$

一个良好的神经网络要尽量保证对于每一个输入数据，神经网络所预测类别分布概率与实际类别分布概率之间的差距越小越好，即交叉熵越小越好。于是，可将交叉熵作为损失函数来训练神经网络。

??? normal-comment "交叉熵损失函数优化"

    上图给出了一个三个类别分类的例子。由于输入数据x属于类别1，因此其实际类别概率分布值为$y=(y_1,y_2,y_3)=(1,0,0)$。经过神经网络的变换，得到了输入数据x相对于三个类别的预测中间值$(z_1,z_2,z_3)$。然后，经过Softmax函数映射，得到神经网络所预测的输入数据x的类别分布概率$\hat{y}=(\hat{y_1},\hat{y_2},\hat{y_3})$。根据前面的介绍，$\hat{y_1}$、$\hat{y_2}$和$\hat{y_3}$为(0,1)范围之间的一个概率值。由于样本x属于第一个类别，因此希望神经网络所预测得到的$\hat{y_1}$取值要远远大于$\hat{y_2}$和$\hat{y_3}$的取值。

    训练中可利用如下交叉熵损失函数来对模型参数进行优化：

    $$\text{cross entropy}=-(y_1\times\log(\hat{y_1})+y_2\times\log(\hat{y_2})+y_3\times\log(\hat{y_3}))$$

    在上式中，$y_2$和$y_3$均为0、$y_1$为1，因此交叉熵损失函数简化为：

    $$-y_1\times\log(\hat{y_1})=-\log(\hat{y_1})$$

    在神经网络训练中，要将输入数据实际的类别概率分布与模型预测的类别概率分布之间的误差（即损失）从输出端向输入端传递，以便来优化模型参数。下面简单介绍根据交叉熵计算得到的误差从$\hat{y_1}$传递给$z_1$和$z_2$（$z_3$的推导与$z_2$相同）的情况。

    $$
    \frac{\partial \widehat{y}_1}{\partial z_1} = \frac{\partial}{\partial z_1} \left( \frac{e^{z_1}}{\sum_k e^{z_k}} \right) = \frac{(e^{z_1})' \times \sum_k e^{z_k} - e^{z_1} \times e^{z_1}}{(\sum_k e^{z_k})^2} = \frac{e^{z_1}}{\sum_k e^{z_k}} - \frac{e^{z_1}}{\sum_k e^{z_k}} \times \frac{e^{z_1}}{\sum_k e^{z_k}} = \widehat{y}_1(1 - \widehat{y}_1)
    $$

    （注意：在推导中应用了$(e^x)' = e^x$、$\left(\frac{v}{u}\right)' = \frac{v'u - vu'}{u^2}$等公式）

    由于交叉熵损失函数$-\log(\widehat{y}_1)$对$\widehat{y}_1$求导的结果为$-\frac{1}{\widehat{y}_1}$，$\widehat{y}_1(1 - \widehat{y}_1)$与$-\frac{1}{\widehat{y}_1}$相乘为${\widehat{y}_1 - 1}$。这说明一旦得到模型预测输出$\widehat{y}_1$，将该输出减去 1 就是交叉损失函数相对于$z_1$的偏导结果。

    $$
    \frac{\partial \widehat{y}_1}{\partial z_2} = \frac{\partial}{\partial z_2} \left( \frac{e^{z_1}}{\sum_k e^{z_k}} \right) = \frac{0 \times \sum_k e^{z_k} - e^{z_1} \times e^{z_2}}{(\sum_k e^{z_k})^2} = -\frac{e^{z_1}}{\sum_k e^{z_k}} \times \frac{e^{z_2}}{\sum_k e^{z_k}} = -\widehat{y}_1 \widehat{y}_2
    $$

    同理，交叉熵损失函数导数为$-\frac{1}{\widehat{y}_1}$，$-\widehat{y}_1 \widehat{y}_2$与$-\frac{1}{\widehat{y}_1}$相乘结果为${\widehat{y}_2}$。这意味着对于除第一个输出节点以外的节点进行偏导，在得到模型预测输出后，**只要将其保存**，就是交叉损失函数相对于其他节点的偏导结果。在$z_1$、$z_2$和$z_3$得到偏导结果后，再通过链式法则（后续介绍）将损失误差继续往输入端传递即可。

    在上面的例子中，假设所预测中间值$(z_1, z_2, z_3)$经过 Softmax 映射后所得结果为$(0.34, 0.46, 0.20)$。由于已知输入数据$x$属于第一类，显然这个输出不理想而需要对模型参数进行优化。如果选择交叉熵损失函数来优化模型，则$(z_1, z_2, z_3)$这一层的偏导值为

     $$(0.34 - 1, 0.46, 0.20) = (-0.66, 0.46, 0.20)$$

    可以看出，**Softmax 和交叉熵损失函数相互结合**，为偏导计算带来了极大便利。偏导计算使得损失误差从输出端向输入端传递，来对模型参数进行优化。在这里，交叉熵与 Softmax 函数结合在一起，因此也叫 **Softmax 损失（Softmax with cross-entropy loss）**。

#### 感知机模型

**单层感知机：**

早期的感知机结构和 MCP 模型相似，由一个输入层和一个输出层构成，因此也被称为“单层感知机”。感知机的输入层负责接收实数值的输入向量，输出层则能输出 1 或-1 两个值。

单层感知机可被用来区分线性可分数据。在下图中，逻辑与(AND)、逻辑与非(NAND)和逻辑或(OR)为线性可分函数，所以可利用单层感知机来模拟这些逻辑函数。但是，由于逻辑异或（XOR）是非线性可分的逻辑函数，因此单层感知机无法模拟逻辑异或函数的功能。

**多层感知机：**

多层感知机由输入层、输出层和至少一层的隐藏层构成。网络中各个隐藏层中神经元可接收相邻前序隐藏层中所有神经元传递而来的信息，经过加工处理后将信息输出给相邻后续隐藏层中所有神经元。各个神经元接受前一级的输入，并输出到下一级，模型中没有反馈。层与层之间通过“全连接”进行链接，即两个相邻层之间的神经元完全成对连接，但层内的神经元不相互连接。

#### 参数优化

**梯度下降：**

梯度下降算法（Gradient Descent）是一种使得损失函数最小化的方法。梯度的反方向是函数值下降最快的方向，因此是损失函数求解的方向。

??? normal-comment "梯度下降法推导"

    假设损失函数$f(x)$是连续可微的多元变量函数，其泰勒展开如下（$\Delta x$是微小的增量）：

    $$
    f(x + \Delta x) = f(x) + f'(x)\Delta x + \frac{1}{2}f''(x)(\Delta x)^2 + \ldots + \frac{1}{n!}f^{(n)}(x)(\Delta x)^n
    $$

    $$
    f(x + \Delta x) - f(x) \approx (\nabla f(x))^T \Delta x
    $$

    因为我们的目的是**最小化损失函数**$f(x)$，则要求$f(x + \Delta x) < f(x)$，于是有：

    $$
    (\nabla f(x))^T \Delta x < 0
    $$

    在$(\nabla f(x))^T \Delta x = \|\nabla f(x)\| \cdot \|\Delta x\| \cdot \cos\theta$中，$\|\nabla f(x)\|$和$\|\Delta x\|$分别为损失函数梯度的模和下一轮迭代中$x$取值增量的模，两者均为正数。为了保证损失误差减少，只要保证$\cos\theta < 0$。

    当$\theta = 180^\circ$时，$f(x + \Delta x)$和$f(x)$之间的差值为：

    $$
    f(x + \Delta x) - f(x) = \|\nabla f(x)\| \cdot \|\Delta x\| \cdot \cos\theta = -\|\Delta x\| \cdot \|\nabla f(x)\|
    $$

    这说明**只要沿着损失函数梯度的反方向选取$x$的增量$\Delta x$**，就会保证损失误差下降最多、下降最快，犹如从山峰处沿着最陡峭路径可快速走到山谷。

    在前面的推导中忽略了损失函数的二阶导数以及其高阶导数的取值，因此在实际中引入步长$\eta$，用$x - \eta \nabla f(x)$来更新$x$（在具体实现时$\eta$可取一个定值）。

$$x_{new} = x_{old} - \eta \cdot \nabla f(x_{\text{old}})$$

**误差反向传播：**

误差反向传播算法(error back propagation, BP)是一种将输出层误差反向传播给隐藏层进行参数更新的方法。将误差从后向前传递，将误差分摊给各层所有单元，从而获得各层单元所产生的误差，进而依据这个误差来让各层单元负起各自责任、修正各单元参数。

??? normal-comment "误差反向传播推导"

    为了使损失函数$\mathcal{L}$取值减少（从而保证模型预测结果与实际结果之间的差距越来越小），需要求取损失函数$\mathcal{L}$相对于$w_1$的偏导，然后按照损失函数梯度的反方向选取一个微小的增量，来调整$w_1$的取值，就能够保证损失函数取值减少。即将$w_1$变为$w_1 - \eta \frac{d\mathcal{L}}{dw_1}$后，能使得损失误差减少。这里$\frac{d\mathcal{L}}{dw_1}$为损失函数$\mathcal{L}$对变量参数$w_1$的偏导。于是，需要求取损失函数$\mathcal{L}$对变量参数$w_1$的偏导。

    由于$w_1$与加权累加函数$X$和 sigmoid 函数均有关系，因此

    $$
    \frac{d\mathcal{L}}{dw_1} = \frac{d\mathcal{L}}{dO} \cdot \frac{dO}{dX} \cdot \frac{dX}{dw_1}
    $$

    在这个链式求导中：

    -$\frac{d\mathcal{L}}{dO}$与损失函数的定义有关；
    -$\frac{dO}{dX}$是对 sigmoid 函数求导，结果为$\frac{1}{1+e^{-X}} \times \left(1 - \frac{1}{1+e^{-X}}\right)$；
    -$\frac{dX}{dw_1}$是加权累加函数$w_1 \times out_1 + w_2 \times out_2 + w_3 \times out_3$对$w_1$求导，结果为$out_1$。

    链式求导实现了损失函数对某个自变量求偏导，好比将损失误差从输出端向输入端逐层传播，通过这个传播过程来更新该自变量取值。**梯度下降法**告诉我们，只要沿着损失函数梯度的反方向来更新参数，就可使得损失函数下降最快。

    参数$w_1$在下一轮迭代中的取值被调整为：

    $$
    w_1^{\text{new}} = w_1 - \eta \cdot \frac{d\mathcal{L}}{dw_1} = w_1 - \eta \cdot \frac{d\mathcal{L}}{dO} \cdot \frac{dO}{dX} \cdot \frac{dX}{dw_1} = w_1 - \eta \cdot \frac{d\mathcal{L}}{dO} \cdot \frac{1}{1+e^{-X}} \cdot \left(1 - \frac{1}{1+e^{-X}}\right) \cdot out_1
    $$

    按照同样的方法，可调整$w_2$、$w_3$以及图中未显示的其他参数的取值。经过这样的调整，在模型参数新的取值作用下，损失函数$\mathcal{L}(\theta)$会以最快下降方式逐渐减少，直至减少到最小值（即全局最小值）。

### 卷积神经网络（CNN）

#### 卷积操作

图像中像素点具有很强的空间依赖性，**卷积（convolution）**就是针对像素点的空间依赖性来对图像进行处理的一种技术。

在图像卷积计算中，需要定义一个**卷积核（kernel）**。卷积核是一个二维矩阵，矩阵中数值为对图像中与卷积核同样大小的子块像素点进行卷积计算时所采用的权重。

卷积核中的权重系数$w_i$是通过**数据驱动机制**学习得到，其用来捕获图像中某像素点及其邻域像素点所构成的特有空间模式。一旦从数据中学习得到权重系数，这些权重系数就刻画了图像中像素点构成的空间分布不同模式。

人的视觉神经细胞对不同的视觉模式具有**特征选择性（Feature Selectivity）**，即不同视觉神经细胞对边界、运动和颜色等不同信息具有强弱不同的选择性。因此，不同卷积核可被用来刻画视觉神经细胞对外界信息感受时的不同选择性。

卷积所得结果中，每个输出点的取值仅依赖于其在输入图像中该点及其邻域区域点的取值，与这个区域之外的其他点取值均无关，该区域被称为**感受野（receptive field）**。在卷积神经网络中，感受野是卷积神经网络每一层输出的**特征图（feature map）**上的像素点在输入图像上映射的区域大小。

示例：假设输入体积的大小为 [32x32x3]（例如 RGB CIFAR-10 图像）。如果感受野的大小为 5x5，共包含 3 个卷积核，则 Conv 层中的每个神经元将具有输入体积中 [5x5x3] 区域的权重，总共 553 = 75 个权重。请注意，沿深度轴的连通范围必须为 3，因为这是输入体积的深度。

??? normal-comment "空间维度计算"

    Generated by ai

    ## 🎯 一、目标

    给定一个输入图像（或特征图），经过一个卷积层后，输出的**空间尺寸（宽 × 高）**是多少？

    ---

    ## 🧮 二、核心公式

    输出的空间尺寸（宽度或高度）由以下公式决定：

    > ✅ **输出尺寸公式（对宽度或高度分别适用）**：

    $$
    \text{Output Size} = \left\lfloor \frac{W - F + 2P}{S} \right\rfloor + 1
    $$

    其中：

    | 符号 | 含义                     | 说明 |
    |------|--------------------------|------|
    | `W`  | 输入的空间尺寸（宽或高） | 例如 32（输入是 32x32） |
    | `F`  | 卷积核大小（Filter Size） | 例如 5x5 → F = 5 |
    | `P`  | 填充（Padding）          | 通常为 0（无填充）或 1、2 等 |
    | `S`  | 步长（Stride）           | 每次卷积核移动的像素数，通常为 1 或 2 |
    | `⌊ ⌋`| 向下取整                 | 如果结果不是整数，向下取整 |

    > ⚠️ 注意：这个公式对宽度和高度**分别独立计算**。如果输入是正方形（如 32x32），且卷积核也是正方形（如 5x5），且 padding 和 stride 在两个方向相同，则输出也是正方形。

    ---

    ## 📚 三、详细解释每个参数

    ### 1. 输入尺寸 W

    - 指输入图像或特征图在某个空间维度上的大小。
    - 例如：32×32×3 的图像 → W = 32（宽），H = 32（高）

    ### 2. 卷积核大小 F

    - 卷积核在空间维度上的尺寸。
    - 例如：5×5 的卷积核 → F = 5
    - 卷积核深度必须等于输入通道数（如输入是 3 通道，卷积核深度就是 3）

    ### 3. 填充 P（Padding）

    - 在输入图像的边缘补 0，目的是：
      - 控制输出尺寸（如保持输入输出尺寸一致）
      - 防止边缘信息丢失
    - 常见 padding：
      - `P = 0`：无填充（"valid" 卷积）
      - `P = (F - 1)/2`：当 F 为奇数时，可保持输出尺寸不变（"same" 卷积）

    📌 **例子**：F = 5，想保持输出尺寸不变 → P = (5-1)/2 = 2

    ### 4. 步长 S（Stride）

    - 卷积核每次移动的步长（像素数）
    - S = 1：逐像素滑动（最常见）
    - S = 2：跳着滑动，输出尺寸减半，用于降采样

    ---

    ## 📘 四、举例说明（多个场景）

    ### ✅ 例1：标准卷积（无填充，步长为1）

    - 输入：32×32×3
    - 卷积核：5×5，3个（输出通道=3）
    - Padding：0
    - Stride：1

    计算输出宽度：

    $$
    \text{Output} = \frac{32 - 5 + 2×0}{1} + 1 = \frac{27}{1} + 1 = 28
    $$

    → 输出尺寸：**28×28×3**

    > 🧠 为什么是 28？因为 5×5 的窗口从左上角开始，每次移动1格，横向最多能放 28 个位置（32 - 5 + 1 = 28）

    ---

    ### ✅ 例2：使用填充（Same Padding）

    - 输入：32×32×3
    - 卷积核：5×5
    - Padding：2（因为 (5-1)/2 = 2）
    - Stride：1

    计算：

    $$
    \text{Output} = \frac{32 - 5 + 2×2}{1} + 1 = \frac{32 - 5 + 4}{1} + 1 = \frac{31}{1} + 1 = 32
    $$

    → 输出尺寸：**32×32×3**（保持不变！）

    > ✅ 这就是 "same convolution" —— 输出和输入空间尺寸相同。

    ---

    ### ✅ 例3：大步长（用于降采样）

    - 输入：32×32×3
    - 卷积核：3×3
    - Padding：0
    - Stride：2

    计算：

    $$
    \text{Output} = \frac{32 - 3 + 0}{2} + 1 = \frac{29}{2} + 1 = 14.5 → \lfloor 14.5 \rfloor + 1 = 14 + 1 = 15
    $$

    → 输出尺寸：**15×15×?**

    > 📌 注意：29/2 = 14.5 → 向下取整得 14 → +1 = 15

    ---

    ### ✅ 例4：不能整除的情况（向下取整）

    - 输入：7×7
    - 卷积核：3×3
    - Padding：0
    - Stride：2

    $$
    \text{Output} = \frac{7 - 3 + 0}{2} + 1 = \frac{4}{2} + 1 = 2 + 1 = 3
    $$

    → 输出 3×3

    如果输入是 8×8：

    $$
    \frac{8 - 3}{2} + 1 = \frac{5}{2} + 1 = 2.5 → 2 + 1 = 3
    $$

    → 还是 3×3！最后半个窗口被丢弃（因为向下取整）

    ---

    ## 🖼️ 五、图示思维（以宽度为例）

    想象一个长度为 `W` 的一维信号，用长度为 `F` 的窗口，每次移动 `S` 步：

    输入: [ 0  1  2  3  4  5  6 ]   (W=7)
    卷积核长度 F=3, S=2, P=0

    位置0: [0 1 2] → 有效
    位置1:     [2 3 4] → 有效（移动2步）
    位置2:         [4 5 6] → 有效
    位置3:             [6 ? ?] → 超出边界 → 停止

    → 共3个位置 → 输出长度=3


    公式验证：

    $$
    (7 - 3)/2 + 1 = 4/2 + 1 = 2 + 1 = 3 ✅
    $$

    ---

    ## 📊 六、输出通道数怎么算？

    ⚠️ 注意：空间维度 ≠ 通道维度！

    - **空间维度**（宽、高）→ 用上面公式计算
    - **通道维度**（深度）→ **等于卷积核的数量！**

    📌 例子：

    - 输入：32×32×3
    - 使用 64 个 5×5 的卷积核，每个核深度=3（匹配输入通道）
    - 输出通道数 = 64
    - 空间尺寸按公式计算（如前面例1得 28×28）

    → 最终输出：**28×28×64**

    ---

    ## 📝 七、总结表格

    | 参数        | 符号 | 说明                          |
    |-------------|------|-------------------------------|
    | 输入宽/高   | W    | 如 32                         |
    | 卷积核大小  | F    | 如 5（表示 5×5）              |
    | 填充        | P    | 边缘补0的数量，如 0, 1, 2     |
    | 步长        | S    | 卷积核移动步长，如 1, 2       |
    | 输出宽/高   | O    | `⌊(W−F+2P)/S⌋ + 1`            |
    | 输出通道数  | —    | 等于卷积核的数量              |

    ---

    ## 💡 八、实用技巧

    1. **想保持尺寸不变？** → 使用 `P = (F - 1)/2`（F 必须是奇数）
    2. **想降采样？** → 使用 `S = 2`
    3. **遇到小数？** → 向下取整，多余部分被丢弃
    4. **深度不参与空间计算！** → 深度由卷积核数量决定

    ---

    ## 🚀 九、扩展：带 dilation（空洞卷积）？

    如果你遇到“空洞卷积（dilated convolution）”，公式会变成：

    $$
    \text{Output} = \left\lfloor \frac{W - F - (F-1)(D-1) + 2P}{S} \right\rfloor + 1
    $$

    其中 `D` 是 dilation rate。但这是进阶内容，初学可先掌握标准卷积。

#### 池化操作

由于图像中存在较多冗余，在图像处理中，可用某一区域子块的统计信息（如最大值或均值等）来刻画该区域中所有像素点呈现的空间分布模式，以替代区域子块中所有像素点取值，这就是卷积神经网络中**池化(pooling)操作**。池化操作对卷积结果特征图进行约减，实现了下采样，同时保留了特征图中主要信息。

对于输入的海量标注数据，通过多次迭代训练，卷积神经网络在若干次卷积操作、接着对卷积所得结果进行激活函数操作和池化操作下，最后通过全连接层来学习得到输入数据的特征表达，即**分布式向量表达(distributed vector representation)**。

#### 神经网络正则化

为了缓解神经网络在训练过程中出现的**过拟合**问题，需要采取一些正则化技术来提升神经网络的泛化能力(generalization)

#### CNN 经典架构介绍

??? normal-comment "CNN 发展里程和经典架构"

    好的，我们来简要回顾一下卷积神经网络（CNN）的发展里程和其中的经典架构。CNN是深度学习中最重要的架构之一，尤其在计算机视觉领域取得了革命性的成功。

    ### 发展里程与经典架构


    #### 1. LeNet-5 (1998) - 开创者
    *   **提出者**：Yann LeCun 等。
    *   **里程碑意义**：**首个成功应用的卷积神经网络**，用于手写数字识别（如银行支票识别）。
    *   **核心结构**：
        *   交替的卷积层（使用Sigmoid激活函数）和池化层（平均池化）。
        *   最后接全连接层进行分类。
    *   **贡献**：奠定了CNN“卷积层+池化层+全连接层”的基本结构。

    #### 2. AlexNet (2012) - 复兴者
    *   **提出者**：Alex Krizhevsky 等。
    *   **里程碑意义**：在ImageNet大赛上以**远超第二名**的成绩夺冠，引发了**深度学习革命**。
    *   **核心创新**：
        *   **使用ReLU激活函数**：解决了Sigmoid在深层网络中的梯度消失问题，训练速度更快。
        *   **使用Dropout**：在全连接层中使用，有效减轻了过拟合。
        *   **使用GPU进行训练**：证明了大规模并行计算在训练深度网络中的可行性。
    *   **结构**：可以看作是更深、更宽的LeNet，拥有5个卷积层和3个全连接层。

    #### 3. VGGNet (2014) - 深度探索者
    *   **提出者**：牛津大学Visual Geometry Group。
    *   **里程碑意义**：探索了**网络深度**与性能之间的关系，结构非常规整、优雅。
    *   **核心创新**：
        *   **小卷积核堆叠**：使用连续的多个3x3小卷积核来代替大的卷积核（如5x5, 7x7）。**优点**：在获得相同感受野的同时，减少了参数量，增加了非线性（更多ReLU层）。
        *   **构建了16-19层的深度网络**（VGG16, VGG19），证明了深度的重要性。
    *   **影响**：其均匀的结构设计对后续研究影响很大。

    #### 4. GoogLeNet / Inception v1 (2014) - 结构创新者
    *   **提出者**：Google Research。
    *   **里程碑意义**：获得了2014年ImageNet冠军，**重点提升计算效率**。
    *   **核心创新**：
        *   **Inception模块**：核心是一个**并行结构**，在同一层中同时使用1x1、3x3、5x5卷积和池化操作，最后将结果在通道维度上拼接。**思想是：让网络自己选择适合的滤波器大小**。
        *   **1x1卷积**：用于降维和升维，大大减少了计算量和参数量（称为“网络中的网络”）。
        *   **辅助分类器**：在中间层添加辅助输出，用于训练时梯度回传，缓解梯度消失问题。

    #### 5. ResNet (2015) - 深度突破者
    *   **提出者**：何恺明 等（Microsoft Research）。
    *   **里程碑意义**：获得2015年ImageNet冠军，**解决了极深网络的梯度消失和退化问题**，使得网络可以深达上百甚至上千层。
    *   **核心创新**：
        *   **残差块（Residual Block）**：引入**跳跃连接（Shortcut Connection）**。网络不再学习一个完整的输出`H(x)`，而是学习**残差`F(x) = H(x) - x`**，最终输出为`F(x) + x`。
        *   **优势**：跳跃连接使得梯度可以直接反向传播到前面的层，让超深网络的训练成为可能。ResNet-152及其变体成为了后来许多任务的强大骨干网络。

    #### 6. 后续重要架构（简要）
    *   **DenseNet (2017)**：比ResNet更极端的连接，每一层都直接连接到它后面的所有层。强化了特征传播和复用，进一步减轻梯度消失。
    *   **EfficientNet (2019)**：不再盲目加深、加宽网络或提高分辨率，而是提出一种**复合缩放方法**，同时平衡网络的深度、宽度和输入分辨率，以极小的计算代价获取极佳的精度。
    *   **Vision Transformer (ViT, 2020)**：虽然不再是纯CNN，但它表明**Transformer架构**仅通过自注意力机制也能在图像分类任务上达到 state-of-the-art 的性能，开创了新的研究方向。

    ---

    ### 总结与趋势

    | 架构 | 核心贡献 | 关键年份 |
    | :--- | :--- | :--- |
    | **LeNet-5** | CNN奠基之作 | 1998 |
    | **AlexNet** | 开启深度学习浪潮 | 2012 |
    | **VGGNet** | 探索网络深度与规整化设计 | 2014 |
    | **GoogLeNet** | 并行结构（Inception），提升效率 | 2014 |
    | **ResNet** | 跳跃连接，解决深度训练难题 | 2015 |
    | **DenseNet** | 密集连接，强化特征复用 | 2017 |
    | **EfficientNet** | 模型缩放，追求效率与精度平衡 | 2019 |

    **发展总体趋势**：
    1.  **深度不断增加**：从几层（LeNet）到上百层（ResNet）。
    2.  **计算效率不断提高**：从AlexNet的粗暴参数化到Inception、ResNet的精心设计，参数量更少，性能更高。
    3.  **连接方式不断创新**：从简单的顺序连接，到跳跃连接（ResNet），再到密集连接（DenseNet）。
    4.  **架构搜索与自动化**：从手工设计架构（AlexNet, VGG, ResNet）到通过神经网络架构搜索（NAS）自动寻找高效架构（EfficientNet）。
    5.  **跨范式融合**：CNN与Transformer的结合（如ViT, Swin Transformer）成为当前最前沿的方向。

### 循环神经网络（RNN）

**循环神经网络（Recurrent Neural Network, RNN）**是一类处理序列数据（如文本句子、视频帧等）时所采用的网络结构。先前所介绍的前馈神经网络或卷积神经网络所需要处理的输入数据一次性给定，难以处理存在前后依赖关系的数据。

循环神经网络的本质是希望模拟人所具有的记忆能力，在学习过程中记住部分已经出现的信息，并利用所记住的信息影响后续结点输出。循环神经网络在自然语言处理，例如语音识别、情感分析、机器翻译等领域有重要应用。

时刻$t$所得到的隐式编码$h_t$是由上一时刻隐式编码$h_{t-1}$和当前输入$x_t$共同参与生成的，这可认为隐式编码$h_{t-1}$已经“记忆”了$t$时刻之前的时序信息，或者说前序时刻信息影响了后续时刻信息的处理。

与前馈神经网络和卷积神经网络在处理时需要将所有数据一次性输入不同，这体现了循环神经网络（RNN）可刻画序列数据存在**时序依赖**这一重要特点。

#### 长短时记忆网络（LSTM）

**（略）**

与简单的循环神经网络结构不同，长短时记忆网络（Long Short-Term Memory，LSTM）中引入了**内部记忆单元（internal memory cell）和门（gates）**两种结构来对当前时刻输入信息以及前序时刻所生成信息进行整合和传递。在这里，内部记忆单元中信息可视为对“历史信息”的累积。

常见的 LSTM 模型中有**输入门（input gate）**、**遗忘门（forget gate）** 和 **输出门（output gate）** 三种门结构。对于给定的当前时刻输入数据$x_t$和前一时刻隐式编码$h_{t-1}$，输入门、遗忘门和输出门通过各自参数对其进行编码，分别得到三种门结构的输出$i_t$、$f_t$和$o_t$。

在此基础上，再进一步结合前一时刻内部记忆单元信息$c_{t-1}$来更新当前时刻内部记忆单元信息$c_t$，最终得到当前时刻的隐式编码$h_t$。

### 深度生成学习

**（略）**

在之前的介绍中，神经网络模型从数据中提取出高层语义在数据中所蕴含的“模式”，并利用这些模式实现对数据的分类和检测等，这种模型通常称为**判别模型**，判别模型不关心数据如何生成，它只关心数据蕴含哪些模式以及如何将数据进行分类。与之相对的模型类型被称为**生成模型(generative model)**，生成模型需要学习目标数据的分布规律，以合成属于目标数据空间的新数据。

#### 生成对抗网络

**生成对抗网络（generative adversarial network，GAN）**可视为两个神经网络相互竞争的零和游戏（zero-sumgame），“以子之矛，陷子之盾”，最终达到纳什均衡。

生成对抗网络由一个生成器（generator，简称 G）和一个判别器（discriminator，简称 D）组成。GAN 的核心是通过生成器和判别器两个神经网络之间的竞争对抗，不断提升彼此水平以使得生成器所生成数据（人为伪造数据）与真实数据相似，判别器无法区分真实数据和生成数据。

**条件生成对抗网络**

#### 深度学习应用

图像分割与检测 经典 Two-Stage 方法：RCNN -> Fast RCNN -> Faster RCNN -> Mask RCNN

经典 Single-Stage 方法：YOLO/SOLO
