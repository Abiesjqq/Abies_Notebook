<!-- ## 斜堆

merge时不考虑Npl。每次拼接较小值的子树，翻转 -->

## 概念

**dist（或 Npl）**：对于任意一个节点，它的 dist 为这个节点到没有两个孩子的节点的最短距离  
对叶节点、只有一个孩子的节点，dist 都为 0

**左偏堆：**

- 是二叉堆
- 对任意节点，其左孩子的 dist 一定大于等于右孩子的 dist

左偏堆的性质：

- 任意节点的 dist = 其右孩子的 dist + 1（如果没有右孩子，则为 0）
- 若根节点的 dist 为 N，则前 N+1 层为满二叉树，整个左偏堆至少有$2^{N+1}-1$个节点
- 若整个左偏堆共 N 个节点，则右侧路径最多有$\lfloor \log(N+1) \rfloor$个节点

左偏堆最右侧的路径尽可能短，合并时只沿右侧路径合并，时间复杂度低

## 操作

节点的定义为：

```cpp
struct node {
    int val, d;   // 存储的值，dist
    node *l, *r;  // 左右儿子
};
```

### 递归合并

1. 将已经合并的顶点（记为 o）从根较小的堆开始，沿最右侧不断下移。
2. 每次有两个带合并的堆，分别为 o 的右儿子和另一个左偏堆。将这两者中根较小的作为 o 的右儿子。
3. 检查“放在 o 的右儿子”这一步是否违反左偏性质，调整并更新 o 的 dist。
4. 将 o 下移，递归进行。

代码：

```cpp
node* merge1(node* a, node* b) {
    if (!a)
        return b;
    if (!b)
        return a;

    if (a->val > b->val)     // o从根较小的堆开始
        swap(a, b);
    a->r = merge1(a->r, b);  // 递归合并o的右儿子和另一个堆

    if (!a->l || a->l->d < a->r->d)  // 维护左偏性质
        swap(a->l, a->r);
    a->d = a->r ? a->r->d + 1 : 0;   // 更新o的dist
    return a;
}
```

### 迭代合并

递归合并中，每次合并后紧接着维护左偏性质。  
而迭代合并中，先不考虑左偏性质、将两个左偏堆合并，用栈存储合并路径上的所有父节点。  
合并完后，回溯存储的父节点，依次调整左右儿子，使其保持左偏。

1. 将已经合并的顶点（记为 o）从根较小的堆开始，沿最右侧不断下移。
2. 若另一个堆小于 o 的右儿子，则交换到 o 右儿子的位置。
3. 在栈中存储合并的父节点 o。
4. 将 o 下移，递归进行。
5. 依次弹栈，维护左偏性质。

代码：

```cpp
node* merge2(node* a, node* b) {
    if (!a)
        return b;
    if (!b)
        return a;
    if (a->val > b->val)
        swap(a, b);

    node* root = a;    // 合并后根节点
    stack<node*> stk;  // 栈用于存储合并路径的父节点

    while (a->r && b) {   // 合并
        if (a->r->val > b->val)
            swap(a->r, b);
        stk.push(a);
        a = a->r;
    }
    a->r = b;

    while (stk.size()) {  // 调整合并路径上的点，维护左偏性质
        a = stk.top();
        stk.pop();
        if (!a->l || a->l->d < a->r->d)
            swap(a->l, a->r);
        a->d = a->r ? a->r->d + 1 : 0;
    }
    return root;
}
```
