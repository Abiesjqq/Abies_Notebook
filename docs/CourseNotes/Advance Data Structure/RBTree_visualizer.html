<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çº¢é»‘æ ‘å¯è§†åŒ–</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .controls {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .control-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
        }

        .input-group {
            display: flex;
            gap: 10px;
        }

        input[type="number"] {
            padding: 12px 20px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            font-size: 16px;
            width: 150px;
            transition: all 0.3s;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        button {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-warning:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(245, 87, 108, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #c82333;
            transform: translateY(-2px);
        }

        .presets {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .preset-btn {
            padding: 8px 15px;
            background: white;
            border: 2px solid #667eea;
            color: #667eea;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .preset-btn:hover:not(:disabled) {
            background: #667eea;
            color: white;
        }

        .main-content {
            display: flex;
            min-height: 600px;
        }

        .canvas-container {
            flex: 1;
            padding: 40px;
            background: white;
            overflow-x: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #treeCanvas {
            display: block;
        }

        .steps-panel {
            width: 400px;
            background: #f8f9fa;
            border-left: 2px solid #e9ecef;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 80px);
        }

        .steps-header {
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .steps-header h3 {
            font-size: 1.3em;
            margin-bottom: 5px;
        }

        .steps-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .step-item {
            background: white;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            animation: slideIn 0.3s ease;
        }

        .step-item.current {
            border-left-color: #28a745;
            background: #d4edda;
        }

        .step-item.highlight {
            animation: pulse 0.5s ease;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .step-number {
            display: inline-block;
            width: 30px;
            height: 30px;
            background: #667eea;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            margin-right: 10px;
        }

        .step-item.current .step-number {
            background: #28a745;
        }

        .step-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 1.05em;
        }

        .step-description {
            color: #555;
            line-height: 1.6;
            font-size: 0.95em;
        }

        .legend {
            display: flex;
            gap: 30px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-circle {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 3px solid;
        }

        .legend-red {
            background: #ff4757;
            border-color: #ff1744;
        }

        .legend-black {
            background: #2f3542;
            border-color: #333;
        }

        .info-panel {
            padding: 30px;
            background: #f8f9fa;
            border-top: 2px solid #e9ecef;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .info-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .info-card h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .info-card p {
            color: #495057;
            line-height: 1.6;
        }

        .message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            display: none;
            z-index: 1000;
            animation: slideInMsg 0.3s ease;
        }

        @keyframes slideInMsg {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideIn {
            from {
                transform: translateX(-20px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .message.success {
            border-left: 4px solid #28a745;
            color: #28a745;
        }

        .message.error {
            border-left: 4px solid #dc3545;
            color: #dc3545;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speed-control label {
            font-weight: 600;
            color: #495057;
        }

        .speed-control input[type="range"] {
            width: 150px;
        }

        @media (max-width: 1200px) {
            .main-content {
                flex-direction: column;
            }
            .steps-panel {
                width: 100%;
                max-height: 350px;
                border-left: none;
                border-top: 2px solid #e9ecef;
            }
            .steps-content {
                overflow-y: auto; 
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸŒ³ çº¢é»‘æ ‘å¯è§†åŒ–</h1>
            <p>äº¤äº’å¼çº¢é»‘æ ‘æ•°æ®ç»“æ„æ¼”ç¤º - æ”¯æŒæ’å…¥å’Œåˆ é™¤æ“ä½œ</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <div class="input-group">
                    <input type="number" id="valueInput" placeholder="è¾“å…¥æ•°å€¼" min="1" max="999">
                    <button class="btn-primary" id="insertBtn" onclick="insertValue()">æ’å…¥èŠ‚ç‚¹</button>
                    <button class="btn-warning" id="deleteBtn" onclick="deleteValue()">åˆ é™¤èŠ‚ç‚¹</button>
                </div>
                <div class="speed-control">
                    <label>åŠ¨ç”»é€Ÿåº¦:</label>
                    <input type="range" id="speedSlider" min="100" max="2000" value="1000" step="100">
                    <span id="speedLabel">1.0s</span>
                </div>
                <button class="btn-secondary" id="clearBtn" onclick="clearTree()">æ¸…ç©ºæ ‘</button>
                <button class="btn-danger" id="randomBtn" onclick="randomTree()">éšæœºç”Ÿæˆ</button>
            </div>

            <div class="presets">
                <span style="color: #6c757d; font-weight: 600;">é¢„è®¾ç¤ºä¾‹ï¼š</span>
                <button class="preset-btn" onclick="loadPreset([10, 20, 30, 15, 25, 40, 50])">ç¤ºä¾‹1</button>
                <button class="preset-btn" onclick="loadPreset([7, 3, 18, 10, 22, 8, 11, 26])">ç¤ºä¾‹2</button>
                <button class="preset-btn" onclick="loadPreset([1, 2, 3, 4, 5, 6, 7, 8, 9])">é¡ºåºæ’å…¥</button>
                <button class="preset-btn" onclick="loadPreset([50, 40, 30, 20, 10])">é€†åºæ’å…¥</button>
            </div>

            <!-- <div class="legend">
                <div class="legend-item">
                    <div class="legend-circle legend-red"></div>
                    <span>çº¢è‰²èŠ‚ç‚¹</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle legend-black"></div>
                    <span>é»‘è‰²èŠ‚ç‚¹</span>
                </div>
            </div> -->
        </div>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="treeCanvas"></canvas>
            </div>

            <div class="steps-panel">
                <div class="steps-header">
                    <h4>ğŸ“‹ æ“ä½œæ­¥éª¤</h4>
                </div>
                <div class="steps-content" id="stepsContent">
                    <div style="text-align: center; color: #6c757d; padding: 40px 20px;">
                        <p style="font-size: 1.2em; margin-bottom: 15px;">ğŸ‘‹ æ¬¢è¿ä½¿ç”¨çº¢é»‘æ ‘å¯è§†åŒ–å·¥å…·</p>
                        <p>ğŸ‘ˆ è¾“å…¥æ•°å€¼ï¼Œå¯ä»¥æ’å…¥æˆ–åˆ é™¤èŠ‚ç‚¹</p>
                        <p style="margin-top: 10px;">æˆ–ä½¿ç”¨é¢„è®¾ç¤ºä¾‹å¿«é€Ÿå¼€å§‹</p>
                        <p style="margin-top: 10px;">è¿™é‡Œä¼šæ˜¾ç¤ºæ¯ä¸€æ­¥çš„è¯¦ç»†æ“ä½œè¯´æ˜</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-grid">
                <div class="info-card">
                    <h3>ğŸ“Š æ ‘çš„ç»Ÿè®¡</h3>
                    <p id="treeStats">èŠ‚ç‚¹æ•°: 0<br>æ ‘é«˜: 0<br>é»‘é«˜: 0</p>
                </div>
                <div class="info-card">
                    <h3>ğŸ“– çº¢é»‘æ ‘æ€§è´¨</h3>
                    <p>
                        1. æ¯ä¸ªèŠ‚ç‚¹æ˜¯çº¢è‰²æˆ–é»‘è‰²<br>
                        2. æ ¹èŠ‚ç‚¹æ˜¯é»‘è‰²<br>
                        3. æ‰€æœ‰å¶å­èŠ‚ç‚¹æ˜¯é»‘è‰²<br>
                        4. çº¢è‰²èŠ‚ç‚¹çš„å­èŠ‚ç‚¹å¿…é¡»æ˜¯é»‘è‰²<br>
                        5. ä»æ ¹åˆ°å¶å­çš„æ‰€æœ‰è·¯å¾„åŒ…å«ç›¸åŒæ•°é‡çš„é»‘è‰²èŠ‚ç‚¹
                    </p>
                </div>
                <div class="info-card">
                    <h3>ğŸ¯ æ“ä½œè¯´æ˜</h3>
                    <p>
                        â€¢ è¾“å…¥æ•°å€¼åå¯ä»¥æ’å…¥æˆ–åˆ é™¤èŠ‚ç‚¹<br>
                        â€¢ è§‚å¯Ÿå³ä¾§è¯¦ç»†çš„æ“ä½œæ­¥éª¤è¯´æ˜<br>
                        â€¢ è°ƒæ•´åŠ¨ç”»é€Ÿåº¦æ§åˆ¶è§‚çœ‹èŠ‚å¥<br>
                        â€¢ ä½¿ç”¨é¢„è®¾ç¤ºä¾‹å¿«é€Ÿä½“éªŒ
                    </p>
                </div>
            </div>
        </div>
    </div>

    <div id="message" class="message"></div>

    <script>
        // çº¢é»‘æ ‘èŠ‚ç‚¹å®šä¹‰
        const RED = true;
        const BLACK = false;

        class Node {
            constructor(val) {
                this.val = val;
                this.color = RED;
                this.left = null;
                this.right = null;
                this.parent = null;
            }

            clone() {
                const newNode = new Node(this.val);
                newNode.color = this.color;
                if (this.left) {
                    newNode.left = this.left.clone();
                    newNode.left.parent = newNode;
                }
                if (this.right) {
                    newNode.right = this.right.clone();
                    newNode.right.parent = newNode;
                }
                return newNode;
            }
        }

        // æ“ä½œæ­¥éª¤è®°å½•
        let animationSteps = [];
        let animationSpeed = 1000;
        let isAnimating = false;

        class RBTree {
            constructor() {
                this.root = null;
            }

            cloneTree() {
                const newTree = new RBTree();
                if (this.root) {
                    newTree.root = this.root.clone();
                }
                return newTree;
            }

            rotateLeft(x) {
                const y = x.right;
                x.right = y.left;
                if (y.left) y.left.parent = x;

                y.parent = x.parent;
                if (!x.parent) this.root = y;
                else if (x === x.parent.left) x.parent.left = y;
                else x.parent.right = y;

                y.left = x;
                x.parent = y;
            }

            rotateRight(x) {
                const y = x.left;
                x.left = y.right;
                if (y.right) y.right.parent = x;

                y.parent = x.parent;
                if (!x.parent) this.root = y;
                else if (x === x.parent.left) x.parent.left = y;
                else x.parent.right = y;

                y.right = x;
                x.parent = y;
            }

            // æ’å…¥ä¿®å¤
            insertFix(z) {
                while (z.parent && z.parent.color === RED) {
                    if (z.parent === z.parent.parent.left) {
                        const y = z.parent.parent.right;
                        if (y && y.color === RED) {
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `æƒ…å†µ1ï¼šçˆ¶èŠ‚ç‚¹${z.parent.val}å’Œå”èŠ‚ç‚¹${y.val}éƒ½æ˜¯çº¢è‰²`,
                                detail: `è¿åäº†æ€§è´¨4ï¼ˆçº¢è‰²èŠ‚ç‚¹çš„å­èŠ‚ç‚¹å¿…é¡»æ˜¯é»‘è‰²ï¼‰ã€‚éœ€è¦é‡æ–°ç€è‰²ï¼šçˆ¶èŠ‚ç‚¹${z.parent.val}â†’é»‘è‰²ï¼Œå”èŠ‚ç‚¹${y.val}â†’é»‘è‰²ï¼Œç¥–çˆ¶èŠ‚ç‚¹${z.parent.parent.val}â†’çº¢è‰²ï¼Œç„¶åç»§ç»­å‘ä¸Šè°ƒæ•´ã€‚`,
                                highlightNodes: [z.val, z.parent.val, y.val, z.parent.parent.val]
                            });
                            
                            z.parent.color = BLACK;
                            y.color = BLACK;
                            z.parent.parent.color = RED;
                            
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `å˜è‰²å®Œæˆ`,
                                detail: `çˆ¶èŠ‚ç‚¹${z.parent.val}å’Œå”èŠ‚ç‚¹${y.val}å·²å˜ä¸ºé»‘è‰²ï¼Œç¥–çˆ¶èŠ‚ç‚¹${z.parent.parent.val}å˜ä¸ºçº¢è‰²ã€‚ç»§ç»­å‘ä¸Šæ£€æŸ¥ç¥–çˆ¶èŠ‚ç‚¹ã€‚`,
                                highlightNodes: [z.parent.parent.val]
                            });
                            
                            z = z.parent.parent;
                        } else {
                            if (z === z.parent.right) {
                                animationSteps.push({
                                    tree: this.cloneTree(),
                                    description: `æƒ…å†µ3-LRï¼šèŠ‚ç‚¹${z.val}æ˜¯çˆ¶èŠ‚ç‚¹${z.parent.val}çš„å³å­©å­ï¼Œå”èŠ‚ç‚¹æ˜¯é»‘è‰²`,
                                    detail: `è¿™æ˜¯ä¸€ä¸ª"ä¹‹å­—å½¢"ç»“æ„ï¼Œéœ€è¦å…ˆè½¬æ¢ä¸º"ä¸€å­—å½¢"ã€‚å¯¹çˆ¶èŠ‚ç‚¹${z.parent.val}è¿›è¡Œå·¦æ—‹ï¼Œå°†æƒ…å†µè½¬æ¢ä¸ºLLã€‚`,
                                    highlightNodes: [z.val, z.parent.val]
                                });
                                
                                z = z.parent;
                                this.rotateLeft(z);
                                
                                animationSteps.push({
                                    tree: this.cloneTree(),
                                    description: `å·¦æ—‹å®Œæˆï¼Œè½¬æ¢ä¸ºLLæƒ…å†µ`,
                                    detail: `ç°åœ¨èŠ‚ç‚¹${z.val}ã€${z.parent.val}ã€${z.parent.parent.val}å½¢æˆäº†ä¸€å­—å½¢ç»“æ„ï¼Œå¯ä»¥è¿›è¡ŒLLçš„å¤„ç†ã€‚`,
                                    highlightNodes: [z.val, z.parent.val, z.parent.parent.val]
                                });
                            } else {
                                animationSteps.push({
                                    tree: this.cloneTree(),
                                    description: `æƒ…å†µ2-LLï¼šèŠ‚ç‚¹${z.val}æ˜¯çˆ¶èŠ‚ç‚¹${z.parent.val}çš„å·¦å­©å­ï¼Œå”èŠ‚ç‚¹æ˜¯é»‘è‰²`,
                                    detail: `è¿™æ˜¯ä¸€ä¸ª"ä¸€å­—å½¢"ç»“æ„ã€‚éœ€è¦ï¼š1) çˆ¶èŠ‚ç‚¹${z.parent.val}â†’é»‘è‰²ï¼Œ2) ç¥–çˆ¶èŠ‚ç‚¹${z.parent.parent.val}â†’çº¢è‰²ï¼Œ3) å¯¹ç¥–çˆ¶èŠ‚ç‚¹å³æ—‹ã€‚`,
                                    highlightNodes: [z.val, z.parent.val, z.parent.parent.val]
                                });
                            }
                            
                            z.parent.color = BLACK;
                            z.parent.parent.color = RED;
                            
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `å˜è‰²å®Œæˆ`,
                                detail: `çˆ¶èŠ‚ç‚¹${z.parent.val}å˜ä¸ºé»‘è‰²ï¼Œç¥–çˆ¶èŠ‚ç‚¹${z.parent.parent.val}å˜ä¸ºçº¢è‰²ã€‚æ¥ä¸‹æ¥å¯¹ç¥–çˆ¶èŠ‚ç‚¹è¿›è¡Œå³æ—‹ã€‚`,
                                highlightNodes: [z.parent.val, z.parent.parent.val]
                            });
                            
                            this.rotateRight(z.parent.parent);
                            
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `å³æ—‹å®Œæˆ`,
                                detail: `å¯¹èŠ‚ç‚¹è¿›è¡Œå³æ—‹ï¼Œè°ƒæ•´å®Œæˆã€‚ç°åœ¨æ»¡è¶³æ‰€æœ‰çº¢é»‘æ ‘æ€§è´¨ã€‚`,
                                highlightNodes: [z.parent.val]
                            });
                        }
                    } else {
                        const y = z.parent.parent.left;
                        if (y && y.color === RED) {
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `æƒ…å†µ1ï¼šçˆ¶èŠ‚ç‚¹${z.parent.val}å’Œå”èŠ‚ç‚¹${y.val}éƒ½æ˜¯çº¢è‰²`,
                                detail: `è¿åäº†æ€§è´¨4ï¼ˆçº¢è‰²èŠ‚ç‚¹çš„å­èŠ‚ç‚¹å¿…é¡»æ˜¯é»‘è‰²ï¼‰ã€‚éœ€è¦é‡æ–°ç€è‰²ï¼šçˆ¶èŠ‚ç‚¹${z.parent.val}â†’é»‘è‰²ï¼Œå”èŠ‚ç‚¹${y.val}â†’é»‘è‰²ï¼Œç¥–çˆ¶èŠ‚ç‚¹${z.parent.parent.val}â†’çº¢è‰²ï¼Œç„¶åç»§ç»­å‘ä¸Šè°ƒæ•´ã€‚`,
                                highlightNodes: [z.val, z.parent.val, y.val, z.parent.parent.val]
                            });
                            
                            z.parent.color = BLACK;
                            y.color = BLACK;
                            z.parent.parent.color = RED;
                            
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `å˜è‰²å®Œæˆ`,
                                detail: `çˆ¶èŠ‚ç‚¹${z.parent.val}å’Œå”èŠ‚ç‚¹${y.val}å·²å˜ä¸ºé»‘è‰²ï¼Œç¥–çˆ¶èŠ‚ç‚¹${z.parent.parent.val}å˜ä¸ºçº¢è‰²ã€‚ç»§ç»­å‘ä¸Šæ£€æŸ¥ç¥–çˆ¶èŠ‚ç‚¹ã€‚`,
                                highlightNodes: [z.parent.parent.val]
                            });
                            
                            z = z.parent.parent;
                        } else {
                            if (z === z.parent.left) {
                                animationSteps.push({
                                    tree: this.cloneTree(),
                                    description: `æƒ…å†µ3-RLï¼šèŠ‚ç‚¹${z.val}æ˜¯çˆ¶èŠ‚ç‚¹${z.parent.val}çš„å·¦å­©å­ï¼Œå”èŠ‚ç‚¹æ˜¯é»‘è‰²`,
                                    detail: `è¿™æ˜¯ä¸€ä¸ª"ä¹‹å­—å½¢"ç»“æ„ï¼Œéœ€è¦å…ˆè½¬æ¢ä¸º"ä¸€å­—å½¢"ã€‚å¯¹çˆ¶èŠ‚ç‚¹${z.parent.val}è¿›è¡Œå³æ—‹ï¼Œå°†æƒ…å†µè½¬æ¢ä¸ºRRã€‚`,
                                    highlightNodes: [z.val, z.parent.val]
                                });
                                
                                z = z.parent;
                                this.rotateRight(z);
                                
                                animationSteps.push({
                                    tree: this.cloneTree(),
                                    description: `å³æ—‹å®Œæˆï¼Œè½¬æ¢ä¸ºRRæƒ…å†µ`,
                                    detail: `ç°åœ¨èŠ‚ç‚¹${z.val}ã€${z.parent.val}ã€${z.parent.parent.val}å½¢æˆäº†ä¸€å­—å½¢ç»“æ„ï¼Œå¯ä»¥è¿›è¡ŒRRçš„å¤„ç†ã€‚`,
                                    highlightNodes: [z.val, z.parent.val, z.parent.parent.val]
                                });
                            } else {
                                animationSteps.push({
                                    tree: this.cloneTree(),
                                    description: `æƒ…å†µ2-RRï¼šèŠ‚ç‚¹${z.val}æ˜¯çˆ¶èŠ‚ç‚¹${z.parent.val}çš„å³å­©å­ï¼Œå”èŠ‚ç‚¹æ˜¯é»‘è‰²`,
                                    detail: `è¿™æ˜¯ä¸€ä¸ª"ä¸€å­—å½¢"ç»“æ„ã€‚éœ€è¦ï¼š1) çˆ¶èŠ‚ç‚¹${z.parent.val}â†’é»‘è‰²ï¼Œ2) ç¥–çˆ¶èŠ‚ç‚¹${z.parent.parent.val}â†’çº¢è‰²ï¼Œ3) å¯¹ç¥–çˆ¶èŠ‚ç‚¹å·¦æ—‹ã€‚`,
                                    highlightNodes: [z.val, z.parent.val, z.parent.parent.val]
                                });
                            }
                            
                            z.parent.color = BLACK;
                            z.parent.parent.color = RED;
                            
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `å˜è‰²å®Œæˆ`,
                                detail: `çˆ¶èŠ‚ç‚¹${z.parent.val}å˜ä¸ºé»‘è‰²ï¼Œç¥–çˆ¶èŠ‚ç‚¹${z.parent.parent.val}å˜ä¸ºçº¢è‰²ã€‚æ¥ä¸‹æ¥å¯¹ç¥–çˆ¶èŠ‚ç‚¹è¿›è¡Œå·¦æ—‹ã€‚`,
                                highlightNodes: [z.parent.val, z.parent.parent.val]
                            });
                            
                            this.rotateLeft(z.parent.parent);
                            
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `å·¦æ—‹å®Œæˆ`,
                                detail: `å¯¹èŠ‚ç‚¹è¿›è¡Œå·¦æ—‹ï¼Œè°ƒæ•´å®Œæˆã€‚ç°åœ¨æ»¡è¶³æ‰€æœ‰çº¢é»‘æ ‘æ€§è´¨ã€‚`,
                                highlightNodes: [z.parent.val]
                            });
                        }
                    }
                }
                
                if (this.root.color === RED) {
                    animationSteps.push({
                        tree: this.cloneTree(),
                        description: `æ ¹èŠ‚ç‚¹éœ€è¦å˜ä¸ºé»‘è‰²`,
                        detail: `æ ¹èŠ‚ç‚¹${this.root.val}å½“å‰æ˜¯çº¢è‰²ï¼Œè¿åäº†æ€§è´¨2ï¼ˆæ ¹èŠ‚ç‚¹å¿…é¡»æ˜¯é»‘è‰²ï¼‰ã€‚å°†å…¶æŸ“æˆé»‘è‰²ã€‚`,
                        highlightNodes: [this.root.val]
                    });
                }
                
                this.root.color = BLACK;
                
                animationSteps.push({
                    tree: this.cloneTree(),
                    description: `æ’å…¥è°ƒæ•´å®Œæˆ`,
                    detail: `æ‰€æœ‰çº¢é»‘æ ‘æ€§è´¨å·²æ»¡è¶³ï¼Œæ’å…¥æ“ä½œæˆåŠŸå®Œæˆï¼`,
                    highlightNodes: []
                });
            }

            // åˆ é™¤ä¿®å¤
            deleteFix(x, xParent) {
                while (x !== this.root && (!x || x.color === BLACK)) {
                    if (x === xParent.left) {
                        let w = xParent.right;
                        
                        if (w && w.color === RED) {
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `æƒ…å†µ1ï¼šå…„å¼ŸèŠ‚ç‚¹${w.val}æ˜¯çº¢è‰²`,
                                detail: `å°†å…„å¼Ÿ${w.val}å˜é»‘ï¼Œçˆ¶èŠ‚ç‚¹${xParent.val}å˜çº¢ï¼Œç„¶åå¯¹çˆ¶èŠ‚ç‚¹å·¦æ—‹ï¼Œè½¬æ¢ä¸ºå…¶ä»–æƒ…å†µã€‚`,
                                highlightNodes: [w.val, xParent.val]
                            });
                            
                            w.color = BLACK;
                            xParent.color = RED;
                            this.rotateLeft(xParent);
                            w = xParent.right;
                            
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `è½¬æ¢å®Œæˆ`,
                                detail: `ç°åœ¨å…„å¼ŸèŠ‚ç‚¹æ˜¯é»‘è‰²ï¼Œç»§ç»­å¤„ç†ã€‚`,
                                highlightNodes: [w.val]
                            });
                        }
                        
                        if ((!w.left || w.left.color === BLACK) && 
                            (!w.right || w.right.color === BLACK)) {
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `æƒ…å†µ2ï¼šå…„å¼ŸèŠ‚ç‚¹${w.val}çš„ä¸¤ä¸ªå­èŠ‚ç‚¹éƒ½æ˜¯é»‘è‰²`,
                                detail: `å°†å…„å¼Ÿ${w.val}å˜çº¢ï¼Œç„¶åç»§ç»­å‘ä¸Šè°ƒæ•´çˆ¶èŠ‚ç‚¹ã€‚`,
                                highlightNodes: [w.val]
                            });
                            
                            w.color = RED;
                            x = xParent;
                            xParent = x.parent;
                            
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `å˜è‰²å®Œæˆï¼Œå‘ä¸Šè°ƒæ•´`,
                                detail: `å…„å¼ŸèŠ‚ç‚¹${w.val}å·²å˜çº¢ï¼Œç»§ç»­æ£€æŸ¥çˆ¶èŠ‚ç‚¹ã€‚`,
                                highlightNodes: [x ? x.val : -1]
                            });
                        } else {
                            if (!w.right || w.right.color === BLACK) {
                                animationSteps.push({
                                    tree: this.cloneTree(),
                                    description: `æƒ…å†µ3ï¼šå…„å¼ŸèŠ‚ç‚¹${w.val}çš„å³å­©å­æ˜¯é»‘è‰²ï¼Œå·¦å­©å­æ˜¯çº¢è‰²`,
                                    detail: `å°†å…„å¼Ÿçš„å·¦å­©å­${w.left.val}å˜é»‘ï¼Œå…„å¼Ÿ${w.val}å˜çº¢ï¼Œç„¶åå¯¹å…„å¼Ÿå³æ—‹ï¼Œè½¬æ¢ä¸ºæƒ…å†µ4ã€‚`,
                                    highlightNodes: [w.val, w.left.val]
                                });
                                
                                if (w.left) w.left.color = BLACK;
                                w.color = RED;
                                this.rotateRight(w);
                                w = xParent.right;
                                
                                animationSteps.push({
                                    tree: this.cloneTree(),
                                    description: `å³æ—‹å®Œæˆï¼Œè½¬æ¢ä¸ºæƒ…å†µ4`,
                                    detail: `ç°åœ¨å…„å¼Ÿçš„å³å­©å­æ˜¯çº¢è‰²ï¼Œå¯ä»¥è¿›è¡Œæœ€åçš„è°ƒæ•´ã€‚`,
                                    highlightNodes: [w.val]
                                });
                            }
                            
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `æƒ…å†µ4ï¼šå…„å¼ŸèŠ‚ç‚¹${w.val}çš„å³å­©å­æ˜¯çº¢è‰²`,
                                detail: `å°†å…„å¼Ÿ${w.val}æŸ“æˆçˆ¶èŠ‚ç‚¹${xParent.val}çš„é¢œè‰²ï¼Œçˆ¶èŠ‚ç‚¹å˜é»‘ï¼Œå…„å¼Ÿçš„å³å­©å­å˜é»‘ï¼Œç„¶åå¯¹çˆ¶èŠ‚ç‚¹å·¦æ—‹ã€‚`,
                                highlightNodes: [w.val, xParent.val, w.right ? w.right.val : -1]
                            });
                            
                            w.color = xParent.color;
                            xParent.color = BLACK;
                            if (w.right) w.right.color = BLACK;
                            this.rotateLeft(xParent);
                            x = this.root;
                            
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `å·¦æ—‹å®Œæˆï¼Œåˆ é™¤è°ƒæ•´ç»“æŸ`,
                                detail: `æ‰€æœ‰çº¢é»‘æ ‘æ€§è´¨å·²æ¢å¤ï¼Œåˆ é™¤æ“ä½œå®Œæˆï¼`,
                                highlightNodes: []
                            });
                        }
                    } else {
                        let w = xParent.left;
                        
                        if (w && w.color === RED) {
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `æƒ…å†µ1ï¼šå…„å¼ŸèŠ‚ç‚¹${w.val}æ˜¯çº¢è‰²`,
                                detail: `å°†å…„å¼Ÿ${w.val}å˜é»‘ï¼Œçˆ¶èŠ‚ç‚¹${xParent.val}å˜çº¢ï¼Œç„¶åå¯¹çˆ¶èŠ‚ç‚¹å³æ—‹ï¼Œè½¬æ¢ä¸ºå…¶ä»–æƒ…å†µã€‚`,
                                highlightNodes: [w.val, xParent.val]
                            });
                            
                            w.color = BLACK;
                            xParent.color = RED;
                            this.rotateRight(xParent);
                            w = xParent.left;
                            
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `è½¬æ¢å®Œæˆ`,
                                detail: `ç°åœ¨å…„å¼ŸèŠ‚ç‚¹æ˜¯é»‘è‰²ï¼Œç»§ç»­å¤„ç†ã€‚`,
                                highlightNodes: [w.val]
                            });
                        }
                        
                        if ((!w.right || w.right.color === BLACK) && 
                            (!w.left || w.left.color === BLACK)) {
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `æƒ…å†µ2ï¼šå…„å¼ŸèŠ‚ç‚¹${w.val}çš„ä¸¤ä¸ªå­èŠ‚ç‚¹éƒ½æ˜¯é»‘è‰²`,
                                detail: `å°†å…„å¼Ÿ${w.val}å˜çº¢ï¼Œç„¶åç»§ç»­å‘ä¸Šè°ƒæ•´çˆ¶èŠ‚ç‚¹ã€‚`,
                                highlightNodes: [w.val]
                            });
                            
                            w.color = RED;
                            x = xParent;
                            xParent = x.parent;
                            
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `å˜è‰²å®Œæˆï¼Œå‘ä¸Šè°ƒæ•´`,
                                detail: `å…„å¼ŸèŠ‚ç‚¹${w.val}å·²å˜çº¢ï¼Œç»§ç»­æ£€æŸ¥çˆ¶èŠ‚ç‚¹ã€‚`,
                                highlightNodes: [x ? x.val : -1]
                            });
                        } else {
                            if (!w.left || w.left.color === BLACK) {
                                animationSteps.push({
                                    tree: this.cloneTree(),
                                    description: `æƒ…å†µ3ï¼šå…„å¼ŸèŠ‚ç‚¹${w.val}çš„å·¦å­©å­æ˜¯é»‘è‰²ï¼Œå³å­©å­æ˜¯çº¢è‰²`,
                                    detail: `å°†å…„å¼Ÿçš„å³å­©å­${w.right.val}å˜é»‘ï¼Œå…„å¼Ÿ${w.val}å˜çº¢ï¼Œç„¶åå¯¹å…„å¼Ÿå·¦æ—‹ï¼Œè½¬æ¢ä¸ºæƒ…å†µ4ã€‚`,
                                    highlightNodes: [w.val, w.right.val]
                                });
                                
                                if (w.right) w.right.color = BLACK;
                                w.color = RED;
                                this.rotateLeft(w);
                                w = xParent.left;
                                
                                animationSteps.push({
                                    tree: this.cloneTree(),
                                    description: `å·¦æ—‹å®Œæˆï¼Œè½¬æ¢ä¸ºæƒ…å†µ4`,
                                    detail: `ç°åœ¨å…„å¼Ÿçš„å·¦å­©å­æ˜¯çº¢è‰²ï¼Œå¯ä»¥è¿›è¡Œæœ€åçš„è°ƒæ•´ã€‚`,
                                    highlightNodes: [w.val]
                                });
                            }
                            
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `æƒ…å†µ4ï¼šå…„å¼ŸèŠ‚ç‚¹${w.val}çš„å·¦å­©å­æ˜¯çº¢è‰²`,
                                detail: `å°†å…„å¼Ÿ${w.val}æŸ“æˆçˆ¶èŠ‚ç‚¹${xParent.val}çš„é¢œè‰²ï¼Œçˆ¶èŠ‚ç‚¹å˜é»‘ï¼Œå…„å¼Ÿçš„å·¦å­©å­å˜é»‘ï¼Œç„¶åå¯¹çˆ¶èŠ‚ç‚¹å³æ—‹ã€‚`,
                                highlightNodes: [w.val, xParent.val, w.left ? w.left.val : -1]
                            });
                            
                            w.color = xParent.color;
                            xParent.color = BLACK;
                            if (w.left) w.left.color = BLACK;
                            this.rotateRight(xParent);
                            x = this.root;
                            
                            animationSteps.push({
                                tree: this.cloneTree(),
                                description: `å³æ—‹å®Œæˆï¼Œåˆ é™¤è°ƒæ•´ç»“æŸ`,
                                detail: `æ‰€æœ‰çº¢é»‘æ ‘æ€§è´¨å·²æ¢å¤ï¼Œåˆ é™¤æ“ä½œå®Œæˆï¼`,
                                highlightNodes: []
                            });
                        }
                    }
                }
                
                if (x) {
                    x.color = BLACK;
                }
            }

            // æ‰¾åˆ°æœ€å°èŠ‚ç‚¹
            minimum(node) {
                while (node.left) {
                    node = node.left;
                }
                return node;
            }

            // ç§»æ¤èŠ‚ç‚¹
            transplant(u, v) {
                if (!u.parent) {
                    this.root = v;
                } else if (u === u.parent.left) {
                    u.parent.left = v;
                } else {
                    u.parent.right = v;
                }
                if (v) {
                    v.parent = u.parent;
                }
            }

            // æŸ¥æ‰¾èŠ‚ç‚¹
            findNode(val) {
                let current = this.root;
                while (current) {
                    if (val === current.val) return current;
                    if (val < current.val) current = current.left;
                    else current = current.right;
                }
                return null;
            }

            // åˆ é™¤æ“ä½œ
            delete(val) {
                animationSteps = [];
                
                const z = this.findNode(val);
                if (!z) {
                    animationSteps.push({
                        tree: this.cloneTree(),
                        description: `èŠ‚ç‚¹ ${val} ä¸å­˜åœ¨`,
                        detail: `æ ‘ä¸­æ²¡æœ‰æ‰¾åˆ°å€¼ä¸º ${val} çš„èŠ‚ç‚¹ï¼Œæ— æ³•åˆ é™¤ã€‚`,
                        highlightNodes: []
                    });
                    return false;
                }

                animationSteps.push({
                    tree: this.cloneTree(),
                    description: `å¼€å§‹åˆ é™¤èŠ‚ç‚¹ ${val}`,
                    detail: `æ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹${val}ï¼Œå‡†å¤‡è¿›è¡Œåˆ é™¤æ“ä½œã€‚`,
                    highlightNodes: [val]
                });

                let y = z;
                let yOriginalColor = y.color;
                let x, xParent;

                if (!z.left) {
                    animationSteps.push({
                        tree: this.cloneTree(),
                        description: `èŠ‚ç‚¹ ${val} æ²¡æœ‰å·¦å­æ ‘`,
                        detail: `ç›´æ¥ç”¨å³å­æ ‘æ›¿æ¢èŠ‚ç‚¹${val}ã€‚${yOriginalColor === BLACK ? 'âš ï¸ åˆ é™¤çš„æ˜¯é»‘è‰²èŠ‚ç‚¹ï¼Œå¯èƒ½ç ´åé»‘é«˜å¹³è¡¡ï¼Œéœ€è¦è°ƒæ•´ã€‚' : 'âœ“ åˆ é™¤çš„æ˜¯çº¢è‰²èŠ‚ç‚¹ï¼Œä¸å½±å“é»‘é«˜ã€‚'}`,
                        highlightNodes: [val, z.right ? z.right.val : -1]
                    });
                    
                    x = z.right;
                    xParent = z.parent;
                    this.transplant(z, z.right);
                    
                    animationSteps.push({
                        tree: this.cloneTree(),
                        description: `æ›¿æ¢å®Œæˆ`,
                        detail: `èŠ‚ç‚¹${val}å·²è¢«å…¶å³å­æ ‘æ›¿æ¢ã€‚${yOriginalColor === BLACK ? 'éœ€è¦è¿›è¡Œåˆ é™¤ä¿®å¤ã€‚' : 'åˆ é™¤å®Œæˆã€‚'}`,
                        highlightNodes: [x ? x.val : -1]
                    });
                } else if (!z.right) {
                    animationSteps.push({
                        tree: this.cloneTree(),
                        description: `èŠ‚ç‚¹ ${val} æ²¡æœ‰å³å­æ ‘`,
                        detail: `ç›´æ¥ç”¨å·¦å­æ ‘æ›¿æ¢èŠ‚ç‚¹${val}ã€‚${yOriginalColor === BLACK ? 'âš ï¸ åˆ é™¤çš„æ˜¯é»‘è‰²èŠ‚ç‚¹ï¼Œå¯èƒ½ç ´åé»‘é«˜å¹³è¡¡ï¼Œéœ€è¦è°ƒæ•´ã€‚' : 'âœ“ åˆ é™¤çš„æ˜¯çº¢è‰²èŠ‚ç‚¹ï¼Œä¸å½±å“é»‘é«˜ã€‚'}`,
                        highlightNodes: [val, z.left.val]
                    });
                    
                    x = z.left;
                    xParent = z.parent;
                    this.transplant(z, z.left);
                    
                    animationSteps.push({
                        tree: this.cloneTree(),
                        description: `æ›¿æ¢å®Œæˆ`,
                        detail: `èŠ‚ç‚¹${val}å·²è¢«å…¶å·¦å­æ ‘æ›¿æ¢ã€‚${yOriginalColor === BLACK ? 'éœ€è¦è¿›è¡Œåˆ é™¤ä¿®å¤ã€‚' : 'åˆ é™¤å®Œæˆã€‚'}`,
                        highlightNodes: [x.val]
                    });
                } else {
                    y = this.minimum(z.right);
                    yOriginalColor = y.color;
                    x = y.right;
                    
                    animationSteps.push({
                        tree: this.cloneTree(),
                        description: `èŠ‚ç‚¹ ${val} æœ‰ä¸¤ä¸ªå­æ ‘`,
                        detail: `æ‰¾åˆ°åç»§èŠ‚ç‚¹${y.val}ï¼ˆå³å­æ ‘ä¸­çš„æœ€å°èŠ‚ç‚¹ï¼‰æ¥æ›¿æ¢${val}ã€‚`,
                        highlightNodes: [val, y.val]
                    });

                    if (y.parent === z) {
                        xParent = y;
                    } else {
                        xParent = y.parent;
                        this.transplant(y, y.right);
                        y.right = z.right;
                        y.right.parent = y;
                        
                        animationSteps.push({
                            tree: this.cloneTree(),
                            description: `ç§»åŠ¨åç»§èŠ‚ç‚¹ ${y.val}`,
                            detail: `å°†åç»§èŠ‚ç‚¹${y.val}ä»åŸä½ç½®ç§»å‡ºã€‚`,
                            highlightNodes: [y.val]
                        });
                    }

                    this.transplant(z, y);
                    y.left = z.left;
                    y.left.parent = y;
                    y.color = z.color;
                    
                    animationSteps.push({
                        tree: this.cloneTree(),
                        description: `ç”¨åç»§èŠ‚ç‚¹ ${y.val} æ›¿æ¢ ${val}`,
                        detail: `åç»§èŠ‚ç‚¹${y.val}ç»§æ‰¿äº†è¢«åˆ é™¤èŠ‚ç‚¹${val}çš„é¢œè‰²${z.color === RED ? '(çº¢è‰²)' : '(é»‘è‰²)'}ã€‚${yOriginalColor === BLACK ? 'âš ï¸ åŸåç»§ä½ç½®æ˜¯é»‘è‰²ï¼Œéœ€è¦è°ƒæ•´ã€‚' : 'âœ“ åŸåç»§ä½ç½®æ˜¯çº¢è‰²ï¼Œä¸å½±å“é»‘é«˜ã€‚'}`,
                        highlightNodes: [y.val]
                    });
                }

                if (yOriginalColor === BLACK) {
                    this.deleteFix(x, xParent);
                }

                animationSteps.push({
                    tree: this.cloneTree(),
                    description: `åˆ é™¤å®Œæˆ`,
                    detail: `èŠ‚ç‚¹${val}å·²æˆåŠŸåˆ é™¤ï¼Œæ‰€æœ‰çº¢é»‘æ ‘æ€§è´¨å·²æ¢å¤ï¼`,
                    highlightNodes: []
                });

                return true;
            }

            // æ’å…¥æ“ä½œ
            insert(val) {
                animationSteps = [];
                const z = new Node(val);
                let y = null;
                let x = this.root;

                animationSteps.push({
                    tree: this.cloneTree(),
                    description: `å¼€å§‹æ’å…¥èŠ‚ç‚¹ ${val}`,
                    detail: `æŒ‰ç…§äºŒå‰æœç´¢æ ‘çš„è§„åˆ™æŸ¥æ‰¾æ’å…¥ä½ç½®ã€‚æ–°èŠ‚ç‚¹åˆå§‹é¢œè‰²ä¸ºçº¢è‰²ï¼ˆé€‰æ‹©çº¢è‰²æ˜¯å› ä¸ºè¿™æ ·è¿åçš„æ€§è´¨æ›´å°‘ï¼Œæ›´å®¹æ˜“ä¿®å¤ï¼‰ã€‚`,
                    highlightNodes: []
                });

                while (x) {
                    y = x;
                    if (z.val < x.val) x = x.left;
                    else x = x.right;
                }

                z.parent = y;
                if (!y) {
                    this.root = z;
                    animationSteps.push({
                        tree: this.cloneTree(),
                        description: `æ’å…¥æ ¹èŠ‚ç‚¹ ${val}`,
                        detail: `æ ‘ä¸ºç©ºï¼ŒèŠ‚ç‚¹${val}æˆä¸ºæ ¹èŠ‚ç‚¹ã€‚æ–°èŠ‚ç‚¹é»˜è®¤æ˜¯çº¢è‰²ã€‚`,
                        highlightNodes: [val]
                    });
                } else {
                    if (z.val < y.val) y.left = z;
                    else y.right = z;
                    
                    animationSteps.push({
                        tree: this.cloneTree(),
                        description: `å°†çº¢è‰²èŠ‚ç‚¹ ${val} æ’å…¥åˆ°èŠ‚ç‚¹ ${y.val} çš„${z.val < y.val ? 'å·¦' : 'å³'}è¾¹`,
                        detail: `æ‰¾åˆ°æ’å…¥ä½ç½®ï¼Œä½œä¸ºèŠ‚ç‚¹${y.val}çš„${z.val < y.val ? 'å·¦' : 'å³'}å­©å­ã€‚æ–°æ’å…¥çš„èŠ‚ç‚¹æ˜¯çº¢è‰²ã€‚${y.color === RED ? 'âš ï¸ çˆ¶èŠ‚ç‚¹ä¹Ÿæ˜¯çº¢è‰²ï¼Œè¿åäº†æ€§è´¨4ï¼Œéœ€è¦è°ƒæ•´ï¼' : 'âœ“ çˆ¶èŠ‚ç‚¹æ˜¯é»‘è‰²ï¼Œæš‚æ—¶ç¬¦åˆæ€§è´¨ã€‚'}`,
                        highlightNodes: [val, y.val]
                    });
                }

                this.insertFix(z);
            }

            getHeight(node) {
                if (!node) return 0;
                return 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
            }

            getBlackHeight(node) {
                if (!node) return 1;
                const leftHeight = this.getBlackHeight(node.left);
                return leftHeight + (node.color === BLACK ? 1 : 0);
            }

            getNodeCount(node) {
                if (!node) return 0;
                return 1 + this.getNodeCount(node.left) + this.getNodeCount(node.right);
            }
        }

        // å¯è§†åŒ–ç›¸å…³
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');
        let tree = new RBTree();

        const NODE_RADIUS = 25;
        const LEVEL_HEIGHT = 100;

        // é€Ÿåº¦æ§åˆ¶
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            animationSpeed = parseInt(e.target.value);
            document.getElementById('speedLabel').textContent = (animationSpeed / 1000).toFixed(1) + 's';
        });

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = Math.max(container.clientWidth - 80, 800);
            canvas.height = Math.max(600, tree.getHeight(tree.root) * LEVEL_HEIGHT + 100);
            drawTree(tree);
        }

        function calculateNodePositions(node, depth, leftBound, rightBound, positions) {
            if (!node) return;

            const x = (leftBound + rightBound) / 2;
            const y = depth * LEVEL_HEIGHT + 80;
            positions.set(node, { x, y });

            const mid = (leftBound + rightBound) / 2;
            calculateNodePositions(node.left, depth + 1, leftBound, mid, positions);
            calculateNodePositions(node.right, depth + 1, mid, rightBound, positions);
        }

        function drawTree(treeObj, highlightNodes = []) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!treeObj.root) return;

            const positions = new Map();
            calculateNodePositions(treeObj.root, 0, 0, canvas.width, positions);

            // ç»˜åˆ¶è¾¹
            function drawEdges(node) {
                if (!node) return;
                const pos = positions.get(node);

                if (node.left) {
                    const leftPos = positions.get(node.left);
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    ctx.lineTo(leftPos.x, leftPos.y);
                    ctx.strokeStyle = '#95a5a6';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    drawEdges(node.left);
                }

                if (node.right) {
                    const rightPos = positions.get(node.right);
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    ctx.lineTo(rightPos.x, rightPos.y);
                    ctx.strokeStyle = '#95a5a6';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    drawEdges(node.right);
                }
            }

            drawEdges(treeObj.root);

            // ç»˜åˆ¶èŠ‚ç‚¹
            function drawNodes(node) {
                if (!node) return;
                const pos = positions.get(node);
                const isHighlight = highlightNodes.includes(node.val);

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, NODE_RADIUS, 0, 2 * Math.PI);
                ctx.fillStyle = node.color === RED ? '#ff4757' : '#2f3542';
                ctx.fill();
                
                // çº¢è‰²èŠ‚ç‚¹ç”¨çº¢è‰²è¾¹æ¡†ï¼Œé»‘è‰²èŠ‚ç‚¹ç”¨é»‘è‰²è¾¹æ¡†
                ctx.strokeStyle = node.color === RED ? '#ff1744' : '#000';
                ctx.lineWidth = isHighlight ? 5 : 3;
                ctx.stroke();

                // é«˜äº®æ•ˆæœ
                if (isHighlight) {
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, NODE_RADIUS + 8, 0, 2 * Math.PI);
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.val, pos.x, pos.y);

                drawNodes(node.left);
                drawNodes(node.right);
            }

            drawNodes(treeObj.root);
            updateStats(treeObj);
        }

        function updateStats(treeObj) {
            const nodeCount = treeObj.getNodeCount(treeObj.root);
            const height = treeObj.getHeight(treeObj.root);
            const blackHeight = treeObj.getBlackHeight(treeObj.root);
            document.getElementById('treeStats').innerHTML = 
                `èŠ‚ç‚¹æ•°: ${nodeCount}<br>æ ‘é«˜: ${height}<br>é»‘é«˜: ${blackHeight}`;
        }

        function displaySteps() {
            const stepsContent = document.getElementById('stepsContent');
            stepsContent.innerHTML = '';

            animationSteps.forEach((step, index) => {
                const stepDiv = document.createElement('div');
                stepDiv.className = 'step-item';
                stepDiv.id = `step-${index}`;
                
                stepDiv.innerHTML = `
                    <div>
                        <span class="step-number">${index + 1}</span>
                        <span class="step-title">${step.description}</span>
                    </div>
                    <div class="step-description">${step.detail}</div>
                `;
                
                stepsContent.appendChild(stepDiv);
            });
        }

        async function animateSteps() {
            isAnimating = true;
            disableControls();

            for (let i = 0; i < animationSteps.length; i++) {
                const step = animationSteps[i];
                const stepDiv = document.getElementById(`step-${i}`);
                
                // é«˜äº®å½“å‰æ­¥éª¤
                document.querySelectorAll('.step-item').forEach(el => {
                    el.classList.remove('current', 'highlight');
                });
                stepDiv.classList.add('current', 'highlight');
                stepDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

                // ç»˜åˆ¶å½“å‰çŠ¶æ€çš„æ ‘
                const currentTree = step.tree;
                canvas.height = Math.max(600, currentTree.getHeight(currentTree.root) * LEVEL_HEIGHT + 100);
                drawTree(currentTree, step.highlightNodes);

                await sleep(animationSpeed);
            }

            // æœ€ç»ˆçŠ¶æ€
            tree = animationSteps[animationSteps.length - 1].tree;
            resizeCanvas();

            isAnimating = false;
            enableControls();
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function disableControls() {
            document.getElementById('insertBtn').disabled = true;
            document.getElementById('deleteBtn').disabled = true;
            document.getElementById('clearBtn').disabled = true;
            document.getElementById('randomBtn').disabled = true;
            document.querySelectorAll('.preset-btn').forEach(btn => btn.disabled = true);
        }

        function enableControls() {
            document.getElementById('insertBtn').disabled = false;
            document.getElementById('deleteBtn').disabled = false;
            document.getElementById('clearBtn').disabled = false;
            document.getElementById('randomBtn').disabled = false;
            document.querySelectorAll('.preset-btn').forEach(btn => btn.disabled = false);
        }

        function showMessage(text, type = 'success') {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.className = `message ${type}`;
            msg.style.display = 'block';
            setTimeout(() => msg.style.display = 'none', 2000);
        }

        async function insertValue() {
            if (isAnimating) return;

            const input = document.getElementById('valueInput');
            const val = parseInt(input.value);

            if (isNaN(val) || val < 1 || val > 999) {
                showMessage('è¯·è¾“å…¥1-999ä¹‹é—´çš„æ•°å€¼', 'error');
                return;
            }

            tree.insert(val);
            displaySteps();
            input.value = '';
            
            await animateSteps();
            showMessage(`æˆåŠŸæ’å…¥èŠ‚ç‚¹ ${val}`);
        }

        async function deleteValue() {
            if (isAnimating) return;

            const input = document.getElementById('valueInput');
            const val = parseInt(input.value);

            if (isNaN(val) || val < 1 || val > 999) {
                showMessage('è¯·è¾“å…¥1-999ä¹‹é—´çš„æ•°å€¼', 'error');
                return;
            }

            const success = tree.delete(val);
            displaySteps();
            input.value = '';
            
            await animateSteps();
            
            if (success) {
                showMessage(`æˆåŠŸåˆ é™¤èŠ‚ç‚¹ ${val}`);
            } else {
                showMessage(`èŠ‚ç‚¹ ${val} ä¸å­˜åœ¨`, 'error');
            }
        }

        function clearTree() {
            if (isAnimating) return;
            tree = new RBTree();
            animationSteps = [];
            resizeCanvas();
            document.getElementById('stepsContent').innerHTML = `
                <div style="text-align: center; color: #6c757d; padding: 40px 20px;">
                    <p style="font-size: 1.2em; margin-bottom: 15px;">ğŸ‘‹ æ¬¢è¿ä½¿ç”¨çº¢é»‘æ ‘å¯è§†åŒ–å·¥å…·</p>
                    <p>ğŸ‘ˆ è¾“å…¥æ•°å€¼ï¼Œå¯ä»¥æ’å…¥æˆ–åˆ é™¤èŠ‚ç‚¹</p>
                    <p style="margin-top: 10px;">æˆ–ä½¿ç”¨é¢„è®¾ç¤ºä¾‹å¿«é€Ÿå¼€å§‹</p>
                    <p style="margin-top: 10px;">è¿™é‡Œä¼šæ˜¾ç¤ºæ¯ä¸€æ­¥çš„è¯¦ç»†æ“ä½œè¯´æ˜</p>
                </div>
            `;
            showMessage('æ ‘å·²æ¸…ç©º');
        }

        async function randomTree() {
            if (isAnimating) return;
            
            tree = new RBTree();
            const count = 5 + Math.floor(Math.random() * 5);
            const values = new Set();
            
            while (values.size < count) {
                values.add(Math.floor(Math.random() * 100) + 1);
            }

            showMessage(`å¼€å§‹ç”ŸæˆåŒ…å« ${count} ä¸ªèŠ‚ç‚¹çš„éšæœºæ ‘`);
            
            for (const v of values) {
                tree.insert(v);
                displaySteps();
                await animateSteps();
                await sleep(500);
            }
            
            showMessage(`æˆåŠŸç”ŸæˆåŒ…å« ${count} ä¸ªèŠ‚ç‚¹çš„éšæœºæ ‘`);
        }

        async function loadPreset(values) {
            if (isAnimating) return;
            
            tree = new RBTree();
            showMessage(`å¼€å§‹åŠ è½½é¢„è®¾: [${values.join(', ')}]`);
            
            for (const v of values) {
                tree.insert(v);
                displaySteps();
                await animateSteps();
                await sleep(500);
            }
            
            showMessage(`é¢„è®¾åŠ è½½å®Œæˆ`);
        }

        // é”®ç›˜äº‹ä»¶
        document.getElementById('valueInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !isAnimating) insertValue();
        });

        // åˆå§‹åŒ–
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    </script>
</body>
</html>