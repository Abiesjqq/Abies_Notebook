## AVL 树

树的高度：根节点到最远的叶节点的距离（边数）

平衡二叉树：二叉搜索树+所有节点|左子树高度-右子树高度|<=1（平衡因子<=1）  
查找、插入、删除和不同二叉搜索树相同，只是每次再检查是否平衡

### 查找/插入

左旋：向左旋转，冲突的左孩变右孩  
右旋：向右旋转，冲突的右孩变左孩

**什么时候、什么节点左旋/右旋？**

LL 型（失衡节点 2，失衡节点左孩子 1）：失衡节点右旋  
RR 型（失衡节点-2，失衡节点右孩子-1）：失衡节点左旋  
LR 型（失衡节点 2，失衡节点左孩子-1）：左孩子左旋，失衡节点右旋  
RL 型（失衡节点-2，失衡节点右孩子-1）：右孩子右旋，失衡节点左旋

**怎么判断是哪种情况？**

检查插入的节点在失衡节点的哪个孩子的哪个子树上。  
或分别看失衡节点、左右孩子的平衡节点。

若同时有多个祖先失衡，只要调整距离最近的失衡节点。

### 删除

删除操作和普通二叉搜索树相同，用左子树或右子树最接近的节点替换，检查平衡。  
需要依次对每个祖先、从下到上检查，如果失衡可能需要调整多次。

!!! normal-comment "给定树高 h，AVL 树至少有几个节点？"

    “树高”定义为根节点到当前节点的路径长度。空的数高度为-1，只有根节点的树高度为 0。
    记$N(h)$为高度 h 的 AVL 树的最小节点数。

    由于希望总节点数最少，平衡因子尽量为$\pm 1$，即左右子树的高度一个为$h$、一个为$h-1$。因此$N(h)=N(h-1)+N(h-2)+1$。

    初始条件：$N(-1)=0$，$N(0)=1$

    斐波那契数列：$F_1=1, F_2=2, F_3=3, F_4=5\cdots F_n=F_{n-1}+F_{n-2}$

    递推结果：$N(h)=F_{h+2}-1$

    由于$F_n\approx\phi^n / \sqrt{5}$，其中$\phi\approx 1.618$，$N(h)\approx\phi^{h+2}-1$，为指数级别。

    故如果 AVL 树有 n 个节点，则树高为$O(\log n)$级别。

!!! normal-comment "给定树高 h，AVL 树至多有几个节点？"

    记$M(h)$为高度 h 的 AVL 树的最小节点数。

    为了使节点数最多，树应该尽量饱满，左右子树的树高都为$h-1$。

    递推关系：$M(h)=2M(h-1)+1$；初始条件：$M(-1)=0$，$M(0)=1$

    递推结果：$M(h)=2^{h}-1$

## 伸展树（Splay Tree）

伸展树是一种自平衡的 BST，它的核心原理是在每次访问节点时，将该节点通过旋转操作“伸展”到根节点。

通过这种方式，伸展树能在一定程度上优化频繁访问节点的查询效率（不仅推到根部，还将树高变成约一半）。

### 访问节点

每次对节点进行查找、插入或删除时，通过旋转将该节点提升到根部

**旋转的操作：**

当前节点、父亲、爷爷为 LR 或 RL 型：旋转操作和 AVL 树相同，称为 zig-zag（两次旋转方向相反）  
当前节点、父亲、爷爷为 LL 或 RR 型：先旋转爷爷、再旋转父亲，和 AVL 树相比多一次父亲的旋转，称为 zig-zig（两次旋转方向相同）  
esp. 当前节点为根节点的儿子时，只进行一次旋转，称为 zig

AVL 树和 Splay 树在 LL 型、RR 型旋转的区别：

![AVL vs Splay](./ADSresources/AVL%20vs%20Splay.png){style="width:500px"}

### 查找、插入、删除

- 查询：根据 BST 找到要查询的点，旋转到根部
- 插入：根据 BST 找到要插入的点，插入，并旋转到根部
- 删除：先找到要删除的节点、旋转到根部，删除根节点，合并左右子树（将右子树中最小的或左子树中最大的 splay 到根部，连接剩余子树）

## 摊还分析

分析最大时间复杂度时，如果用所有操作中的最坏情况\*操作次数，会带来大量冗余的时间代价，导致估计的 TC 远大于实际值。

摊还分析相当于将代价大的步骤分摊到代价小的步骤，得到更接近实际的结果。

摊还分析分为**聚合法、核法、势能法**三种。

聚合法：平均代价 = 总代价 / 操作次数

核法：定义基准代价，每次多的记为负、少的记为正，要维持账户总数值大于零

势能法：定义关于状态的势能函数，对于代价大的操作，用势能的下降抵消操作的代价

详见这两篇文章：

- [聚合法、核法](https://zh.wikipedia.org/wiki/%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90)

- [势能法](https://www.yuque.com/xianyuxuan/saltfish_shop/weekly002_amortized_analysis#KmnY6)

**push, pop, multipop**

操作代价$\Phi_1$，势函数$\Phi_2=\text{height of stack}$

$$\Phi_1 +\Phi_2=2n\,,\, \Phi_2(n)<n$$

$$|\Phi_1|=|(\Phi_1 + \Phi_2)-\Phi_2|\le|\Phi_1 +\Phi_2|+|\Phi_2|=3n$$

### Splay 树的摊还分析

n 节点的伸展树，连续 M 次搜索需要 $O(M\log n+n\log n)$ 时间。

$$\lim _{M\to\infty}\frac{M\log n+n\log n}{M}=\log n$$

- $\Phi_1$：每次旋转次数
- $\Phi_2$：$Rank(z)=\log_2(\text{decendents of z})\, ,\, \Phi_2=\displaystyle\sum_{z\in \text{Tree}}Rank(z)$

**引理：**

Splay(x)时，每一步操作有：

$$\text{steps}+\Delta\Phi_2\le 3(Rank'(x)-Rank(x))+1$$

$$Rank'(x)=\log_2 n$$

<!-- ??? normal-comment "引理证明" -->

**证明：**

对每一步求和：

$$\sum\text{steps}+\Phi_2(T_M)-\Phi_2(T_0)\le 3\log_2 n+1$$

## 红黑树

### 红黑树性质

1. 节点为红色或黑色
2. 根节点为黑色，NIL 节点（空叶子节点）为黑色
3. 红色节点的子节点为黑色
4. 从根节点到 NIL 节点的每条路径上的黑色节点数量相同

合法红黑树的红色节点的两个子节点一定都是叶子或都不是叶子。

从根到叶节点的路径，最长路径最多是最短路径的两倍。

有 N 个内部节点的红黑树，树高最大为$2\log_2(N+1)$

??? normal-comment "证明"

    bh表示黑高，h表示树高

    $N\ge 2^{bh}-1$, 即 $bh\le\log_2(N+1)$

    $h\le 2\, bh=2\log_2(N+1)$

??? examples "一道选择题"

    If we insert N(N⩾2) nodes (with different integer elements) consecutively to build a red-black tree T from an empty tree, which of the following situations is possible:

    A. All nodes in T are black
    B. The number of leaf nodes (NIL) in T is 2N−1
    C. 2N rotations occurred during the construction of T
    D. The height of T is ⌈3log2(N+1)⌉ (assume the height of the empty tree is 0)

    A：可能？

    B：不可能。二叉树有 N 个内部节点，则有 N+1 个 NIL。
    设内部节点 N 个，NIL 共 L 个。则总出度为 2N，总边数为 N+L-1，总出度=总边数，故 L=N+1。

    C：不可能。每次插入节点最多旋转两次，而根节点和第二个插入的不用旋转。

    D：不可能。最大高度为$2\log_2(N+1)$。

### 插入

插入节点默认为红色。

1. 插入节点是根节点：直接变黑
2. father 为红色，uncle 为红色：uncle, father, grandfather 变色，将 grandfather 作为插入节点重新判断
3. father 为红色，uncle 为黑色：（LL, RR, LR, RL）旋转，再变色

### 删除

??? remarks "二叉搜索树的删除"

    1. 叶节点：直接删除
    2. 只有一个孩子：直接用孩子代替
    3. 有两个孩子：找到左子树中最大的或右子树中最小的，代替删除节点，继续删除这个节点

红黑树删除：先按二叉搜索树方法删除，再调整。  
第三种一定会转化为前两种，只讨论前两种情况。

只有一个孩子：一定是当前黑，唯一的孩子红，且孩子为叶节点。  
直接用孩子红节点代替，再将代替后的节点变黑

没有孩子，且删除红节点：直接删除

没有孩子，且删除黑节点：  
认为删除后替换的 NIL 为“双黑节点”

1. 兄弟是黑色：
   1. 兄弟至少有一个红色孩子：根据父亲 p、兄弟 s、兄弟红孩子 r 关系（LL,RR,LR,RL）变色+旋转，双黑恢复为单黑
      1. LL 型和 RR 型：r 变 s，s 变 p，p 变黑
      2. LR 型和 RL 型：r 变 p，p 变黑
   2. 兄弟的孩子都是黑色：兄弟变红，双黑上移到父节点
      1. 父节点为红：直接将父节点变黑
      2. 父节点为黑：双黑上移到父节点，对父节点重复操作
      3. 父节点为根节点：双黑上移后碰到根节点，直接变成单黑
2. 兄弟是红色：
   兄父变色，父亲朝双黑节点旋转，保持双黑继续调整

_文字已经讲不清楚了，看图吧_

![RBTree insertion](./ADSresources/RBTree%20insertion.png)

<!-- ![RBTree deletion](./ADSresources/RBTree%20deletion.png) -->

## B 树

### B 树性质

AVL 树、红黑树都将数据存到内存。当数据量大到内存存不下时，需要将数据存到硬盘，再分批从硬盘读到内存。  
（硬盘：CPU 不能直接和硬盘交互，硬盘读取物理地址连续的多个字节和读取单个字节的耗时几乎没有区别。）

硬盘访问时间长，尽可能减少硬盘的访问次数。而对于 AVL 树和红黑树，每往下找一层都要访问硬盘，硬盘访问次数和树高正相关。  
B 树是多叉平衡搜索树，降低树高。

- 内部节点：包含数据的节点
- 外部节点：表示查找失败，这里省略
- 叶节点：这里将最后一层内部节点称为叶节点

1. 平衡：叶节点都在同一层
2. 有序：任何节点内都从小到大，左子树<元素<右子树
3. 多路：对于 m 阶 B 树，每个节点最多有 m 个分支、m-1 个元素

根节点最少 2 个分支、1 个元素（除非只有根节点）  
其他节点最少$\lceil\frac{m}{2}\rceil$个节点，$\lceil\frac{m}{2}\rceil-1$个元素

### 查找、插入

**查找**：在节点内依次比较（顺序查找为例，更大就向右比较，更小就向下到子树）

**插入**：插入在叶节点。如果上溢出（节点内的元素超出），以第$\lceil\frac{m}{2}\rceil$个元素分割，将这个元素上移到父节点，两边分裂。如果父节点上溢出，递归调整。

### 删除

插入会上溢出，而删除会下溢出（节点内的元素个数过少）

查找要删除的节点，如果非叶节点，转化为直接前驱或直接后继替换，再删除替换的节点。

如果出现下溢出，首先用左右兄弟补全。先将父亲节点对应元素下移，再将兄弟节点中的元素上移。如果兄弟有子树，要将子树也移动到补全的节点。

如果左右兄弟都不够补全，将节点和其中一个兄弟合并。先将父亲节点对应元素下移，再将要合并的元素合并，删除父亲中空节点和空子树。  
要检查父亲节点是否也下溢出，递归调整。

## B+树

### B+树性质

在 B 树中按顺序遍历节点，需要中序遍历来回移动。而 B+树中可以直接遍历叶节点。

B+树的叶节点层包含所有元素，从小到大链接起来。  
B+树常用于数据库中的索引结构，每个元素都包含指向记录存储地址的指针，此时节点内的元素又被称为关键字。通过关键字中的指针，可以索引到数据库中的某一条记录。  
B+树本身也作为索引文件存储在硬盘中。

- B+树节点内元素个数和分支数相同，每个元素对应子节点的最大值。非叶节点是对下一层节点的索引。
- 其他性质与 B 树相同。节点最少 2 个分支、1 个元素（除非只有根节点）；其他节点最少$\lceil\frac{m}{2}\rceil$个节点，$\lceil\frac{m}{2}\rceil-1$个元素

!!! normal-comment "B+树和B树的区别"

B树中m个分支的节点内有m-1个元素，而B+树中m个分支的节点内有m个元素

B 树中每个节点都包含指向相应记录的指针，而 B+树中只有叶节点包含指向相应记录的指针，非叶节点只作为查找叶节点的多级索引。

B树只有根节点一个头指针。B+树有两个头指针，即能通过叶节点链表的头指针顺序查找，也能通过根节点的指针随机查找。

### 查找

顺序查找：直接在叶节点链表上查找  

随机查找：从根节点开始查找，直到叶节点。在节点内依次比较（顺序查找为例，大于就向右比较，小于等于就向下到子树）

范围查找：e.g. 查找范围为[A,B]的节点。先随机查找到左边界，在顺序遍历直到右边界。


