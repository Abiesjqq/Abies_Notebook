## 困难问题（Hard Problem）

**Partition Problem**：给定一个数集 $S$，问能否把它划分成两个子集 $S_1, S_2$，使得 $\sum_{x \in S_1}x = \sum_{x \in S_2}x$。这是一个 NP-hard 问题（证明略）。

“Homework ++” 问题：给定一组任务，每个任务有释放时间 $r_i$、执行时间 $s_i$ 和截止时间 $d_i$，要求安排它们的执行顺序使得所有任务都在各自截止时间前完成。

!!! remarks "证明 Homework ++ 比 partition 更难"
    对给定的 partition 输入 $\{a_1, \ldots, a_n\}$，令 $w = \sum a_i$。  
    构造 $n + 1$ 个作业：前 $n$ 个对应 $a_1, \ldots, a_n$，每个作业释放时间为 $0$，DDL 为 $w + 1$，执行时间为 $a_i$。  
    最后一个作业的释放时间为 $w / 2$，DDL 为 $w / 2 + 1$，执行时间为 $1$，因此它必须在时间 $w / 2$ 开始执行。  
    于是，剩余任务是否能被恰好安排在 $[0, w / 2)$ 与 $(w / 2, w]$ 两段时间内，就等价于一个 partition 问题。

## 最小生成树（Minimum Spanning Tree, MST）

定义和基本算法在离散数学课程中已经介绍过，这里略去证明。

下面的算法都适用于无向图（undirected graphs）。

### Prim 算法

每次往生成树中加入一个新的顶点。更具体地，从任意一个起点出发，每一步把当前树外、到树的边权最小的顶点加入树中。

```
# Initialize
T = {}, S = {}
cost[r] = 0, cost[v] = inf for v other than r
for r's neighbour v: cost[v] = w(r, v), pre[v] = r

# Recurse
while:
    find v not in S with smallest cost[v]
    S = S + {v}, T = T + {(pre[v], v)}
    
    # update
    for v's neighbour u:
        cost[u] = min(cost[u], w(u, v))
        if cost[u] was updated, pre[u] = v
```

若结合 Fibonacci 堆来维护最小边，可以做到时间复杂度 $O(\vert E \vert + \vert V \vert \log \vert V \vert)$。

### Kruskal 算法

Kruskal 的思路是每次往生成树中加入一条边：先按权值从小到大排序所有边，然后依次扫描，遇到不会产生环的边就加入生成树。

为了高效判断“加上这条边是否产生环”，可以使用 **并查集（union-find）**。

```
sort(E, ascending)

for each u, create a group containing only u

for each (u, v) in E with ascending order:
    if root(u) ≠ root(v):
        add (u, v) into the MST
        union(u, v)
```

!!! remarks "Union-Find 的复杂度"
    初始化（Create）：$O(1)$  
    Find：$O(\log n)$  
    Union：$O(1)$

    因此对 Kruskal 算法：  
    排序：$O(\vert E \vert \log \vert E \vert)$  
    初始化与合并：$O(\vert V \vert)$  
    Find：$O(\vert E \vert)$  

    !!! normal-comment "为什么 Find 是 $O(\log n)$？"
        在每次合并时记录并维护树的高度，在 Union 时总是把矮树挂到高树上。  
        这样一棵高度为 $k$ 的树（`rank[i]`）至少需要 $2^k$ 个节点，因此树高为 $O(\log n)$。这就是按秩合并（union by rank）。

    !!! remarks "配合路径压缩（path compression）的优化"

        用摊还分析可以证明：  
        $m$ 次 FIND 操作的总时间为 $O(m \log^* n + n \log^* m)$。

        在每一次 FIND 过程中，我们会把路径上部分边“压缩”（把中间节点直接挂到根上），这些被压缩掉的边称为被 **cut** 的边；直接连到根上的边视为 **uncut**。  
        可以看到，所有 FIND 经由 uncut 边的访问总成本为 $O(m)$。

        FIND 与路径压缩不会改变 `rank[v]`，因此 `rank[v]` 不再等于以 $v$ 为根的子树高度，但仍然满足：  
        - 父节点的 rank 严格大于子节点的 rank；  
        - rank 单调不减；  
        - rank 只会在根节点上增加。  
    
        在分析时，我们按 rank 将所有节点分组：
    
        $$
        \begin{cases}
        g_i &= \{v_i\ |\ \mathrm{rank}[v_i] \in [k_i + 1, 2^{k_i}] \} \\
        k_{i + 1} &= 2^{k_i}
        \end{cases}
        $$
    
        因此可以把 $n$ 个节点划分成大约 $\log^* n$ 组。
        
        我们把 FIND 的代价分成两类：  
        - **Same Group Charging (SGC)**：从同一 rank 组的父节点处被 cut 的情况；  
        - **Across Group Charging (AGC)**：从不同 rank 组的父节点处被 cut 的情况。  
    
        **AGC：**  
        在一次 FIND 中，最多会发生 $\log^* n$ 次 AGC，因此 $m$ 次 FIND 的总 AGC 成本为 $m \log^* n$。
        
        **SGC：**  
        对于某个 rank 落在区间 $[k_i + 1, 2^{k_i}]$ 内的节点 $v$，每发生一次 SGC，它父亲的 rank 都会严格上升；因此该节点最多经历 $2^{k_i} - (k_i + 1) < 2^{k_i}$ 次 SGC。  
        另一方面，该组中节点个数最多为 $n / 2^{k_i}$（构造一棵 rank 为 $k_i$ 的树至少需要 $2^{k_i}$ 个节点）。  
        因此这一组中所有节点一共最多发生 $n / 2^{k_i} \cdot 2^{k_i}$ 次 SGC。  
        对全部 $\log^* n$ 组求和，$m$ 次 FIND 的 SGC 总成本为 $n \log^* n$。
        
        综合起来，总时间为 $m + m \log^* n + n \log^* n$（对应 uncut + AGC + SGC）。  
        当 $m \to \infty$ 时，复杂度可以写成 $O(m \log^* n)$。


!!! remarks "Matroid 定理与独立集（Independent set）"

    考虑一个二元组 $M=(U,\mathcal{I})$，其中 $U$ 是有限集，$\mathcal{I}\subseteq \{0,1\}^U$ 是 $U$ 的子集族。若满足：  
    1. **Hereditary property**：$\mathcal{I}$ 非空，并且对任意 $A\in\mathcal{I}$ 和 $B\subseteq A$，都有 $B\in\mathcal{I}$；  
    2. **Exchange property**：对任意 $A,B\in\mathcal{I}$ 且 $|A|<|B|$，存在 $x\in B\setminus A$ 使得 $A\cup\{x\}\in\mathcal{I}$；  
    就称 $M$ 为一个 *matroid*。其中每个 $A\in\mathcal{I}$ 称为一个 *independent set*。

    可以证明：**所有极大独立集的大小都相同。**（这里极大指的是不存在 $B\in\mathcal{I}$ 使得 $A\subsetneq B$。）

    !!! examples "MST 作为 Matroid 的例子"

        设 $G=(V,E)$ 是一张简单无向图。令 $M=(E,\mathcal{S})$，其中
        
        $$
        \mathcal{S}=\{F\subseteq E\mid F\text{ 不含任何环}\}
        $$
        
        则 $M$ 是一个 matroid：所有无环子图都是独立集（independent set），而所有极大独立集都是生成森林（spanning forests）。

    因此，对带非负权的 matroid，可以用 Kruskal 式的贪心找到**最大权极大独立集**：

    ```text
    S ← ∅
    Sort U in decreasing order by weight w

    for x ∈ U (in decreasing order of w) do
        if S ∪ {x} ∈ 𝓘 then
            S ← S ∪ {x}
        end if
    end for

    return S
    ```

    **证明**：$S$ 显然是一个极大独立集。  
    假设 $S = \{s_1, \ldots, s_n\}$，存在另一极大独立集 $O = \{o_1, \ldots, o_n\}$ 的总权值更大。令
    
    $$
    k = \min_{\substack{l = 1, \ldots, n \\ s_l \neq o_l}}l
    $$
    
    （这样的 $k$ 一定存在）。记 $S_{k - 1} = \{s_1, \ldots, s_{k - 1}\}$，$O_{k} = \{o_1, \ldots, o_k\}$。  
    由 exchange property，存在某个 $o_p \in O_k \setminus S_{k - 1}$（$p \geq k$），使得 $S_{k - 1} \cup \{o_p\} \in \mathcal{I}$。  
    又由于按权值递减排序，有 $w(o_p) \geq w(o_k) > w(s_k)$。  
    但在算法执行到加入 $s_k$ 的那一步时，我们本应优先加入权值更大的 $o_p$，与贪心选择顺序矛盾。  
    因此算法输出的 $S$ 一定是最大权值的极大独立集。

## 基于贪心的近似算法（Greedy-Based Approximation Algorithms）

对于某些难题，贪心算法虽无法给出精确解，但可以得到具有保证的近似解。

对一个最小化问题及其算法 $\mathcal{A}$，记 $\mathcal{A}(I)$ 为算法在输入 $I$ 上的输出值，$\mathrm{OPT}(I)$ 为最优解的值。若

$$
\forall I:\quad \frac{\mathcal{A}(I)}{\mathrm{OPT}(I)} \le \alpha
$$

则称 $\mathcal{A}$ 是一个 **$\alpha$-approximation algorithm**。  

对最大化问题，若

$$
\forall I:\quad \frac{\mathcal{A}(I)}{\mathrm{OPT}(I)} \ge \alpha
$$

则同样称 $\mathcal{A}$ 为 $\alpha$-approximation algorithm。

### Max-k-coverage 与 Set Cover 问题

设 $U = \langle n \rangle$ 为底集，$T = \{A_1, \ldots, A_m\}$ 为 $U$ 的子集族，且满足 $\bigcup_{A_i \in T}A_i = U$。

- **Set Cover**：寻找子集族 $S \subseteq T$，使得 $\bigcup_{A_i \in S}A_i = U$ 且 $\vert S \vert$ 最小；  
- **Max-k-coverage**：给定整数 $k$，寻找 $S \subseteq T$，满足 $\vert S \vert \leq k$ 且覆盖的元素数 $\left\vert \bigcup_{A_i \in S}A_i \right\vert$ 最大。

（这两个问题都是 NP-Hard 的。）

!!! normal-comment "可以用二分图直观地表示“集合–元素”的关系"

定义

$$
f(S) = \left\vert \bigcup_{A_i \in S}A_i \right\vert
$$

一个自然的贪心算法是：

```
Initialize S = ∅
repeat:
    find A ∈ T \ S that maximizes f(S ∪ {A}) - f(S)
    update S = S ∪ {A}
until:
    f(S) = |U| (for set cover)
    |S| = k    (for max-k-coverage)
```

!!! remarks "近似比分析"

    设 $S^* = \{O_1, \ldots, O_k\}$ 是任意一个由 $k$ 个子集组成的集合（可以看作 Max-k-coverage 的最优解），$S = \{A_1, \ldots, A_l\}$ 为算法执行 $l$ 轮后的输出。将证明
    
    $$
    f(S) \geq \left(1 - \left(1 - \frac{1}{k}\right)^l\right)f(S^*) \geq \left(1 - \frac{1}{\mathrm{e}}\right) f(S^*)
    $$
    
    这给出了 Max-k-coverage 的近似下界。  
    对于 Set Cover，若 $\vert S^* \vert = k$ 且取 $l = k\ln n$，则有
    
    $$
    f(S) \geq \left(1 - \left(1 - \frac{1}{k}\right)^{k \ln n}\right)f(S^*) > \left(1 - \frac{1}{\mathrm{e^{\ln n}}}\right) f(S^*) = n - 1 \Rightarrow f(S) = n
    $$
    
    因此可以得到一个 $\ln n$ 近似。
    
    证明思路是归纳：令 $S_t = \{A_1, \ldots, A_t\}, t = 1, 2, \ldots, l$。  
    - 当 $t = 1$ 时，由贪心选择可知，$f(S_1 = \{A_1\}) \geq f(O_i)$ 对所有 $O_i$ 成立，因此
    
    $$
    f(S_1) \geq \frac{1}{k}\sum_{i = 1}^{k}f\left(\{O_i\}\right) \geq \frac{1}{k}f(S^*) = \left(1 - \left(1 - \frac{1}{k}\right)^{1}\right)f(S^*)
    $$
    
    - 一般地，假设 $S_t$ 已经选好，定义增量
    
    $$
    \Delta(O_i\vert S_t) = f(S_t \cup \{O_i\}) - f(S_t)
    $$
    
    由贪心性，有 $\Delta(A_{t + 1}\vert S_t) \geq \Delta(O_i\vert S_t)$。并且
    
    $$
    \begin{align}
    &\Delta(A_{t + 1}\vert S_t) \geq \frac{1}{k}\sum_{i = 1}^{k}\Delta(O_i\vert S_t) \geq \frac{1}{k}\Delta(S^*\vert S_t) \\
    \Leftrightarrow& f(S_{t + 1}) - f(S_t) \geq \frac{1}{k}\left(f(S^* \cup S_t) - f(S_t)\right) \geq \frac{1}{k}\left(f(S^*) - f(S_t)\right) \\
    \Leftrightarrow& f(S_{t + 1}) \geq \frac{1}{k}f(S^*) + \left(1 - \frac{1}{k}\right)f(S_t)  \\ &= \left(1 - \left(1 - \frac{1}{k}\right)^{t + 1}\right)f(S^*)
    \end{align}
    $$

!!! remarks "多项式时间里我们还能做得更好吗？"
    上面的不等式都是紧的（从量级上看）。  
    实际上，除非 **P = NP**，否则不存在任何 $\displaystyle 1 - \frac{1}{\mathrm{e}} + \varepsilon$ 近似的多项式时间算法。

### 设施选址问题（Facility Location）

#### $k$-centers

在图上开设 $k$ 个设施，使任意顶点到其最近设施的距离尽量小（通常考虑在满足三角不等式的度量空间中，例如具有三角不等式的无向图）。

输入：一个度量空间（通常是一张满足三角不等式的无向图）和整数 $k$。  
输出：大小为 $k$ 的集合 $S \subseteq V$，使得

$$
f(S) = \max_{v \in V} \min_{s \in S} d(s, v)
$$

最小。

可以用简单的贪心得到一个 2-近似：每一步选取当前离已选中心最远的点作为新的中心。

!!! remarks "2-近似的分析"
    设最优解为 $O = \{o_1, \ldots, o_k\}$，其代价为 $\mathrm{OPT}$；  
    算法输出为 $A = \{a_1, \ldots, a_k\}$，其代价为 $\mathrm{ALG}$；  
    要证明 $\mathrm{ALG} \leq 2 \cdot \mathrm{OPT}$。
    
    对每个 $o_i$，令 $X_i$ 为距离 $o_i$ 最近的顶点集合（即按到 $o_i$ 的距离划分的 Voronoi 区），$\{X_1, \ldots, X_k\}$ 构成对 $V$ 的划分。  
    记 $d(A, v) = \min_{a \in A}d(a, v)$。
    
    **情形 1：** 对所有 $i$ 都有 $A \cap X_i \neq \emptyset$。  
    那么每个 $X_i$ 中都至少包含一个算法选出的中心。WLOG，假设 $a_i \in X_i$。
    
    对任意 $v \in V$，若 $v \in X_i$，则
    
    $$
    d(a_i, v) \leq d(a_i, o_i) + d(o_i, v) \leq 2 \cdot \mathrm{OPT}.
    $$
    
    在算法中，$v$ 实际被分配给某个 $a'$，于是 $d(a', v) \leq d(a_i, v) \leq 2 \cdot \mathrm{OPT}$，故
    
    $$
    \mathrm{ALG} = \max_{v \in V}d(a', v) \leq 2 \cdot \mathrm{OPT}.
    $$
    
    **情形 2：** 存在某个 $i$ 使得 $A \cap X_i = \emptyset$。  

    这意味着某个 $X_j$ 中包含了两个被算法选作中心的点。设 $a_j, a_r \in X_i$，且 $a_j$ 先于 $a_r$ 被选中。  
    当算法选取 $a_r$ 时，有
    
    $$
    \mathrm{ALG} \leq d(A, a_r) \leq d(a_j, a_r).
    $$
    
    又因为 $a_j, a_r \in X_i$，故
    
    $$
    d(a_j, a_r) \leq d(a_j, o_i) + d(a_r, o_i) \leq 2 \cdot \mathrm{OPT},
    $$
    
    因此同样有 $\mathrm{ALG} \leq 2 \cdot \mathrm{OPT}$。

    !!! normal-comment "什么时候能达到等号？"
        当 $V$ 在一条直线上且 $k = 2$ 时，如果算法选取的是“中点 + 端点”，则代价约为 $\vert V \vert / 2$；  
        而最优方案是选择两个四分点，此时代价约为 $\vert V \vert / 4$。

事实上，不存在任何 $(2 - \varepsilon)$ 近似的多项式时间算法。

!!! remarks "支配集（Dominating Set）问题"
    对给定无向图 $G = (V, E)$，若 $S \subseteq V$ 满足：对任意 $v \in V \backslash S$，存在某个 $u \in S$ 与 $v$ 相邻，则称 $S$ 为一个 dominating set。  

    **Dominating Set Problem**：给定图 $G$ 和整数 $k$，判断 $G$ 是否存在大小为 $k$ 的 dominating set。该问题是已知的 NP-Hard 问题。

!!! normal-comment "证明不存在 $(2 - \varepsilon)$ 近似的多项式时间算法"
    假设存在这样一个算法，记为 $\mathcal{A}$。对任意给定的支配集实例图 $G$，以及任意 $k$，若 $\mathcal{A}$ 在输入 $G$ 上输出的值为 $1$，则 $G$ 一定存在支配集。  
    这是因为：存在支配集当且仅当 $\mathrm{OPT} = 1$，而若 $\mathrm{OPT} = 1$，则
    
    $$
    \mathrm{OPT} \leq \mathrm{ALG} \leq (2 - \varepsilon)\cdot\mathrm{OPT} < 2
    $$
    
    从而 $\mathrm{ALG}$ 必须为 $1$。这就等价于在多项式时间内精确判断一个 NP-Hard 问题。

### 局部搜索：Max-Cut

局部搜索（local search）的思想是，从一个任意解出发，通过一系列“局部修改”不断改进解，直至无法再改进。

**Max Cut 问题**：给定无向图，对顶点集 $V$ 的一个 cut 指的是一个二划分 $\{A, B\}$，其值定义为

$$
c(A, B) = \vert E(A, B) \vert
$$

其中 $E(A, B)$ 是所有一端在 $A$、另一端在 $B$ 的边。目标是找到使 $c(A, B)$ 最大的 cut。

**一个局部搜索算法**：  
1. 从任意划分 $\{A, B\}$ 开始；  
2. 如果把某个顶点从 $A$ 移到 $B$（或从 $B$ 移到 $A$）可以增大 $c(A, B)$，则执行这个移动；  
3. 当不存在任何可以改进的移动时终止。

!!! remarks "分析"

    **时间复杂度**：每次找一个可改进的顶点需要 $O(\vert V \vert)$ 的遍历，而判断一次移动是否有利需要 $O(\vert E \vert)$ 的时间；  
    总共的有效移动次数至多为 $O(\vert E \vert)$。  
    因此总时间复杂度为 $O(\vert V \vert \vert E \vert^2)$。

    **近似保证**：该算法可以保证至少达到 0.5-approx。

    对每个顶点 $u$，最终解中至少有
    
    $$
    \frac{1}{2}\deg u
    $$
    
    条与 $u$ 相 incident 的边跨越了 cut（否则，把 $u$ 移到另一侧可以改进解，与局部最优性矛盾）。  
    因此
    
    $$
    c(A, B) \geq \frac{1}{2}\sum_{u \in V}\frac{1}{2}\deg u = \frac{1}{2}\vert E \vert \geq \frac{1}{2}\mathrm{OPT}.
    $$

    !!! normal-comment "实际上还能做到更好"
        更深入的结果表明：$\displaystyle c(A, B) > \frac{1}{2}\vert E \vert$ 始终成立，并且存在一个著名的 $0.878$-approximation 算法。

