## DFS Tree and Topological Sort

### DFS Tree

By a complete DFS, we can get a subgraph $T$ of the former directed graph $G$, and $T$ is a tree called **DFS Tree**  

Then with the tree we divide the edges of $G$ into 4 groups:  
- Tree edges: the edges in $T$  
- Forward edges: edges from an ancestor to its descendant in $T$  
- Back edges: edges from an descendant to its ancestor in $T$  
- Cross edges: edges cross two subtrees in $T$

```mermaid
flowchart LR
    %% === Nodes ===
    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
    F((F))
    G((G))
    H((H))
    I((I))
    J((J))

%%    %% === Subgraph for DFS Tree ===
%%    subgraph T["DFS Tree T"]
%%        direction LR
%%        A
%%        B
%%        C
%%        D
%%        E
%%        F
%%        G
%%        H
%%        I
%%        J
%%    end

    %% === DFS Tree edges (生成树) ===
    A --> B
    A --> C
    B --> D
    B --> E
    C --> F
    D --> G
    E --> H
    F --> I
    G --> J

    %% === Other edges in G (非树边) ===
    A -->|Forward| H
    C -->|Forward| G
    E -->|Cross| F
    I -->|Cross| D
    H -->|Back| B
    J -->|Cross| E
    
    

    %% === Soft color styling ===
    %% Tree edges: 柔和绿色
    linkStyle 0,1,2,3,4,5,6,7,8 stroke:#6da96f,stroke-width:2px;

    %% Forward edges: 柔和蓝灰
    linkStyle 9,10 stroke:#6b8fb3,stroke-width:2px;

    %% Back edges: 深红棕色虚线
    linkStyle 13 stroke:#b26b6b,stroke-dasharray:4 3,stroke-width:2px;

    %% Cross edges: 暖橙灰色虚线
    linkStyle 11,12,14 stroke:#b28b5c,stroke-dasharray:3 3,stroke-width:2px;
```

### Topological Ordering

Given a directed graph $G$, a **topological order** is an ordering of vertices such that for every directed edge $u, v \in E$, vertex $u$ comes before vertex $v$ in the ordering.

!!! remarks "Theorem"
    1. Topological order exists iff. the graph is a DAG (Directed Acyclic Graph)  
    2. There must exist at least a **sink** in a DAG. (**Sink**: vertices that do not have outgoing edges.)

#### The algorithm to find Topological Order in DAG

Solution 1: (Time complexity $O(\vert V\vert^2)$)

1. Find a sink ($O(\vert V \vert)$)  
2. Put it to be the last one in the topological order  
3. Remove the sink in the graph  
4. Repeat 1.

Solution 2: Improve by DFS

Through DFS we can record some information to find the sink.  
Record the start time and finish time through DFS:

```
time = 0
def DFS(u):
    start[u] = time
    time ++
    
    vis[u] = true
    for each u's neighbour v:
        if vis[v]: continue
        DFS[v]
        
    finish[u] = time
    time ++
```

```mermaid
flowchart LR
    %% === Nodes with (start, finish) time ===
    A(("A<br>(0,19)"))
    B(("B<br>(1,10)"))
    C(("C<br>(11,18)"))
    D(("D<br>(2,5)"))
    E(("E<br>(6,9)"))
    F(("F<br>(12,15)"))
    G(("G<br>(3,4)"))
    H(("H<br>(7,8)"))
    I(("I<br>(13,14)"))
    J(("J<br>(5,6)"))

    %% === DFS Tree edges (生成树) ===
    A --> B
    A --> C
    B --> D
    B --> E
    C --> F
    D --> G
    E --> H
    F --> I
    G --> J

    %% === Other edges in G (无 back edge) ===
    A -->|Forward| H
    C -->|Forward| G
    E -->|Cross| F
    I -->|Cross| D
    J -->|Cross| E

    %% === Legend (explanation of data pair) ===
%%    subgraph Legend["Legend"]
%%        direction TB
        L1["Each node shows (start, finish) —<br>the DFS discovery and finishing times."]
%%    end

    %% === Connect Legend to one node for positioning hint ===
%%    J -.-> L1

    %% === Soft color styling ===
    linkStyle 0,1,2,3,4,5,6,7,8 stroke:#6da96f,stroke-width:2px;
    linkStyle 9,10 stroke:#6b8fb3,stroke-width:2.5px;
    linkStyle 11,12,13 stroke:#b28b5c,stroke-dasharray:3 3,stroke-width:2px;
```

The vertex with the earliest finish time is the sink. So just sort vertices by descending order of finish time. ($O(\vert V \vert \log \vert V \vert)$)

In fact, we haven't to sort afterward: just add the vertex into the topological order list when it finishes. ($O(\vert V \vert + \vert E \vert)$)

??? remarks "Proof"
    **Claim**: No edge $(u, v)$, if `finish[v] > finish[u]`.

    If $(u, v)$ exists,  
    - Can it be a tree/forward edge? Obviously no.  
    - Can it be a cross edge? No! If it exists, the DFS will get through the cross edge!
    - Can it be a back edge? No! There shouldn't exist back edge in DAG!

!!! remarks "DFS can distinguish four types of edges"
    Edge $(u, v)$ in DFS process:  
    - Tree edge: `vis[v] = false`  
    - Forward edge: `vis[v] = true`, `start[u] < start[v] < finish[v] < finish[u]`  
    - Cross edge: `vis[v] = true`, `start[v] < finish[v] < start[u] < finish[u]`  
    - Back edge: `vis[v] = true`, `start[v] < start[u] < finish[u] < finish[v]`


