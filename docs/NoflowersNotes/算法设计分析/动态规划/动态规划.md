
## Dynamic Programming

Dependency of sub-problems forms a DAG, and solve the problem through the topological order.

Two implementations:  
1. Topological Ordering: find a topological ordering and solve it step by step.  
2. Memoization: backward recursion with storing

### Longest Increasing Subsequence (LIS)

Enumerate the last number $a_i$, we have $\displaystyle LIS(a_{i}) = \max_{j < i, a_j < a_i} LIS(a_j) + 1$

```
lis[0] = 0

for i = 1..n:
    lis[i] = max_{j < i, a_j < a_i} lis[j] + 1

return max lis[i]
```

!!! normal-comment "There exists a $O(\log n)$ algorithm!"
    (To be completed)


### Edit Distance

Decide the distance from one string for another. **Distance** is measured by the number of steps of **Insertion, Deletion and Replacement**

**Algorithm**: Let $X[1..m], Y[1..n]$ be the input strings. let $ED[i, j]$ be the edit distance between strings $X[1..i]$ and $Y[1..j]$, then consider the last character, we have:

| Operation                     | Meaning                         | Subproblem        |
| ----------------------------- | ------------------------------- | ----------------- |
| Replace $x_i \rightarrow y_j$ | Fix last char directly          | $ED[i-1,j-1] + 1_{x_i \neq y_j}$ |
| Insert $y_j$                  | Match $y_j$ by adding it to $X$ | $ED[i,j-1] + 1$   |
| Delete $x_i$                  | Remove unmatched $x_i$          | $ED[i-1,j] + 1$   |

$$
ED[i, j] = \min\{ED[i - 1, j - 1] + 1_{x_i \neq y_j}, ED[i, j - 1] + 1, ED[i - 1, j] + 1\}
$$


### Knapsack Problems

Input: $n$ items with cost $c_i$ and value $v_i$, and a capacity $W$.  
Output: Select a subset of items, with total cost at most $W$. The goal is to maximize the total value.

It is an NP-hard problem.

!!! remarks "Why?"
    Assume $c_i = v_i$ for all $i$ and $W$ is half of the total cost $\sum c_i$, then it is reduced into a **partition problem**!

Define $f[i, w]$: the maximum value we can get by using the first $i$ items, and with $w$ budget (the sum of the costs)

| Decision on item $i$ | Meaning                                                    | Subproblem used   |
| -------------------- | ---------------------------------------------------------- | ----------------- |
| **Skip item $i$**    | Do not use this item                                       | $f[i-1, w]$       |
| **Take item $i$**    | Use this item and pay its cost $c_i$ (only if $c_i \le w$) | $f[i-1, w - c_i]$ |


$$
f[i, w] =
\begin{cases}
\max\{f[i-1, w],\; f[i-1, w - c_i] + v_i\} & c_i \leq w, \\
f[i-1, w] & c_i > w .
\end{cases}
$$

!!! remarks "Analysis"
    The time complexity: $O(nW)$, which is not polynomial!

**Any approximate solutions in poly time?**

If we reduce $w$ to $w / K$ which $w / k$ is polynomial in $n$ (reducing precision), we can turn the problem into poly time.  
However, the lost precision in $w$ will cause invalid solutions!

So we have to change the formal algorithm.

Let $V = \max v_i$, Obviously $\mathrm{OPT} \leq nV$. Define new sub-problems:

$A[i, v]$: the minimum cost $\mathrm{cost}(S)$ we can have if we select $S \subseteq\{1, \ldots, n\}$ with value $\mathrm{value}(S) = v$.  
This DP turns knapsack into minimizing cost while fixing value

| Decision on item $i$ | Meaning                                                  | Subproblem used   |
| -------------------- | -------------------------------------------------------- | ----------------- |
| **Skip item $i$**    | Do not use this item                                     | $A[i-1, v]$       |
| **Take item $i$**    | Use this item and gain value $v_i$ (only if $v_i \le v$) | $A[i-1, v - v_i]$ |

$$
A[i, v] =
\begin{cases}
\min\{A[i-1, v],\; A[i-1, v - v_i] + c_i\}, & v_i \le v, \\
A[i-1, v], & v_i > v .
\end{cases}
$$

And return $\max\{v\ |\ A[n, v] \leq W\}$

!!! remarks "analysis"
    Now time complexity $O(n^2 V)$.  

Now choose a large $K$ (decide later), and let $v_i' = \lfloor v_i / K \rfloor$, we can have a poly time approximation.

!!! remarks "Approximation ratio?"

Let $O$ be the optimal bundle in the original set. We gonna decide the lower bound of $\mathrm{value}(S) / \mathrm{value}(O)$.

Due to 

$$
v_i \leq Kv_i' + K
$$

then 

$$
\mathrm{value}(O) - K \mathrm{value}'(O) \leq nK
$$

so

$$
\begin{aligned}
\mathrm{value}(S) &\geq K \cdot \mathrm{value}'(S) \\
 & \geq K \cdot \mathrm{value}'(O) \geq \mathrm{value}(O) - nK \\
 &= \left(1 - \frac{nK}{\mathrm{value}(O)}\right)\mathrm{value}(O) \geq \left(1 - \frac{nK}{V}\right)\mathrm{value}(O)
\end{aligned}
$$



### PTAS and FPTAS -- type of approximation algorithm

Knapsack Problems is an example of FPTAS problem (Fully Polynomial Time Approximation Scheme)

A **PTAS** is an approximation algorithm that, for any $\varepsilon > 0$, returns a solution within a factor of $(1 + \varepsilon)$ for minimization (or $(1 - \varepsilon)$ for maximization).  
For every fixed $\varepsilon$, the running time is polynomial in the input size $n$, but may be exponential in $1/\varepsilon$

An **FPTAS** is a PTAS whose running time is **polynomial in both**:

- the input size $n$, and  
- $1/\varepsilon$


