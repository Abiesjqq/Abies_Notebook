
## Dynamic Programming

Dependency of sub-problems forms a DAG, and solve the problem through the topological order.

Two implementations:  
1. Topological Ordering: find a topological ordering and solve it step by step.  
2. Memoization: backward recursion with storing

### Longest Increasing Subsequence (LIS)

Enumerate the last number $a_i$, we have $\displaystyle LIS(a_{i}) = \max_{j < i, a_j < a_i} LIS(a_j) + 1$

```
lis[0] = 0

for i = 1..n:
    lis[i] = max_{j < i, a_j < a_i} lis[j] + 1

return max lis[i]
```

!!! normal-comment "There exists a $O(\log n)$ algorithm!"
    (To be completed)


### Edit Distance

Decide the distance from one string for another. **Distance** is measured by the number of steps of **Insertion, Deletion and Replacement**

**Algorithm**: Let $X[1..m], Y[1..n]$ be the input strings. let $ED[i, j]$ be the edit distance between strings $X[1..i]$ and $Y[1..j]$, then consider the last character, we have:

| Operation                     | Meaning                         | Subproblem        |
| ----------------------------- | ------------------------------- | ----------------- |
| Replace $x_i \rightarrow y_j$ | Fix last char directly          | $ED[i-1,j-1] + 1_{x_i \neq y_j}$ |
| Insert $y_j$                  | Match $y_j$ by adding it to $X$ | $ED[i,j-1] + 1$   |
| Delete $x_i$                  | Remove unmatched $x_i$          | $ED[i-1,j] + 1$   |

$$
ED[i, j] = \min\{ED[i - 1, j - 1] + 1_{x_i \neq y_j}, ED[i, j - 1] + 1, ED[i - 1, j] + 1\}
$$


### Knapsack Problems

Input: $n$ items with cost $c_i$ and value $v_i$, and a capacity $W$.  
Output: Select a subset of items, with total cost at most $W$. The goal is to maximize the total value.

It is an NP-hard problem.

!!! remarks "Why?"
    Assume $c_i = v_i$ for all $i$ and $W$ is half of the total cost $\sum c_i$, then it is reduced into a **partition problem**!

Define $f[i, w]$: the maximum value we can get by using the first $i$ items, and with $w$ budget (the sum of the costs)

| Decision on item $i$ | Meaning                                                    | Subproblem used   |
| -------------------- | ---------------------------------------------------------- | ----------------- |
| **Skip item $i$**    | Do not use this item                                       | $f[i-1, w]$       |
| **Take item $i$**    | Use this item and pay its cost $c_i$ (only if $c_i \le w$) | $f[i-1, w - c_i]$ |


$$
f[i, w] =
\begin{cases}
\max\{f[i-1, w],\; f[i-1, w - c_i] + v_i\} & c_i \leq w, \\
f[i-1, w] & c_i > w .
\end{cases}
$$

!!! remarks "Analysis"
    The time complexity: $O(nW)$, which is not polynomial!

**Any approximate solutions in poly time?**

If we reduce $w$ to $w / K$ which $w / k$ is polynomial in $n$ (reducing precision), we can turn the problem into poly time.  
However, the lost precision in $w$ will cause invalid solutions!

So we have to change the formal algorithm.

Let $V = \max v_i$, Obviously $\mathrm{OPT} \leq nV$. Define new sub-problems:

$A[i, v]$: the minimum cost $\mathrm{cost}(S)$ we can have if we select $S \subseteq\{1, \ldots, n\}$ with value $\mathrm{value}(S) = v$.  
This DP turns knapsack into minimizing cost while fixing value

| Decision on item $i$ | Meaning                                                  | Subproblem used   |
| -------------------- | -------------------------------------------------------- | ----------------- |
| **Skip item $i$**    | Do not use this item                                     | $A[i-1, v]$       |
| **Take item $i$**    | Use this item and gain value $v_i$ (only if $v_i \le v$) | $A[i-1, v - v_i]$ |

$$
A[i, v] =
\begin{cases}
\min\{A[i-1, v],\; A[i-1, v - v_i] + c_i\}, & v_i \le v, \\
A[i-1, v], & v_i > v .
\end{cases}
$$

And return $\max\{v\ |\ A[n, v] \leq W\}$

!!! remarks "analysis"
    Now time complexity $O(n^2 V)$.  

Now choose a large $K$ (decide later), and let $v_i' = \lfloor v_i / K \rfloor$, we can have a poly time approximation.

!!! remarks "Approximation ratio?"

Let $O$ be the optimal bundle in the original set. We gonna decide the lower bound of $\mathrm{value}(S) / \mathrm{value}(O)$.

Due to 

$$
v_i \leq Kv_i' + K
$$

then 

$$
\mathrm{value}(O) - K \mathrm{value}'(O) \leq nK
$$

so

$$
\begin{aligned}
\mathrm{value}(S) &\geq K \cdot \mathrm{value}'(S) \\
 & \geq K \cdot \mathrm{value}'(O) \geq \mathrm{value}(O) - nK \\
 &= \left(1 - \frac{nK}{\mathrm{value}(O)}\right)\mathrm{value}(O) \geq \left(1 - \frac{nK}{V}\right)\mathrm{value}(O)
\end{aligned}
$$



### PTAS and FPTAS -- type of approximation algorithm

Knapsack Problems is an example of FPTAS problem (Fully Polynomial Time Approximation Scheme)

A **PTAS** is an approximation algorithm that, for any $\varepsilon > 0$, returns a solution within a factor of $(1 + \varepsilon)$ for minimization (or $(1 - \varepsilon)$ for maximization).  
For every fixed $\varepsilon$, the running time is polynomial in the input size $n$, but may be exponential in $1/\varepsilon$

An **FPTAS** is a PTAS whose running time is **polynomial in both** the input size $n$, and $1/\varepsilon$.

### Floyd-Warshall Algorithm

All pairs shortest paths:  
**Input** a directed weighted graph $G = (V, E, w)$  
**Output** $dist(u, v)$ for all pairs of vertices.

Actually, running Bellman-Ford algorithm for all vertices will cost about $O(\vert V \vert^2 \vert E \vert)$ time (also check if negative cycle exists). By Floyd-Warshall, it will be $O(\vert V \vert^3)$

**Subproblem**: label all vertices by $1, 2, \ldots, n$, $\operatorname{dist}_k(i, j)$ the distance between $i$ and $j$ by only using intermediate vertices form $\{1, 2, \ldots, k\}$.

Obviously

$$
\operatorname{dist}_{k + 1}(i, j) = \min \{\operatorname{dist}_k(i, j), \operatorname{dist}_k(i, k + 1), \operatorname{dist}_k(k + 1, j)\}
$$

So it is a $O(\vert V \vert^3)$ algorithm (Let $d(i, j, k) = \operatorname{dist}_k(i, j)$). A natural topological order: increasing order in $k$; order of vertices in $d(\cdot, \cdot, k)$ can be arbitrary.

Initialization:

$$
d(i, j, 0) = \begin{cases}
    \infty, & \quad i \neq j, (i, j) \notin E \\
    w(i, j) & \quad (i, j) \in E \\
    0, &\quad i = j
\end{cases}
$$

!!! remarks "A Trick"
    There is a trick to reduce the space complexity from $O(\vert V \vert^3)$ to $O(\vert V \vert^2)$: due to the update order (we never use layers before $k$ at $k + 1$ iteration), the new $k + 1$ layer could overlap the $k$ layer.  
    Now 

    $$
    d(i, j) = \min \{d(i, j), d(i, k + 1) + d(k + 1, j)\}
    $$

    Actually a lot of DPs can apply this trick!

    Notice: If we view $d(i, j)$ as subproblems, the dependency does NOT form a DAG.

### DP with Exhaustive Searches: Non-attacking Kings

Given an $m \times n$ chessboard, **how many different ways** we can place "Kings" such that no pair of them are in the attack range ($3 \times 3$ centered) of each other.  
We will design a DP based algorithm with $O(4^n m)$ time.

Let $H(i)$: number of placements on the $i \times n$ sub-chessboard

Simply build relationship from $H(0), \ldots, H(i - 1)$ is hard because such $H(i)$ does not contain enough information! (whether its border has Kings and where, i.e. the information of row $i$).

**Encoding Availability of a Row**

Use a length-$n$ binary string $w$ to encode availability:  
- $w[i] = 0$ if the $i$-th cell of this row can put a King (available)  
- $w[i] \neq 0$ if the $i$-th cell of this row cannot put a King (unavailable)

Then we define $H[i, w]$: number of placements such that the availability of the cells at the $i$-th row follows $w$

Then the feasible state transition:

$$
H[i + 1, w_0] = \sum_{\substack{w \text{ feasible} \\\text{for }w_0 \\ \text{in row }i}}H[i, w]
$$

and $w$ feasible iff.

$$
\begin{aligned}
    &\texttt{(s \& t) == 0} \\
    \texttt{\&\& } &\texttt{(s \& (t << 1)) == 0} \\
    \texttt{\&\& } &\texttt{((s << 1) \& t) == 0}
\end{aligned}
$$

!!! remarks "Analysis"
    $m$ rows; each row: $2^n$ atates; each row, each state: at most $2^n$ placements of Kings.  
    Overall time complexity: $O(4^n m)$

### DP on Trees: Maximum Independent Set on Trees

Given an undirected tree $G(V, E)$, find an independent set with maximum number of vertices.

!!! normal-comment "Independent set here"
    Independent set $S$ here meas $\forall u, v \in S, (u, v) \notin E$, which is aligned with the independent set definition before.

!!! remarks "Maximize independent set"
    It is **NP-hard** in normal undirected graphs (because _Maximum Clique_ is NP-Hard, and the independent set in $G(V, E)$ is the clique in $\overline{G}(V, \overline{E})$)

In a subtree,  
- If we choose the root, we should decide the problems from 2-deeper subtrees.  
- If we do not choose the root, we should decide the problems from 1-deeper subtrees.

Let $H[u]$: the maximized size of independent set of the subtree rooted at $v$

$$
H[v] = \max \left\{\sum_{u \in \operatorname{Children}(v)} H[u], 1 + \sum_{u \in \operatorname{GrandChildren}(v)} H[u]\right\}
$$

And the recurrence comes from leaves to root.

!!! remarks "Analysis"
    Each vertex is processed once and each $H[u]$ is looked up for twice: $O(\vert V \vert)$

!!! normal-comment "Actually Greedy solution is also correct"
    To be completed...


## Some Exercises

Given a sequence $h_i \leq H, i = 1, \ldots, n$, find a non-decreasing sequence $h_i'$ and minimize $\sum_{i = 1}^n |h_i - h_i'|$.

Define $f(i, h)$: choose at most $h$ at the $h_i'$, and

$$
f(i, h) = \min_{0 \leq h_i' \leq h}\{f(i - 1, h_i') + |h_i - h_i'|\}
$$

$O(nH^2)$

Given three string $A, B, C$, decide if $C$ can be decomposed to $A, B$, for example, $C = 1742435, A = 1245, B = 743$ is true.

Let $f(i, j)$ be $A[1:i + 1], B[1:j + 1], C[1:i + j + 1]$ subproblem.  
Update $f$ by compare the last character:

$$
f(i, j) = f(i - 1, j)_{A[i] = C[i + j]} \lor f(i, j - 1)_{B[j] = C[i + j]}
$$