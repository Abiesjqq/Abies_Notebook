## 动态规划（Dynamic Programming）

很多问题的子问题依赖关系可以表示成一个 DAG，我们按照这个 DAG 的拓扑序自底向上求解，就得到了动态规划的思路。

常见的实现方式有两种：  
1. **按拓扑序迭代**：先找出一个拓扑序，再按这个顺序依次计算子问题；  
2. **记忆化搜索**：写出自顶向下的递归，同时用数组 / 哈希表记录已经算过的状态。

### 最长上升子序列（Longest Increasing Subsequence, LIS）

枚举最后一个数 $a_i$，有

$$
LIS(a_{i}) = \max_{j < i, a_j < a_i} LIS(a_j) + 1
$$

对应的朴素 DP 实现：

```
lis[0] = 0

for i = 1..n:
    lis[i] = max_{j < i, a_j < a_i} lis[j] + 1

return max lis[i]
```

!!! normal-comment "其实还存在一个 $O(\log n)$ 的算法"
    （留待补充）


### 编辑距离（Edit Distance）

衡量一个字符串变成另一个字符串所需的最少操作次数。  
这里的 **距离** 按三种操作的总次数来计算：**插入（Insertion）、删除（Deletion）、替换（Replacement）**。

**算法**：设输入字符串为 $X[1..m], Y[1..n]$。记 $ED[i, j]$ 为 $X[1..i]$ 与 $Y[1..j]$ 的编辑距离。考虑最后一个字符的匹配方式，有：

| Operation                     | Meaning                         | Subproblem        |
| ----------------------------- | ------------------------------- | ----------------- |
| Replace $x_i \rightarrow y_j$ | 直接把最后一个字符改成 $y_j$    | $ED[i-1,j-1] + 1_{x_i \neq y_j}$ |
| Insert $y_j$                  | 在 $X$ 末尾插入 $y_j$ 来匹配它  | $ED[i,j-1] + 1$   |
| Delete $x_i$                  | 删掉当前多余的 $x_i$           | $ED[i-1,j] + 1$   |

于是递推式为

$$
ED[i, j] = \min\{ED[i - 1, j - 1] + 1_{x_i \neq y_j}, ED[i, j - 1] + 1, ED[i - 1, j] + 1\}
$$


### 背包问题（Knapsack Problems）

输入：$n$ 个物品，每个物品有成本 $c_i$ 和价值 $v_i$，背包容量为 $W$。  
输出：选取一个物品子集，使得总成本不超过 $W$，并且总价值最大。

这是一个 NP-hard 问题。

!!! remarks "为什么是 NP-hard？"
    如果令所有 $c_i = v_i$，并且 $W$ 取为 $\sum c_i$ 的一半，那么问题就退化成了经典的 **partition problem**。

先来看标准 0-1 背包的 DP：

定义 $f[i, w]$：只考虑前 $i$ 个物品，总成本不超过 $w$ 时能取得的最大总价值。

| 对物品 $i$ 的决策 | 含义                                          | 子问题           |
| ----------------- | --------------------------------------------- | ---------------- |
| **不选物品 $i$**  | 不使用该物品                                 | $f[i-1, w]$      |
| **选物品 $i$**    | 使用该物品并支付成本 $c_i$（需满足 $c_i \le w$） | $f[i-1, w - c_i]$ |

递推式：

$$
f[i, w] =
\begin{cases}
\max\{f[i-1, w],\; f[i-1, w - c_i] + v_i\} & c_i \leq w, \\
f[i-1, w] & c_i > w .
\end{cases}
$$

!!! remarks "复杂度分析"
    这一 DP 的时间复杂度是 $O(nW)$，并不是“真正意义上的多项式时间”。

**能否在多项式时间内做近似？**

如果直接把 $w$ 缩放为 $w / K$，让 $w / K$ 关于 $n$ 是多项式量级（牺牲精度），可以把问题变成多项式时间；  
但这样会导致容量精度损失，使得构造出的解可能不合法。

所以需要从算法形式上做一些改变。

设 $V = \max v_i$，显然 $\mathrm{OPT} \leq nV$。我们重新定义子问题：

令 $A[i, v]$ 表示在只考虑前 $i$ 个物品时，要达到总价值 $v$ 所需的最小成本 $\mathrm{cost}(S)$（其中 $S \subseteq \{1, \ldots, i\}$ 且 $\mathrm{value}(S) = v$）。  
这个 DP 把背包问题转化成了“在价值固定时最小化成本”。

| 对物品 $i$ 的决策 | 含义                                     | 子问题           |
| ----------------- | ---------------------------------------- | ---------------- |
| **不选物品 $i$**  | 不使用该物品                             | $A[i-1, v]$      |
| **选物品 $i$**    | 使用该物品并获得价值 $v_i$（需 $v_i \le v$） | $A[i-1, v - v_i]$ |

递推式：

$$
A[i, v] =
\begin{cases}
\min\{A[i-1, v],\; A[i-1, v - v_i] + c_i\}, & v_i \le v, \\
A[i-1, v], & v_i > v .
\end{cases}
$$

最终返回 $\max\{v\ |\ A[n, v] \leq W\}$。

!!! remarks "复杂度分析"
    在这种写法下，时间复杂度变为 $O(n^2 V)$。

现在选取一个较大的常数 $K$（具体值稍后讨论），定义 $v_i' = \lfloor v_i / K \rfloor$，这样就能得到一个多项式时间的近似算法。

!!! remarks "近似比（Approximation ratio）"

设 $O$ 是原问题中的最优解，对应子集为 $O$，我们希望给出 $\mathrm{value}(S) / \mathrm{value}(O)$ 的下界。

注意到

$$
v_i \leq Kv_i' + K
$$

于是

$$
\mathrm{value}(O) - K \mathrm{value}'(O) \leq nK
$$

从而

$$
\begin{aligned}
\mathrm{value}(S) &\geq K \cdot \mathrm{value}'(S) \\
 & \geq K \cdot \mathrm{value}'(O) \geq \mathrm{value}(O) - nK \\
 &= \left(1 - \frac{nK}{\mathrm{value}(O)}\right)\mathrm{value}(O) \geq \left(1 - \frac{nK}{V}\right)\mathrm{value}(O)
\end{aligned}
$$



### PTAS 与 FPTAS —— 近似算法的类型

背包问题是一个 FPTAS 的经典例子（Fully Polynomial Time Approximation Scheme，完全多项式时间近似方案）。

**PTAS**：给定任意 $\varepsilon > 0$，算法返回的解与最优解之比在 $(1 + \varepsilon)$ 以内（最小化问题）或 $(1 - \varepsilon)$ 以内（最大化问题）。  
对每个固定的 $\varepsilon$，算法的运行时间关于输入规模 $n$ 是多项式的，但可能对 $1/\varepsilon$ 是指数级的。

**FPTAS**：是一类特殊的 PTAS，它的运行时间不仅对 $n$ 是多项式的，对 $1/\varepsilon$ 也是多项式的。

### Floyd-Warshall 算法

要解决的是 **全源最短路（All-pairs shortest paths）** 问题：  
**输入**：带权有向图 $G = (V, E, w)$；  
**输出**：对任意一对顶点 $(u, v)$，给出 $dist(u, v)$。

如果对每个顶点分别运行一次 Bellman-Ford，总时间大约为 $O(\vert V \vert^2 \vert E \vert)$（顺便也可以检查负环）。  
Floyd-Warshall 则能在 $O(\vert V \vert^3)$ 的时间里完成。

**子问题设计**：给所有顶点标号为 $1, 2, \ldots, n$，记 $\operatorname{dist}_k(i, j)$ 为只允许经过中间点集合 $\{1, 2, \ldots, k\}$ 的情况下，从 $i$ 到 $j$ 的最短路长度。

显然有递推关系：

$$
\operatorname{dist}_{k + 1}(i, j) = \min \{\operatorname{dist}_k(i, j), \operatorname{dist}_k(i, k + 1) + \operatorname{dist}_k(k + 1, j)\}
$$

于是可以得到一个 $O(\vert V \vert^3)$ 的算法（记 $d(i, j, k) = \operatorname{dist}_k(i, j)$）。自然的拓扑序是按 $k$ 递增；在固定的 $k$ 层内，顶点的顺序可以任意。

初始化：

$$
d(i, j, 0) = \begin{cases}
    \infty, & \quad i \neq j, (i, j) \notin E \\
    w(i, j) & \quad (i, j) \in E \\
    0, &\quad i = j
\end{cases}
$$

!!! remarks "一个常用的小技巧"
    可以把空间复杂度从 $O(\vert V \vert^3)$ 降到 $O(\vert V \vert^2)$：  
    由于在计算第 $k + 1$ 层时不会再用到更早的层，所以我们可以直接在同一个二维数组上原地更新。  
    也就是说把递推式写成

    $$
    d(i, j) = \min \{d(i, j), d(i, k + 1) + d(k + 1, j)\}
    $$

    实际上，很多 DP 都可以用类似的“滚动数组”技巧来节省空间。

    需要注意的是，如果直接把 $d(i, j)$ 看成子问题，那么它们之间的依赖关系并不构成一个 DAG。

### 带枚举状态的 DP：不互相攻击的国王（Non-attacking Kings）

给定一个 $m \times n$ 的棋盘，问有多少种放置“国王”的方法，使得任意两个国王都不在彼此的攻击范围内（即任意两个国王之间的曼哈顿距离都不在中心 $3 \times 3$ 的区域内）。  
我们将给出一个时间复杂度为 $O(4^n m)$ 的 DP 算法。

设 $H(i)$ 为在前 $i$ 行（一个 $i \times n$ 的子棋盘）上的合法放置方案数。

直接尝试从 $H(0), \ldots, H(i - 1)$ 推出 $H(i)$ 比较困难，因为 $H(i)$ 本身并不包含关于第 $i$ 行边界的足够信息（例如第 $i$ 行哪些位置已经放置了国王）。

**行状态的编码方式**

用一个长度为 $n$ 的二进制串 $w$ 来表示一行的“可用性”：  
- 若第 $i$ 列仍然可以放国王，则 $w[i] = 0$；  
- 若第 $i$ 列不再允许放国王，则 $w[i] \neq 0$。

于是定义 $H[i, w]$ 为在前 $i$ 行棋盘上、并且第 $i$ 行的可用性状态为 $w$ 的摆放方案数。

可行的状态转移为：

$$
H[i + 1, w_0] = \sum_{\substack{w \text{ feasible} \\\text{for }w_0 \\ \text{in row }i}}H[i, w]
$$

其中 $w$ 与 $w_0$ 的“可行性”可以通过位运算判断：

$$
\begin{aligned}
    &\texttt{(s \& t) == 0} \\
    \texttt{\&\& } &\texttt{(s \& (t << 1)) == 0} \\
    \texttt{\&\& } &\texttt{((s << 1) \& t) == 0}
\end{aligned}
$$

!!! remarks "复杂度分析"
    一共有 $m$ 行；每一行有 $2^n$ 个可能的状态；  
    对于每一行的每个状态，最多需要枚举 $2^n$ 个上一行的状态。  
    因此总时间复杂度为 $O(4^n m)$。

### 树上的 DP：树的最大独立集（Maximum Independent Set on Trees）

给定一棵无向树 $G(V, E)$，求一个顶点数最大的独立集。

!!! normal-comment "独立集的定义"
    在这里，独立集 $S$ 是指满足 $\forall u, v \in S, (u, v) \notin E$ 的顶点集合，与之前图论中独立集的定义一致。

!!! remarks "一般图上的情况"
    在一般无向图中，最大独立集问题是 **NP-hard** 的（因为 _Maximum Clique_ 是 NP-hard，而在补图 $\overline{G}(V, \overline{E})$ 中，独立集正好对应原图中的团）。

在树上则可以用 DP 高效求解。考虑一棵子树：  
- 如果我们选取了根节点，那么它的所有直接子节点都不能再选，只能转到“孙子节点”的子树上去选；  
- 如果不选根节点，则可以在它的所有子节点的子树中独立做选择。

令 $H[v]$ 为以 $v$ 为根的子树中最大独立集的大小，则有

$$
H[v] = \max \left\{\sum_{u \in \operatorname{Children}(v)} H[u],\; 1 + \sum_{u \in \operatorname{GrandChildren}(v)} H[u]\right\}
$$

递推顺序是从叶子往根的方向进行。

!!! remarks "复杂度分析"
    每个顶点只会被处理一次，并且每个 $H[u]$ 只会被访问常数次，因此总的时间复杂度为 $O(\vert V \vert)$。

!!! normal-comment "实际上这里也存在一个贪心解法"
    细节留待之后补充。

